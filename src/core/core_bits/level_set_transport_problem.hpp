
/*
 *       /\        Matteo Cicuttin (C) 2017,2018
 *      /__\       matteo.cicuttin@enpc.fr
 *     /_\/_\      École Nationale des Ponts et Chaussées - CERMICS
 *    /\    /\
 *   /__\  /__\    This is ProtoN, a library for fast Prototyping of
 *  /_\/_\/_\/_\   Numerical methods.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * If you use this code or parts of it for scientific publications, you
 * are required to cite it as following:
 *
 * Implementation of Discontinuous Skeletal methods on arbitrary-dimensional,
 * polytopal meshes using generic programming.
 * M. Cicuttin, D. A. Di Pietro, A. Ern.
 * Journal of Computational and Applied Mathematics.
 * DOI: 10.1016/j.cam.2017.09.017
 */

#pragma once


#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <cmath>
#include <memory>
#include <sstream>
#include <list>
#include <map>
#include <iomanip>

#include <Eigen/Dense>
#include <Eigen/SparseCore>
#include <Eigen/SparseLU>
#include <unsupported/Eigen/SparseExtra>
#include <Spectra/SymEigsSolver.h>
#include <Spectra/MatOp/SparseSymMatProd.h>

#include <unsupported/Eigen/MatrixFunctions> // ADD BY STEFANO

using namespace Eigen;

#include "core/core"
#include "core/solvers"
#include "dataio/silo_io.hpp"

#include "methods/hho"
#include "methods/cuthho"


#include "methods/cuthho_bits/cuthho_export.hpp"


namespace random_functions{



    template <typename T> int sgn(T val) {
        return (T(0) < val) - (val < T(0));
    }




    int binomial_coeff_fx(int n, int k) {

        int C[n + 1][k + 1];
        int i, j;

// Caculate value of Binomial Coefficient
// in bottom up manner
        for (i = 0; i <= n; i++) {
            for (j = 0; j <= std::min(i, k); j++) {
// Base Cases
                if (j == 0 || j == i)
                    C[i][j] = 1;

// Calculate value using previously
// stored values
                else
                    C[i][j] = C[i - 1][j - 1] +
                              C[i - 1][j];
            }
        }

        return C[n][k];
    }

    template<typename T, typename Mesh>
    bool
    pt_in_cell(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &cl) {
        auto pts = points(msh, cl);

//std::cout<<"Point to find "<<std::setprecision(15)<<point_to_find.x()<<", "<<point_to_find.y()<<std::endl;

// std::cout<<"Min x "<<std::setprecision(15)<<pts[0].x()<<", max x "<<pts[1].x()<<std::endl;

//std::cout<<"Min y "<<std::setprecision(15)<<pts[1].y()<<", max y "<<pts[2].y()<<std::endl;

        T epsilon = 1e-10;
        if ((pts[0].x() - epsilon) <= point_to_find.x() && (pts[1].x() + epsilon) >= point_to_find.x() &&
            (pts[1].y() - epsilon) <= point_to_find.y() && (pts[2].y() + epsilon) >= point_to_find.y())
            return TRUE;
        else
            return FALSE;

    }

    template<typename T, typename Mesh>
    bool
    pt_in_cell_approximated(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &cl) {
        auto pts = points(msh, cl);

//std::cout<<"Point to find "<<std::setprecision(15)<<point_to_find.x()<<", "<<point_to_find.y()<<std::endl;

// std::cout<<"Min x "<<std::setprecision(15)<<pts[0].x()<<", max x "<<pts[1].x()<<std::endl;

//std::cout<<"Min y "<<std::setprecision(15)<<pts[1].y()<<", max y "<<pts[2].y()<<std::endl;

        T epsilon = 1e-3;
        if ((pts[0].x() - epsilon) <= point_to_find.x() && (pts[1].x() + epsilon) >= point_to_find.x() &&
            (pts[1].y() - epsilon) <= point_to_find.y() && (pts[2].y() + epsilon) >= point_to_find.y())
            return TRUE;
        else
            return FALSE;

    }

    template<typename T, typename Mesh>
    size_t
    pt_in_subcell(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {

        for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if (pt_in_cell(msh, point_to_find, cl)) // pt_in_cell
                return offset_subcells;
        }

        for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if (pt_in_cell_approximated(msh, point_to_find, cl)) // pt_in_cell
                return offset_subcells;
        }
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
        std::cout << "the point did not find is " << point_to_find << std::endl;
        std::cout << "IT DIDN'T FIND THE POINT IN SUBCELL " << offset(msh, agglocl) << std::endl;
        std::cout << "CELL vertices:" << '\n';
        for (auto &pt: points(msh, agglocl))
            std::cout << " , pt = " << pt;
        std::cout << '\n' << std::endl;
        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");

    }

    template<typename T, typename Mesh>
    size_t
    pt_in_subcell_APPROX(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {

        for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if (pt_in_cell_approximated(msh, point_to_find, cl))
                return offset_subcells;
        }
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
        std::cout << "the point did not find is " << point_to_find << std::endl;
        std::cout << "IT DIDN'T FIND THE POINT IN SUBCELL(sbagliata) " << offset(msh, agglocl) << std::endl;
        std::cout << "CELL vertices:" << '\n';
        for (auto &pt: points(msh, agglocl))
            std::cout << " , pt = " << pt;
        std::cout << '\n' << std::endl;
        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");

    }

    template<typename T, typename Mesh>
    std::vector <size_t>
    pt_in_skeleton(const Mesh &msh, const point<T, 2> &point_to_find) {
        std::vector <size_t> cells_offset;
        for (auto &cl: msh.cells) {
            for (auto &offset_subcells: cl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
                auto cl = msh.cells[offset_subcells];
                if (pt_in_cell(msh, point_to_find, cl))
                    cells_offset.push_back(offset_subcells);

            }
        }
        return cells_offset;
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

    }


    template<typename T, typename Mesh>
    std::vector <size_t>
    pt_in_subcell_skeleton(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {
        std::vector <size_t> cells_offset;
        for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if (pt_in_cell(msh, point_to_find, cl))
                cells_offset.push_back(offset_subcells);

        }
        return cells_offset;
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

    }



    template<typename T>
    std::vector <point<T, 1>>
    reference_nodes(size_t);


    /// Each mesh has memory of the original nodes: useful to link agglomerated - original mesh
    template<typename Mesh>
    void offset_definition(Mesh &msh) {
//size_t counter = 0;
        for (auto &cl: msh.cells) {
            auto offset_orig = offset(msh, cl);
//if( !cl.user_data.offset_subcells.empty() )
//   cl.user_data.offset_subcells.erase( cl.user_data.offset_subcells.begin(),cl.user_data.offset_subcells.end() ) ;
            cl.user_data.offset_subcells.push_back(offset_orig);
// counter++;
// std::cout<<"Initialisation cell num "<< cl.user_data.offset_subcells[offset_orig]<<std::endl;
        }
    }


    template<typename T>
    std::vector <point<T, 1>>
    reference_nodes_ordered(size_t degree) {
        auto comp_degree = degree + 1;
        size_t reqd_nodes = comp_degree;

        std::vector <point<T, 1>> ret;
        ret.reserve(reqd_nodes);

        point<T, 1> qp, qp_1;
        T a1, a2;
        T delta_x;
        switch (reqd_nodes) {
            case 1:
                qp = point<T, 1>({
                                         0.0
                                 });
                ret.push_back(qp);
                return ret;

            case 2:
                qp = point<T, 1>({
                                         1.0
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                return ret;

            case 3:
                qp = point<T, 1>({
                                         1.0
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                qp = point<T, 1>({0.0});
                ret.push_back(qp);
                return ret;

            case 4:
                a1 = 1.0 / 3.0;
                qp = point<T, 1>({1.0});
                ret.push_back(-qp);
                ret.push_back(qp);
                qp = point<T, 1>({a1});
                ret.push_back(-qp);
                ret.push_back(qp);
                return ret;

            case 5:
// Be carefull in what order data is inserted in ret!
// In Gauss Legendre the first one was 0.0, now is the last one
                a2 = 0.5;
                a1 = 1.0;
                qp = point<T, 1>({a1});
                ret.push_back(-qp);
                ret.push_back(qp);

                qp = point<T, 1>({a2});
                ret.push_back(-qp);
                qp_1 = point<T, 1>({0.0});
                ret.push_back(qp_1);
                ret.push_back(qp);

//   qp = point<T,1>({ 0.0 });
//   ret.push_back( qp );
                return ret;

            default:

                delta_x = 2.0 / degree;
                a1 = 1.0;
                while (a1 > 1e-10) {
                    qp = point<T, 1>({
                                             a1
                                     });
                    ret.push_back(-qp);
                    ret.push_back(qp);
                    a1 -= delta_x;

                }
                if (a1 < 1e-10 && a1 > -1e-10) {
                    qp = point<T, 1>({
                                             0.0
                                     });
                    ret.push_back(qp);
                }
                std::sort(ret.begin() + 2, ret.end(), [](point<T, 1> a, point<T, 1> b) {
                    return a.x() < b.x();
                });
                return ret;
        }
        return ret;
    }

// Lagrangian basis b_kl(x,y) = b_k(x)*b_l(y) over a set of equidistributed 2-dimensional nodes (3D CASE NOT YET IMPLEMENTED)

    template<typename T, typename Mesh>
    std::vector <point<T, 2>>
    equidistriduted_nodes_ordered_bis(const Mesh &msh,
                                      const typename Mesh::cell_type &cl,
                                      size_t degree) {
        typedef typename Mesh::point_type point_type;

        auto qps = reference_nodes_ordered<T>(degree); //Ordering:  0 2 3 4 5 6 ... 1

// 3 -  12 - 11 - 10 - 2
// 13 - 22 - 21 - 20 - 9
// 14 - 23 - 24 - 19 - 8
// 15 - 16 - 17 - 18 - 7
// 0 -  4 -  5  - 6  - 1

        auto pts = points(msh, cl);

//auto v0 = pts[1] - pts[0];
//auto v1 = pts[2] - pts[1];
//auto v2 = pts[3] - pts[2];
//auto v3 = pts[3] - pts[0];

        std::vector <point<T, 2>> ret((degree + 1) * (degree + 1));

        auto P = [&](T xi, T eta) -> T {
            return 0.25 * pts[0].x() * (1 - xi) * (1 - eta) +
                   0.25 * pts[1].x() * (1 + xi) * (1 - eta) +
                   0.25 * pts[2].x() * (1 + xi) * (1 + eta) +
                   0.25 * pts[3].x() * (1 - xi) * (1 + eta);
        };

        auto Q = [&](T xi, T eta) -> T {
            return 0.25 * pts[0].y() * (1 - xi) * (1 - eta) +
                   0.25 * pts[1].y() * (1 + xi) * (1 - eta) +
                   0.25 * pts[2].y() * (1 + xi) * (1 + eta) +
                   0.25 * pts[3].y() * (1 - xi) * (1 + eta);
        };

/// ADDING VERTICES:

// (-1,-1)
        auto qp_x = qps[0];
        auto qp_y = qps[0];
        auto xi = qp_x.x();
        auto eta = qp_y.x();
        auto px = P(xi, eta);
        auto py = Q(xi, eta);
        ret[0] = (point_type(px, py));

        if (degree == 0)
            return ret;

// (1,-1)
        qp_x = qps[1];
        qp_y = qps[0];
        xi = qp_x.x();
        eta = qp_y.x();
        px = P(xi, eta);
        py = Q(xi, eta);
        ret[1] = (point_type(px, py));
// (1,1)
        qp_x = qps[1];
        qp_y = qps[1];
        xi = qp_x.x();
        eta = qp_y.x();
        px = P(xi, eta);
        py = Q(xi, eta);
        ret[2] = (point_type(px, py));
// (-1,1)
        qp_x = qps[0];
        qp_y = qps[1];
        xi = qp_x.x();
        eta = qp_y.x();
        px = P(xi, eta);
        py = Q(xi, eta);
        ret[3] = (point_type(px, py));

/// Counter for each side of the 2D - square : starting to count from a vertice, the position where I save the point in ret is (degree -1)*j , with j the j-esima face.

        int count0 = 4, count1 = 4 + degree - 1, count2 = 4 + 2 * (degree - 1), count3 = 4 + 3 * (degree - 1);

        int count_bis0 = 4 * degree; // counter initialisation (USELESS)
        int j_max = floor((degree - 1) / 2); // number of internal layour of points
//  std::cout<<"j max "<<j_max<<std::endl;
        int pos_right = 100; // initial point from the right from bottom -> up
        int pos_left = 100; // initial point from the left from left -> right
// size_t i_min = 0;
//   std::cout<<"inizia ciclo"<<std::endl;
        for (int j = 0; j <= j_max; j++) { // for each layout of point
// bool i_loop = FALSE;
            for (int i = std::max(0, j - 1);
                 i < degree - 1 - j; i++) // I move from into the points over a side of each layout
            {

                if (i == std::max(0, j - 1) && j > 0) // vertices
                {
// different pos_left depending on the layout. Especially this rules the y starting point
                    if (j == 0)
                        pos_left = 0;
                    else if (j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2 + (j - 1);

//   std::cout<<"pos_left "<<pos_left<<std::endl;
                    qp_x = qps[2 + i];
                    qp_y = qps[pos_left]; //qps[0 + 2*j];
//   std::cout<<"qp_y "<<qp_y<<std::endl;
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
// Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                    count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
//std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                    ret[count_bis0] = (point_type(px, py)); // adding point bottom layout
//std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count0]<<std::endl;
                    count_bis0++;

                    if (j == 0)
                        pos_right = 1;
                    else
                        pos_right = degree + 1 - j;
// size_t pos = (1 + j*(degree-1));
// if(pos>degree)
//     pos -= j*degree ;

                    qp_x = qps[pos_right];
                    qp_y = qps[2 + i];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count_bis0] = (point_type(px, py)); // adding point right layout in count_bis0 pos.
//std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
//std::cout<<"count_bis0 is "<<count_bis0<<std::endl;
//std::cout<<ret[count_bis0]<<std::endl;
                    count_bis0++;

                    qp_x = qps[degree - i];
                    qp_y = qps[pos_right];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count_bis0] = (point_type(px, py)); // adding point top layout in count_bis0 pos.
//std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
//std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;

                    count_bis0++;
                    qp_x = qps[pos_left];
                    qp_y = qps[degree - i];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count_bis0] = (point_type(px, py)); // adding point left layout in count_bis0 pos.
//std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
//std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                    count_bis0++;

// Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                    count0 = count_bis0;
                    count1 = count0 + degree - 1.0 - 2.0 * j; //  count0 + (degree - 2); it was
                    count2 = count1 + degree - 1.0 - 2.0 * j;
                    count3 = count2 + degree - 1.0 - 2.0 * j;


                } else // NOT vertices -> node in the sides of each layout
                {

//   std::cout<<"i "<<i<<" j "<<j<<std::endl;
// vertical position where starting for each bottom side layout.
                    if (j == 0)
                        pos_left = 0;
                    else if (j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2 + (j - 1);

//   std::cout<<"pos_left "<<pos_left<<std::endl;
                    qp_x = qps[2 + i];
                    qp_y = qps[pos_left]; //qps[0 + 2*j];
//   std::cout<<"qp_y "<<qp_y<<std::endl;
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count0] = (point_type(px, py)); // from left, node of each bottom side layout
//std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count0]<<std::endl;
                    count0++;
// x-position where to start to increase to get points for each right side layout of points
                    if (j == 0)
                        pos_right = 1;
                    else
                        pos_right = degree + 1 - j;
// size_t pos = (1 + j*(degree-1));
// if(pos>degree)
//     pos -= j*degree ;

                    qp_x = qps[pos_right];
                    qp_y = qps[2 + i];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count1] = (point_type(px, py)); // using count1 that allows correct enumeration
//std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count1]<<std::endl;
                    count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                    qp_x = qps[degree - i];
                    qp_y = qps[pos_right];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count2] = (point_type(px, py));
//std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;
                    count2++; // count2 just enumerate top faces' layout

                    qp_x = qps[pos_left];
                    qp_y = qps[degree - i];
                    xi = qp_x.x();
                    eta = qp_y.x();
                    px = P(xi, eta);
                    py = Q(xi, eta);
                    ret[count3] = (point_type(px, py));
//std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                    count3++; // count3 just enumerate left faces' layout


                }
            }
// Updating for the next layout.
            count0 = count3;
            count1 = count0 + (degree - 2 * (j + 1)); //  count0 + (degree - 2); it was
            count2 = count1 + (degree - 2 * (j + 1));
            count3 = count2 + (degree - 2 * (j + 1));


//}
        }

/// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
        if (degree % 2 == 0) {
            qp_x = qps[degree - floor((degree - 1) / 2)];
            qp_y = qps[degree - floor((degree - 1) / 2)];
            xi = qp_x.x();
            eta = qp_y.x();
            px = P(xi, eta);
            py = Q(xi, eta);
            ret[count0] = (point_type(px, py));
//std::cout<<"counto MIDDLE is "<<count0<<" , pt3"<<point_type(px, py)<<std::endl;
        }
        return ret;
    }


/// Lagrangian nodes saved in each cell of orginal mesh -> useful for connecting HHO velocity field and transport velocity field
    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    void nodes_Lagrangian_cell_definition(Mesh &msh, size_t degree) {
//size_t counter = 0;
        for (auto &cl: msh.cells) {
            cl.user_data.Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);

        }
    }


    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    testing_level_set(const Mesh msh, const FonctionD &, const FonctionA &);

    template<typename FonctionD, typename Mesh>
    void
    test_new_method(const Mesh, const FonctionD &, const typename Mesh::cell_type &);


// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    gradient_checking1(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                       const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;

        double derD1x, derD1y, derAx, derAy, derD2x, derD2y;
        Eigen::Matrix<double, 2, 1> derD1, derD2, derA;
        point<double, 2> node;


        auto pts = points(msh, cl);
        for (auto &node: pts) {
            derD1 = level_set_disc.gradient(node);
            derD2 = level_set_disc.gradient(node, msh, cl);
            derA = level_set_anal.gradient(node);

            derD1x = derD1(0);
            derD1y = derD1(1);
            derD2x = derD2(0);
            derD2y = derD2(1);
            derAx = derA(0);
            derAy = derA(1);


/*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */

            if ((derAx - derD2x) > 1e-2) {
                std::cout << "Differnce between analytic and NEW X-evaluation system " << (derAx - derD2x) << std::endl;
            }

            if ((derAx - derD1x) > 1e-2) {
                std::cout << "Differnce between analytic and OLD X-evaluation system " << (derAx - derD1x) << std::endl;
            }


/*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */


            if ((derAy - derD2y) > 1e-2) {
                std::cout << "Differnce between analytic and NEW Y-evaluation system " << (derAy - derD2y) << std::endl;
            }

            if ((derAy - derD1y) > 1e-2) {
                std::cout << "Differnce between analytic and OLD Y-evaluation system " << (derAy - derD1y) << std::endl;
            }


        }


    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    gradient_checking(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                      const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;

        double derD1x, derD1y, derAx, derAy; // , derD2x , derD2y ;
        Eigen::Matrix<double, 2, 1> derD1, derD2, derA;
        point<double, 2> node;

        auto pts = points(msh, cl);
        for (auto &node: pts) {
            derD1 = level_set_disc.gradient(node);
// derD2 = level_set_disc.gradient(node,msh,cl);
            derA = level_set_anal.gradient(node);

            derD1x = derD1(0);
            derD1y = derD1(1);
//   derD2x = derD2(0);
//   derD2y = derD2(1);
            derAx = derA(0);
            derAy = derA(1);


/*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */
/*
        if((derAx-derD2x)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW X-evaluation system "<<(derAx-derD2x)<<std::endl;
        }
        */
            if ((derAx - derD1x) > 1e-2) {
                std::cout << "Differnce between analytic and OLD X-evaluation system " << (derAx - derD1x) << std::endl;
            }


/*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */

/*
        if((derAy-derD2y)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW Y-evaluation system "<<(derAy-derD2y)<<std::endl;
        }
        */
            if ((derAy - derD1y) > 1e-2) {
                std::cout << "Differnce between analytic and OLD Y-evaluation system " << (derAy - derD1y) << std::endl;
            }


        }


    }


    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    testing_velocity(const Mesh &msh, const FonctionD &vel_disc, const FonctionA &vel_anal) {
//typedef typename Mesh::point_type       point_type;
        postprocess_output<double> postoutput1;

        Eigen::Matrix<double, 2, 1> valueA;
        point<double, 2> node;
        size_t N, M;
        N = 40;
        M = 40;
        auto test_discx = std::make_shared < gnuplot_output_object < double > > ("vel_discX.dat");
        auto test_analx = std::make_shared < gnuplot_output_object < double > > ("vel_analX.dat");
        auto test_discy = std::make_shared < gnuplot_output_object < double > > ("vel_discY.dat");
        auto test_analy = std::make_shared < gnuplot_output_object < double > > ("vel_analY.dat");

        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            for (auto &pt: pts) {
                auto valueD = vel_disc(pt, msh, cl);
                valueA = vel_anal(pt);

                test_discx->add_data(pt, valueD.first);
                test_discy->add_data(pt, valueD.second);
                test_analx->add_data(pt, valueA(0));
                test_analy->add_data(pt, valueA(1));


            }
        }

        postoutput1.add_object(test_discx);
        postoutput1.add_object(test_analx);
        postoutput1.add_object(test_discy);
        postoutput1.add_object(test_analy);


        postoutput1.write();

    }




    template<typename T>
    std::vector <point<T, 1>>
    reference_nodes(size_t degree) {
        auto comp_degree = degree + 1;

        size_t reqd_nodes = comp_degree;

        std::vector <point<T, 1>> ret;
        ret.reserve(reqd_nodes);

        point<T, 1> qp;
        T a1, a2;
        T delta_x;
        switch (reqd_nodes) {
            case 1:
                qp = point<T, 1>({
                                         0.0
                                 });
                ret.push_back(qp);
                return ret;

            case 2:
                qp = point<T, 1>({
                                         1.0
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                return ret;

            case 3:
                qp = point<T, 1>({
                                         1.0
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                qp = point<T, 1>({0.0});
                ret.push_back(qp);
                return ret;

            case 4:
                a1 = 1.0 / 3.0;
                qp = point<T, 1>({1.0});
                ret.push_back(-qp);
                ret.push_back(qp);
                qp = point<T, 1>({a1});
                ret.push_back(-qp);
                ret.push_back(qp);
                return ret;

            case 5:
// Be carefull in what order data is inserted in ret!
// In Gauss Legendre the first one was 0.0, now is the last one
                a2 = 0.5;
                a1 = 1.0;
                qp = point<T, 1>({a1});
                ret.push_back(-qp);
                ret.push_back(qp);

                qp = point<T, 1>({a2});
                ret.push_back(-qp);
                ret.push_back(qp);

                qp = point<T, 1>({0.0});
                ret.push_back(qp);

                return ret;

            default:

                delta_x = 1.0 / degree;
                a1 = 1.0;
                while (a1 > 0) {
                    qp = point<T, 1>({
                                             a1
                                     });
                    ret.push_back(-qp);
                    ret.push_back(qp);
                    a1 -= delta_x;

                }
                if (a1 == 0) {
                    qp = point<T, 1>({
                                             0.0
                                     });
                    ret.push_back(qp);
                }
                return ret;
        }

        return ret;
    }

    template<typename T, typename Mesh>
    std::vector <point<T, 2>>
    equidistriduted_nodes(const Mesh &msh,
                          const typename Mesh::cell_type &cl,
                          size_t degree) {
        typedef typename Mesh::point_type point_type;

        auto qps = reference_nodes<T>(degree);


        auto pts = points(msh, cl);

        auto v0 = pts[1] - pts[0];
        auto v1 = pts[2] - pts[1];
        auto v2 = pts[3] - pts[2];
        auto v3 = pts[3] - pts[0];

        std::vector <point<T, 2>> ret;

        auto P = [&](T xi, T eta) -> T {
            return 0.25 * pts[0].x() * (1 - xi) * (1 - eta) +
                   0.25 * pts[1].x() * (1 + xi) * (1 - eta) +
                   0.25 * pts[2].x() * (1 + xi) * (1 + eta) +
                   0.25 * pts[3].x() * (1 - xi) * (1 + eta);
        };

        auto Q = [&](T xi, T eta) -> T {
            return 0.25 * pts[0].y() * (1 - xi) * (1 - eta) +
                   0.25 * pts[1].y() * (1 + xi) * (1 - eta) +
                   0.25 * pts[2].y() * (1 + xi) * (1 + eta) +
                   0.25 * pts[3].y() * (1 - xi) * (1 + eta);
        };

        for (auto jtor = qps.begin(); jtor != qps.end(); jtor++) {
            for (auto itor = qps.begin(); itor != qps.end(); itor++) {
                auto qp_x = *itor;
                auto qp_y = *jtor;

                auto xi = qp_x.x();
                auto eta = qp_y.x();

                auto px = P(xi, eta);
                auto py = Q(xi, eta);

                ret.push_back(point_type(px, py));
            }
        }

        return ret;
    }


// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename Fonction, typename Mesh>
    void
    testing_velocity_field_L2projected(const Mesh msh, const Fonction &vel) {
//typedef typename Mesh::point_type       point_type;
        postprocess_output<double> postoutput1;

        auto test_discx = std::make_shared < gnuplot_output_object < double > > ("L2vel_HHOX.dat");
        auto test_discy = std::make_shared < gnuplot_output_object < double > > ("L2vel_HHOY.dat");


        for (auto &cl: msh.cells) {
            auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
            for (auto &pt: pts) {
                auto value = vel(pt, msh, cl);
                test_discx->add_data(pt, value.first);
                test_discy->add_data(pt, value.second);


            }
        }

        postoutput1.add_object(test_discx);
        postoutput1.add_object(test_discy);


        postoutput1.write();

    }

    template<typename Fonction, typename Mesh>
    void
    testing_velocity_field(const Mesh msh, const Fonction &vel) {

        std::string filename_interface_Stokes = "vel_lagrange_disc.3D";

        std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   val0   val1" << std::endl;


        } else
            std::cerr << "Interface_file has not been opened" << std::endl;


        for (auto &cl: msh.cells) {
            auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
            for (auto &pt: pts) {
                auto value = vel(pt, msh, cl);
                interface_file << pt.x() << "   " << pt.y() << "   " << value.first << "   " << value.second << std::endl;


            }
        }

        interface_file.close();

    }


    template<typename Fonction, typename Mesh>
    void
    testing_velocity_field(const Mesh &msh, const Fonction &vel, size_t time_step, std::string &folder) {

        std::string filename_stokes6 = folder + "velocity_field_" + std::to_string(time_step) + ".3D";
        std::ofstream interface_file(filename_stokes6, std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   val0   val1" << std::endl;


        } else
            std::cerr << "Interface_file has not been opened" << std::endl;


        for (auto &cl: msh.cells) {
            auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
            for (auto &pt: pts) {
                auto value = vel(pt, msh, cl);
                interface_file << pt.x() << "   " << pt.y() << "   " << value.first << "   " << value.second << std::endl;


            }
        }

        interface_file.close();

    }

    template<typename FonctionD, typename Mesh, typename T>
    void
    testing_level_set_time(Mesh &msh, const FonctionD &level_set_disc, T time, size_t time_step, std::string &folder) {
        typedef typename Mesh::point_type point_type;


        postprocess_output <T> postoutput0;
        std::string filename_FEM = folder + "sol_FEM_t=" + std::to_string(time_step) + ".dat";
        auto test_FEM = std::make_shared < gnuplot_output_object < double > > (filename_FEM);



// CHECK MAX AND MIN
        T ret0 = -10.0;
        T ret1 = 10.0;
        for (auto &cl: msh.cells) {
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, level_set_disc.degree_FEM);

            for (auto &nd: nodes) {
                auto new_ret = level_set_disc(nd, msh, cl);
                test_FEM->add_data(nd, new_ret);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }


        }

        postoutput0.add_object(test_FEM);
        postoutput0.write();

        std::cout << "At initial time: min(phi) = " << level_set_disc.phi_min << ", max(phi) = " << level_set_disc.phi_max
                  << std::endl;

        std::cout << "At time t = " << time << ": min(phi) = " << ret1 << ", max(phi) = " << ret0 << std::endl;

    }



    template<typename FonctionD, typename Mesh, typename T>
    void
    testing_level_set_max_min(const Mesh &msh, const FonctionD &level_set_disc, size_t time_step,
                              std::vector <std::pair<T, T>> &min_max_vec) {

// CHECK MAX AND MIN
        T ret0 = -10.0;
        T ret1 = 10.0;


        for (auto &cl: msh.cells) {

            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, level_set_disc.degree_FEM);

            for (auto &nd: nodes) {
                auto new_ret = level_set_disc(nd, msh, cl);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }


        }

        min_max_vec.push_back(std::make_pair(ret1, ret0));

//std::cout<<"Initial time: MIN(phi) = "<<level_set_disc.phi_min<<", MAX(phi) = "<<level_set_disc.phi_max<< std::endl;
//std::cout<<"At time t = "<<time<<": MIN(phi) = "<<ret1<<" , MAX(phi) = "<<ret0<< std::endl;

    }



/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
    template<typename Mesh, typename Function, typename T>
    void
    output_mesh_info2_time(const Mesh &msh, const Function &level_set_function, T time, size_t time_step,
                           std::string &folder) {
        using RealType = typename Mesh::coordinate_type;

/************** OPEN SILO DATABASE **************/
        silo_database silo;
        std::string filename_silo = folder + "cuthho_meshinfo_Stokes_" + std::to_string(time_step) + ".silo";
        silo.create(filename_silo);
        silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
        std::vector <RealType> cut_cell_markers;
        for (auto &cl: msh.cells) {
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                cut_cell_markers.push_back(1.0);
            else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
                cut_cell_markers.push_back(-1.0);
            else if (location(msh, cl) == element_location::ON_INTERFACE)
                cut_cell_markers.push_back(0.0);
            else
                throw std::logic_error("shouldn't have arrived here...");
        }
        silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
        std::vector <RealType> highlight_markers;
        for (auto &cl: msh.cells) {
            if (cl.user_data.highlight)
                highlight_markers.push_back(1.0);
            else
                highlight_markers.push_back(0.0);

        }
        silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(),
                          zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
        std::vector <RealType> level_set_vals;
// for (auto& pt : msh.points)
//    level_set_vals.push_back( level_set_function(pt) );
        for (auto &n: msh.nodes)
            level_set_vals.push_back(level_set_function(n));

        silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
        std::vector <RealType> node_pos;
        for (auto &n: msh.nodes)
            node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
        silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

        std::vector <RealType> cell_set;
        for (auto &cl: msh.cells) {
            RealType r;

            switch (cl.user_data.agglo_set) {
                case cell_agglo_set::UNDEF:
                    r = 0.0;
                    break;

                case cell_agglo_set::T_OK:
                    r = 1.0;
                    break;

                case cell_agglo_set::T_KO_NEG:
                    r = 2.0;
                    break;

                case cell_agglo_set::T_KO_POS:
                    r = 3.0;
                    break;

            }

            cell_set.push_back(r);
        }
        silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

        silo.close();

/*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
        std::vector <RealType> int_pts_x;
        std::vector <RealType> int_pts_y;

        for (auto &fc: msh.faces) {
            if (fc.user_data.location != element_location::ON_INTERFACE) continue;

            RealType x = fc.user_data.intersection_point.x();
            RealType y = fc.user_data.intersection_point.y();

            int_pts_x.push_back(x);
            int_pts_y.push_back(y);
        }

        std::ofstream points_file(folder + "int_points.3D", std::ios::out | std::ios::trunc);

        if (points_file) {
// instructions
            points_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_pts_x.size(); i++) {
                points_file << int_pts_x[i] << "   " << int_pts_y[i]
                            << "   0.0     0.0" << std::endl;
            }

            points_file.close();
        } else
            std::cerr << "Points_file has not been opened" << std::endl;


/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
        std::vector <RealType> int_x;
        std::vector <RealType> int_y;

        for (auto &cl: msh.cells) {
            if (cl.user_data.location != element_location::ON_INTERFACE) continue;

            for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
                RealType x = cl.user_data.interface.at(i).x();
                RealType y = cl.user_data.interface.at(i).y();

                int_x.push_back(x);
                int_y.push_back(y);
            }
        }

        std::string filename_interface_Stokes = folder + "interface_Stokes_" + std::to_string(time_step) + ".3D";

        std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_x.size(); i++) {
                interface_file << int_x[i] << "   " << int_y[i]
                               << "   0.0     0.0" << std::endl;
            }

            interface_file.close();
        } else
            std::cerr << "Interface_file has not been opened" << std::endl;
    }


/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
    template<typename Mesh, typename Function>
    void
    output_mesh_info_ls_l_n(const Mesh &msh, const Function &ls) {
// Plotting of parametric interface (l,n)
// l = degree
// n = # of cells
        using RealType = typename Mesh::coordinate_type;



/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
        std::vector <RealType> int_x;
        std::vector <RealType> int_y;

        auto interface0 = ls.interface0;
        auto interface1 = ls.interface1;
        interface0.rows();
        auto nOfRow = interface0.rows();
        auto nOfCol = interface0.cols();
        for (auto i = 0; i < nOfRow; i++) {
            for (auto j = 0; j < nOfCol; j++) {
                RealType x = interface0(i, j);
                RealType y = interface1(i, j);

                int_x.push_back(x);
                int_y.push_back(y);

            }
        }


        std::string filename_interface_Stokes = "parametric_interface_Stokes.3D";

        std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_x.size(); i++) {
                interface_file << int_x[i] << "   " << int_y[i]
                               << "   0.0     0.0" << std::endl;
            }

            interface_file.close();
        } else
            std::cerr << "Interface_file has not been opened" << std::endl;


        std::vector <RealType> int_x1;
        std::vector <RealType> int_y1;


        for (auto &cl: msh.cells) {


            if (cl.user_data.location == element_location::ON_INTERFACE) {

                auto global_cells_i = ls.get_global_cells_interface(msh, cl);
                auto integration_msh = cl.user_data.integration_msh;


                auto qps_un = edge_quadrature<RealType>(100);

                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++) {
                    auto pts = points(integration_msh, integration_msh.cells[i_cell]);
                    size_t global_cl_i = global_cells_i[i_cell];

                    for (auto &qp: qps_un) {
                        auto t = 0.5 * qp.first.x() + 0.5;

                        auto p = ls(t, global_cl_i);

                        int_x1.push_back(p(0));
                        int_y1.push_back(p(1));


                    }
                }
            }
        }


        std::string filename_interface_Stokes1 = "parametric_interface_Stokes_multipts.3D";

        std::ofstream interface_file1(filename_interface_Stokes1, std::ios::out | std::ios::trunc);

        if (interface_file1) {
// instructions
            interface_file1 << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_x1.size(); i++) {
                interface_file1 << int_x1[i] << "   " << int_y1[i]
                                << "   0.0     0.0" << std::endl;
            }

            interface_file1.close();
        } else
            std::cerr << "Interface_file has not been opened" << std::endl;


    }

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
    template<typename Mesh, typename Function, typename T>
    void
    output_mesh_info2_time_fixed_mesh(const Mesh &msh, const Function &level_set_function, T time, size_t time_step) {
        using RealType = typename Mesh::coordinate_type;



/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
        std::vector <RealType> int_x;
        std::vector <RealType> int_y;

        for (auto &cl: msh.cells) {
            if (cl.user_data.location != element_location::ON_INTERFACE) continue;

            for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
                RealType x = cl.user_data.interface.at(i).x();
                RealType y = cl.user_data.interface.at(i).y();

                int_x.push_back(x);
                int_y.push_back(y);
            }
        }

        std::string filename_interface_Stokes = "interface_Stokes_" + std::to_string(time_step) + ".3D";

        std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_x.size(); i++) {
                interface_file << int_x[i] << "   " << int_y[i]
                               << "   0.0     0.0" << std::endl;
            }

            interface_file.close();
        } else
            std::cerr << "Interface_file has not been opened" << std::endl;
    }

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
    template<typename Mesh, typename Function>
    void
    output_mesh_info2(const Mesh &msh, const Function &level_set_function) {
        using RealType = typename Mesh::coordinate_type;

/************** OPEN SILO DATABASE **************/
        silo_database silo;
        silo.create("cuthho_meshinfo_Stokes.silo");
        silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
        std::vector <RealType> cut_cell_markers;
        for (auto &cl: msh.cells) {
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                cut_cell_markers.push_back(1.0);
            else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
                cut_cell_markers.push_back(-1.0);
            else if (location(msh, cl) == element_location::ON_INTERFACE)
                cut_cell_markers.push_back(0.0);
            else
                throw std::logic_error("shouldn't have arrived here...");
        }
        silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
        std::vector <RealType> highlight_markers;
        for (auto &cl: msh.cells) {
            if (cl.user_data.highlight)
                highlight_markers.push_back(1.0);
            else
                highlight_markers.push_back(0.0);

        }
        silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(),
                          zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
        std::vector <RealType> level_set_vals;
// for (auto& pt : msh.points)
//    level_set_vals.push_back( level_set_function(pt) );
        for (auto &n: msh.nodes)
            level_set_vals.push_back(level_set_function(n));

        silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
        std::vector <RealType> node_pos;
        for (auto &n: msh.nodes)
            node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
        silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

        std::vector <RealType> cell_set;
        for (auto &cl: msh.cells) {
            RealType r;

            switch (cl.user_data.agglo_set) {
                case cell_agglo_set::UNDEF:
                    r = 0.0;
                    break;

                case cell_agglo_set::T_OK:
                    r = 1.0;
                    break;

                case cell_agglo_set::T_KO_NEG:
                    r = 2.0;
                    break;

                case cell_agglo_set::T_KO_POS:
                    r = 3.0;
                    break;

            }

            cell_set.push_back(r);
        }
        silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

        silo.close();

/*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
        std::vector <RealType> int_pts_x;
        std::vector <RealType> int_pts_y;

        for (auto &fc: msh.faces) {
            if (fc.user_data.location != element_location::ON_INTERFACE) continue;

            RealType x = fc.user_data.intersection_point.x();
            RealType y = fc.user_data.intersection_point.y();

            int_pts_x.push_back(x);
            int_pts_y.push_back(y);
        }

        std::ofstream points_file("int_points.3D", std::ios::out | std::ios::trunc);

        if (points_file) {
// instructions
            points_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_pts_x.size(); i++) {
                points_file << int_pts_x[i] << "   " << int_pts_y[i]
                            << "   0.0     0.0" << std::endl;
            }

            points_file.close();
        } else
            std::cerr << "Points_file has not been opened" << std::endl;


/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
        std::vector <RealType> int_x;
        std::vector <RealType> int_y;

        for (auto &cl: msh.cells) {
            if (cl.user_data.location != element_location::ON_INTERFACE) continue;

            for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
                RealType x = cl.user_data.interface.at(i).x();
                RealType y = cl.user_data.interface.at(i).y();

                int_x.push_back(x);
                int_y.push_back(y);
            }
        }
        std::ofstream interface_file("interface_Stokes.3D", std::ios::out | std::ios::trunc);

        if (interface_file) {
// instructions
            interface_file << "X   Y   Z   val" << std::endl;

            for (size_t i = 0; i < int_x.size(); i++) {
                interface_file << int_x[i] << "   " << int_y[i]
                               << "   0.0     0.0" << std::endl;
            }

            interface_file.close();
        } else
            std::cerr << "Interface_file has not been opened" << std::endl;
    }

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
    template<typename T, typename Function, typename Mesh>
    point<T, 2>
    find_zero_crossing_on_face(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                               const T &threshold, const Mesh &msh, const typename Mesh::face_type &fc) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
        auto pa = p0;
        auto pb = p1;
        auto pm = (pa + pb) / 2.0;
        auto pm_prev = pm;

        T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
        size_t max_iter = 50;

        do {
            auto la = level_set_function(pa, msh, fc);
            auto lb = level_set_function(pb, msh, fc);
            auto lm = level_set_function(pm, msh, fc);

            if ((lb >= 0 && lm >= 0) || (lb < 0 && lm < 0)) {   /* intersection is between pa and pm */
                pm_prev = pm;
                pb = pm;
                pm = (pa + pb) / 2.0;
            } else {   /* intersection is between pm and pb */
                pm_prev = pm;
                pa = pm;
                pm = (pa + pb) / 2.0;
            }

            x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
            y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

        } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

        return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
    }

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
    template<typename T, typename Function, typename Mesh>
    point<T, 2>
    find_zero_crossing_on_face3(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                                const T &threshold, const Mesh &msh, const typename Mesh::face_type &fc) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
        auto pa = p0;
        auto pb = p1;
        auto pm = (pa + pb) / 2.0;
        auto pm_prev = pm;
        T iso_val_interface = level_set_function.iso_val_interface;
        T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
        size_t max_iter = 50;

        do {
//auto la = level_set_function(pa,msh,fc);
            auto lb = level_set_function(pb, msh, fc);
            auto lm = level_set_function(pm, msh, fc);

            if ((lb >= iso_val_interface && lm >= iso_val_interface) ||
                (lb < iso_val_interface && lm < iso_val_interface)) {   /* intersection is between pa and pm */
                pm_prev = pm;
                pb = pm;
                pm = (pa + pb) / 2.0;
            } else {   /* intersection is between pm and pb */
                pm_prev = pm;
                pa = pm;
                pm = (pa + pb) / 2.0;
            }

            x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
            y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

        } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

        return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
    }

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
    template<typename T, typename Function, typename Mesh>
    point<T, 2>
    find_zero_crossing_in_cell(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                               const T &threshold, const Mesh &msh, const typename Mesh::cell_type &cl) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
        auto pa = p0;
        auto pb = p1;
        auto pm = (pa + pb) / 2.0;
        auto pm_prev = pm;

        T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
        size_t max_iter = 50; // ERA 50, METTO 100

        do {
            auto la = level_set_function(pa, msh, cl);
            auto lb = level_set_function(pb, msh, cl);
            auto lm = level_set_function(pm, msh, cl);

            if ((lb >= 0 && lm >= 0) || (lb < 0 && lm < 0)) {   /* intersection is between pa and pm */
                pm_prev = pm;
                pb = pm;
                pm = (pa + pb) / 2.0;
            } else {   /* intersection is between pm and pb */
                pm_prev = pm;
                pa = pm;
                pm = (pa + pb) / 2.0;
            }

            x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
            y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

        } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

        return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
    }

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
    template<typename T, typename Function, typename Mesh>
    point<T, 2>
    find_zero_crossing_in_cell3(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                                const T &threshold, const Mesh &msh, const typename Mesh::cell_type &cl) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
        auto pa = p0;
        auto pb = p1;
        auto pm = (pa + pb) / 2.0;
        auto pm_prev = pm;
        T iso_val_interface = level_set_function.iso_val_interface;
        T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
        size_t max_iter = 50; // ERA 50, METTO 100

        do {
//auto la = level_set_function(pa,msh,cl);
            auto lb = level_set_function(pb, msh, cl);
            auto lm = level_set_function(pm, msh, cl);

            if ((lb >= iso_val_interface && lm >= iso_val_interface) ||
                (lb < iso_val_interface && lm < iso_val_interface)) {   /* intersection is between pa and pm */
                pm_prev = pm;
                pb = pm;
                pm = (pa + pb) / 2.0;
            } else {   /* intersection is between pm and pb */
                pm_prev = pm;
                pa = pm;
                pm = (pa + pb) / 2.0;
            }

            x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
            y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

        } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

        return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
    }


/// New version of detect_node_position for discret level functions
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_node_position2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
        for (auto &n: msh.nodes) {
//auto pt = points(msh, n); //deleted by Stefano
//if ( level_set_function(pt) < 0 ) //deleted by Stefano

            T value_node = level_set_function(n);
            if (std::abs(value_node) < 1e-17) {
                std::cout << "In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!" << std::endl;
                auto pt = points(msh, n);
                value_node = level_set_function(pt);
            }


            if (value_node < 0) // add by Stefano
                n.user_data.location = element_location::IN_NEGATIVE_SIDE;
            else
                n.user_data.location = element_location::IN_POSITIVE_SIDE;


        }
    }


/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_node_position3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {

        timecounter tc;
        tc.tic();
        T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;

        for (auto &n: msh.nodes) {
//auto pt = points(msh, n); //deleted by Stefano
//if ( level_set_function(pt) < 0 ) //deleted by Stefano

            T value_node = level_set_function(n);

            if (std::abs(value_node - iso_val_interface) < 1e-17) {
                std::cout << "In detect_node_position3 -> ATTENTION, INTERFACE ON A NODE!" << std::endl;
                auto pt = points(msh, n);
                value_node = level_set_function(pt);
            }


            if (value_node < iso_val_interface) { // add by Stefano
                n.user_data.location = element_location::IN_NEGATIVE_SIDE;
//std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
            } else {
                n.user_data.location = element_location::IN_POSITIVE_SIDE;
//std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
            }
//std::cout<<"Value_node = "<< value_node<<std::endl;

        }

        tc.toc();
//std::cout << bold << yellow << "detect_node_position3, time resolution: " << tc << " seconds" << reset << std::endl;
    }

/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
/*
template<typename T, size_t ET, typename Function>
void
detect_node_position3_parallel(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    timecounter tc ;
    tc.tic();
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;
#ifdef HAVE_INTEL_TBB
    size_t n_nodes = msh.nodes.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_nodes), size_t(1),
    [&msh,&level_set_function,&iso_val_interface] (size_t & cell_ind){
        auto& n = msh.nodes[cell_ind];
        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }



        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }

    }
    );

    tc.toc();
    //std::cout << "detect_node_position3_parallel, time resolution: " << tc << " seconds" << std::endl;
#else

    for (auto& n : msh.nodes)
    {
        //auto pt = points(msh, n); //deleted by Stefano
        //if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }


        //std::cout<<"value_node SEQUENTIAL = "<<level_set_function(n)<<std::endl;
        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }
        //std::cout<<"Value_node = "<< value_node<<std::endl;

    }


#endif

}
*/
/// New version of detect_cut_faces for discret level functions
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_cut_faces2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
        for (auto &fc: msh.faces) {
            auto pts = points(msh, fc);
/*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
//auto l0 = level_set_function(pts[0]);      //deleted by Stefano
//auto l1 = level_set_function(pts[1]);       //deleted by Stefano

            auto l0 = level_set_function(pts[0], msh, fc);      // add by Stefano
            auto l1 = level_set_function(pts[1], msh, fc);       // add by Stefano

// In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
            if ((std::abs(l0) < 1e-17) && (std::abs(l1) < 1e-17))
                std::cout << "STOP --> CASE DOUBT: l0 = " << l0 << " and l1 = " << l1 << std::endl;

            else if (std::abs(l0) < 1e-17) {
                std::cout << "The node " << pts[0] << " is very close to the interface." << std::endl;
                l0 = level_set_function(pts[0]);
                std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
            } else if (std::abs(l1) < 1e-17) {
                std::cout << "The node " << pts[1] << " is very close to the interface." << std::endl;
                l1 = level_set_function(pts[1]);
                std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
            }
/*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
            if (l0 >= 0 && l1 >= 0) {
                fc.user_data.location = element_location::IN_POSITIVE_SIDE;
                continue;
            }

            if (l0 < 0 && l1 < 0) {
                fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
                continue;
            }


            auto threshold = diameter(msh, fc) / 1e20;
//auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
            auto pm = find_zero_crossing_on_face(pts[0], pts[1], level_set_function, threshold, msh, fc);

/* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
            fc.user_data.node_inside = (l0 < 0) ? 0 : 1;
            fc.user_data.location = element_location::ON_INTERFACE;
            fc.user_data.intersection_point = pm;
        }
    }

/// New version of detect_cut_faces for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_cut_faces3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
        T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"In 'detect_cut_face3'--> iso_val_interface = "<<iso_val_interface<<std::endl;
        for (auto &fc: msh.faces) {
            auto pts = points(msh, fc);
/*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
//auto l0 = level_set_function(pts[0]);      //deleted by Stefano
//auto l1 = level_set_function(pts[1]);       //deleted by Stefano

            auto l0 = level_set_function(pts[0], msh, fc);      // add by Stefano
            auto l1 = level_set_function(pts[1], msh, fc);       // add by Stefano
//        std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<<" vs l0 = "<<l0<<std::endl;
//        std::cout<<"level_set_function(pts[1]) = "<<level_set_function(pts[1])<<" vs l1 = "<<l1<<'\n'<<std::endl;

// In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
            if ((std::abs(l0 - iso_val_interface) < 1e-17) && (std::abs(l1 - iso_val_interface) < 1e-17))
                std::cout << "STOP --> CASE DOUBT: l0 = " << l0 << " and l1 = " << l1 << std::endl;

            else if (std::abs(l0 - iso_val_interface) < 1e-17) {
                std::cout << "The node " << pts[0] << " is very close to the interface." << std::endl;
                l0 = level_set_function(pts[0]);
                std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
            } else if (std::abs(l1 - iso_val_interface) < 1e-17) {
                std::cout << "The node " << pts[1] << " is very close to the interface." << std::endl;
                l1 = level_set_function(pts[1]);
                std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
            }
/*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
            if (l0 >= iso_val_interface && l1 >= iso_val_interface) {
                fc.user_data.location = element_location::IN_POSITIVE_SIDE;
                continue;
            }

            if (l0 < iso_val_interface && l1 < iso_val_interface) {
                fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
                continue;
            }


            auto threshold = diameter(msh, fc) / 1e20;
//auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
            auto pm = find_zero_crossing_on_face3(pts[0], pts[1], level_set_function, threshold, msh, fc);
//std::cout<<"pm = "<<pm<< " and level_set_function = "<<level_set_function(pm,msh,fc)<<std::endl;
/* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
            fc.user_data.node_inside = (l0 < iso_val_interface) ? 0 : 1;
            fc.user_data.location = element_location::ON_INTERFACE;
            fc.user_data.intersection_point = pm;
        }
    }

/// New version of detect_cut_cells for discret level functions
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_cut_cells2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
        std::cout << "I AM IN DETECT CUT CELL2!!!!" << std::endl;
//typedef typename cuthho_mesh<T, ET>::face_type  face_type;
        typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::cell_type cell_type;

        size_t cell_i = 0;
        for (auto &cl: msh.cells) {
            auto fcs = faces(msh, cl);
            std::array<std::pair<size_t, point_type>, 2> cut_faces;

            size_t k = 0;
            for (size_t i = 0; i < fcs.size(); i++) {
                if (is_cut(msh, fcs[i]))
                    cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
            }

/* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

            if (k == 0) {

                auto is_positive = [&](const point_type &pt) -> bool {
                    return level_set_function(pt) > 0;
                };


                auto pts = points(msh, cl);

                if (std::all_of(pts.begin(), pts.end(), is_positive))
                    cl.user_data.location = element_location::IN_POSITIVE_SIDE;
                else
                    cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




/*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

            }
//MODIFICARE QUAAAA
            if (k == 2) {
                cl.user_data.location = element_location::ON_INTERFACE;
                auto p0 = cut_faces[0].second;
                auto p1 = cut_faces[1].second;
                auto pt = p1 - p0;
                auto pn = p0 + point<T, 2>(-pt.y(), pt.x());
                auto pn_prova = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
//if(offset(msh,cl)== 119)
//    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
// PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
/*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
                if (offset(msh, cl) == 137 || offset(msh, cl) == 138 || offset(msh, cl) == 134 || offset(msh, cl) == 103) {
                    std::cout << yellow << bold << "offset(msh,cl) = " << offset(msh, cl) << reset << std::endl;
                    auto pn_bis = (p0 + p1) / 2.0 + point<T, 2>(-pt.y(), pt.x());
                    std::cout << "pn_bis = " << pn_bis << " , level_set_function(pn_bis,msh,cl) ="
                              << level_set_function(pn_bis, msh, cl) << std::endl;
                    auto pn_bis0 = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
                    std::cout << "pn_bis0 = " << pn_bis0 << " , level_set_function(pn_bis0,msh,cl) ="
                              << level_set_function(pn_bis0, msh, cl) << std::endl;
                    auto pn_bis1 = p0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
                    std::cout << "pn_bis1 = " << pn_bis1 << " , level_set_function(pn_bis1,msh,cl) ="
                              << level_set_function(pn_bis1, msh, cl) << '\n' << std::endl;

                    std::cout << "pn = " << pn << " , p0 = " << p0 << " , p1 = " << p1 << std::endl;
                    std::cout << "level_set_function(pn,msh,cl) = " << level_set_function(pn, msh, cl)
                              << " , level_set_function(p0,msh,cl) = " << level_set_function(p0, msh, cl)
                              << " , level_set_function(pn,msh,cl) = " << level_set_function(p1, msh, cl) << std::endl;
                    std::cout << "p0 - point<T,2>(-pt.y(), pt.x()) = " << p0 - point<T, 2>(-pt.y(), pt.x())
                              << " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "
                              << level_set_function(p0 - point<T, 2>(-pt.y(), pt.x()), msh, cl) << std::endl;
                }


                if (!(std::signbit(level_set_function(pn, msh, cl)) ==
                      std::signbit(level_set_function(pn_prova, msh, cl)))) {
                    pn = pn_prova;
                    std::cout << "pn = " << pn << " , pn_prova = " << pn_prova << " , level_set_function(pn,msh,cl) = "
                              << level_set_function(pn, msh, cl) << " , level_set_function(pn_prova,msh,cl) = "
                              << level_set_function(pn_prova, msh, cl) << std::endl;
                }

                if (level_set_function(pn, msh, cl) >= 0) {
                    cl.user_data.p0 = p1;
                    cl.user_data.p1 = p0;
                } else {
                    cl.user_data.p0 = p0;
                    cl.user_data.p1 = p1;
                }

                cl.user_data.interface.push_back(cl.user_data.p0);
                cl.user_data.interface.push_back(cl.user_data.p1);
            }

            if (k != 0 && k != 2) {
                auto pts = points(msh, cl);
                std::cout << "Point[0] = " << pts[0] << " , point[1] = " << pts[1] << " , point[2] = " << pts[2]
                          << " , point[3] = " << pts[3] << std::endl;
                std::cout << "level_set_function(p0) = " << level_set_function(pts[0], msh, cl)
                          << " , level_set_function(p1) = " << level_set_function(pts[1], msh, cl)
                          << " , level_set_function(p2) = " << level_set_function(pts[2], msh, cl)
                          << " , level_set_function(p3) = " << level_set_function(pts[3], msh, cl) << std::endl;
                for (size_t i = 0; i < fcs.size(); i++) {
                    if (is_cut(msh, fcs[i]))
                        std::cout << "fcs[i].user_data.intersection_point = " << fcs[i].user_data.intersection_point
                                  << std::endl;
                }

                std::cout << "ERROR: in cut cell " << cell_i << " there are k = " << k << " cuts!!!!" << std::endl;
                throw std::logic_error(" --> Invalid number of cuts in cell");

            }

            cell_i++;
        }
    }

/// New version of detect_cut_cells for discret level functions -> USING INTERFACE = 1/2
/// in cuthho_geom.hpp
    template<typename T, size_t ET, typename Function>
    void
    detect_cut_cells3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
//std::cout<<"I AM IN DETECT CUT CELL3!!!!"<<std::endl;
        timecounter tc;
        tc.tic();
//typedef typename cuthho_mesh<T, ET>::face_type  face_type;
        typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
        T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;
        size_t cell_i = 0;
        for (auto &cl: msh.cells) {
            auto fcs = faces(msh, cl);
            std::array<std::pair<size_t, point_type>, 2> cut_faces;

            size_t k = 0;
            for (size_t i = 0; i < fcs.size(); i++) {
                if (is_cut(msh, fcs[i]))
                    cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
            }

/* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

            if (k == 0) {

                auto is_positive = [&](const point_type &pt) -> bool {
                    return level_set_function(pt, msh, cl) > iso_val_interface;
                };


                auto pts = points(msh, cl);

                if (std::all_of(pts.begin(), pts.end(), is_positive))
                    cl.user_data.location = element_location::IN_POSITIVE_SIDE;
                else
                    cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




/*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

            }
//MODIFICARE QUAAAA
            if (k == 2) {
                cl.user_data.location = element_location::ON_INTERFACE;
                auto p0 = cut_faces[0].second;
                auto p1 = cut_faces[1].second;
                auto pt = p1 - p0;
                auto pn = p0 + point<T, 2>(-pt.y(), pt.x());
                auto pn_prova = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
//if(offset(msh,cl)== 119)
//    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
// PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
/*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
/*
            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){
                std::cout<<yellow<<bold<<"offset(msh,cl) = "<<offset(msh,cl)<<reset<<std::endl;
                auto pn_bis = (p0+p1)/2.0 + point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis = "<<pn_bis<< " , level_set_function(pn_bis,msh,cl) ="<<level_set_function(pn_bis,msh,cl) <<std::endl;
                auto pn_bis0 = (p0+p1)/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis0 = "<<pn_bis0<< " , level_set_function(pn_bis0,msh,cl) ="<<level_set_function(pn_bis0,msh,cl) <<std::endl;
                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis1 = "<<pn_bis1<< " , level_set_function(pn_bis1,msh,cl) ="<<level_set_function(pn_bis1,msh,cl)<<'\n' <<std::endl;

                std::cout<<"pn = "<<pn<< " , p0 = "<<p0<< " , p1 = "<<p1<<std::endl;
                std::cout<<"level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(p0,msh,cl) = "<<level_set_function(p0,msh,cl)<< " , level_set_function(pn,msh,cl) = "<<level_set_function(p1,msh,cl)<<std::endl;
                std::cout<<"p0 - point<T,2>(-pt.y(), pt.x()) = "<<p0 - point<T,2>(-pt.y(), pt.x())<< " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;
            }
            */

                if (!(std::signbit(level_set_function(pn, msh, cl) - iso_val_interface) ==
                      std::signbit(level_set_function(pn_prova, msh, cl) - iso_val_interface))) {
                    std::cout << "p0 = " << p0 << " , p1 = " << p1 << std::endl;
                    std::cout << "pn = " << pn << " , pn_prova = " << pn_prova << " , level_set_function(pn,msh,cl) = "
                              << level_set_function(pn, msh, cl) << " , level_set_function(pn_prova,msh,cl) = "
                              << level_set_function(pn_prova, msh, cl) << std::endl;
                    pn = pn_prova;
                }

                if (level_set_function(pn, msh, cl) >= iso_val_interface) {
                    cl.user_data.p0 = p1;
                    cl.user_data.p1 = p0;
                } else {
                    cl.user_data.p0 = p0;
                    cl.user_data.p1 = p1;
                }

                cl.user_data.interface.push_back(cl.user_data.p0);
                cl.user_data.interface.push_back(cl.user_data.p1);
            }

            if (k != 0 && k != 2) {
                auto pts = points(msh, cl);
                std::cout << "Point[0] = " << pts[0] << " , point[1] = " << pts[1] << " , point[2] = " << pts[2]
                          << " , point[3] = " << pts[3] << std::endl;
                std::cout << "level_set_function(p0) = " << level_set_function(pts[0], msh, cl)
                          << " , level_set_function(p1) = " << level_set_function(pts[1], msh, cl)
                          << " , level_set_function(p2) = " << level_set_function(pts[2], msh, cl)
                          << " , level_set_function(p3) = " << level_set_function(pts[3], msh, cl) << std::endl;
                for (size_t i = 0; i < fcs.size(); i++) {
                    if (is_cut(msh, fcs[i]))
                        std::cout << "fcs[i].user_data.intersection_point = " << fcs[i].user_data.intersection_point
                                  << std::endl;
                }

                std::cout << "ERROR: in cut cell " << cell_i << " there are k = " << k << " cuts!!!!" << std::endl;
                throw std::logic_error(" --> Invalid number of cuts in cell");

            }

            cell_i++;
        }
        tc.toc();
//std::cout << bold << yellow << "detect_cut_cells3, time resolution: " << tc << " seconds" << reset << std::endl;
    }

/*
template<typename T, size_t ET, typename Function>
void
detect_cut_cells3_parallelized(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    std::cout<<"I AM IN DETECT CUT CELL3 PARALLELELIZED !!!!"<<std::endl;
    timecounter tc;
    tc.tic();
    //typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;


#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&] (size_t & cell_ind){
        auto& cl = msh.cells[cell_ind];

        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }




        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;






        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!


            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                    std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_ind<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }


    });
    tc.toc();
    std::cout << bold << yellow << "detect_cut_cells3_parallelized, time resolution: " << tc << " seconds" << reset << std::endl;
#else

    size_t cell_i = 0;
    for (auto& cl : msh.cells)
    {
        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }



        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;





        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!

            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                  std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_i<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }

#endif
}
*/
/// New version of refine_interface for discret level functions

    template<typename T, size_t ET, typename Function>
    void
    refine_interface2(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                      const Function &level_set_function, size_t min, size_t max) {
        if ((max - min) < 2)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;

        size_t mid = (max + min) / 2;
        auto p0 = cl.user_data.interface.at(min);
        auto p1 = cl.user_data.interface.at(max);
        auto pm = (p0 + p1) / 2.0;
        auto pt = p1 - p0;
        auto pn = point_type(-pt.y(), pt.x());
        auto ps1 = pm + pn;
        auto ps2 = pm - pn;

        auto lm = level_set_function(pm, msh, cl);
        auto ls1 = level_set_function(ps1, msh, cl);
        auto ls2 = level_set_function(ps2, msh, cl);

        point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
        if (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0))) {
            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold, msh, cl);
        } else if (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0))) {
            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold, msh, cl);
        } else
            throw std::logic_error("interface not found in search range");

        cl.user_data.interface.at(mid) = ip;

        refine_interface2(msh, cl, level_set_function, min, mid);
        refine_interface2(msh, cl, level_set_function, mid, max);
    }

    template<typename T, size_t ET, typename Function>
    void
    refine_interface2(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
        if (levels == 0)
            return;

        size_t interface_points = iexp_pow(2, levels);

        for (auto &cl: msh.cells) {
            if (!is_cut(msh, cl))
                continue;


            std::cout << yellow << bold << "--------------------> CELL = " << offset(msh, cl) << "<--------------------"
                      << reset << std::endl;
            cl.user_data.interface.resize(interface_points + 1);
            cl.user_data.interface.at(0) = cl.user_data.p0;
            cl.user_data.interface.at(interface_points) = cl.user_data.p1;

            refine_interface2(msh, cl, level_set_function, 0, interface_points);

            std::cout << "LIMIT CELL " << offset(msh, cl) << " are:" << std::endl;
            std::cout << "pt[0] = " << points(msh, cl)[0] << " , pt[1] = " << points(msh, cl)[1] << " , pt[2] = "
                      << points(msh, cl)[2] << " , pt[3] = " << points(msh, cl)[3] << std::endl;

            for (size_t i_int = 0; i_int < interface_points + 1; i_int++)
                std::cout << "refined points are p = " << cl.user_data.interface.at(i_int) << std::endl;
            std::cout << "--------------------> CELL = " << offset(msh, cl) << "<--------------------" << std::endl;
        }
    }


    template<typename T, size_t ET, typename Function>
    typename cuthho_mesh<T, ET>::point_type
    search_boundary(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                    typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q, T lm, const Function &level_set) {
        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        auto pts = points(msh, cl);

        point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
        point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
        point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
        point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());
/*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
        auto ls0 = level_set(pt_tmp0, msh, cl);
        auto ls1 = level_set(pt_tmp1, msh, cl);
        auto ls2 = level_set(pt_tmp2, msh, cl);
        auto ls3 = level_set(pt_tmp3, msh, cl);

        if (pt_in_cell(msh, pt_tmp0, cl) && (!((lm >= 0 && ls0 >= 0) || (lm < 0 && ls0 < 0))))
            return pt_tmp0;
        if (pt_in_cell(msh, pt_tmp1, cl) && (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0))))
            return pt_tmp1;
        if (pt_in_cell(msh, pt_tmp2, cl) && (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0))))
            return pt_tmp2;
        if (pt_in_cell(msh, pt_tmp3, cl) && (!((lm >= 0 && ls3 >= 0) || (lm < 0 && ls3 < 0))))
            return pt_tmp3;
        else {
            std::cout << "In cell = " << offset(msh, cl) << " points(msh,cl)[0] = " << points(msh, cl)[0]
                      << " points(msh,cl)[1] = " << points(msh, cl)[1] << " points(msh,cl)[2] = " << points(msh, cl)[2]
                      << " points(msh,cl)[3] = " << points(msh, cl)[3] << std::endl;
            std::cout << "m = " << m << " --> q = " << q << std::endl;
            std::cout << "p_init = " << p_init << " --> pt_tmp0 = " << pt_tmp0 << " , pt_tmp1 = " << pt_tmp1
                      << " , pt_tmp2 = " << pt_tmp2 << " , pt_tmp3 = " << pt_tmp3 << std::endl;
            std::cout << "ls0 = " << ls0 << " , ls1 = " << ls1 << " , ls2 = " << ls2 << " , ls3 = " << ls3 << " AND lm = "
                      << lm << std::endl;
            std::cout << "pt_in_cell( pt_tmp0 ) = " << pt_in_cell(msh, pt_tmp0, cl) << " , pt_in_cell( pt_tmp1 ) = "
                      << pt_in_cell(msh, pt_tmp1, cl) << " , pt_in_cell( pt_tmp2 ) = " << pt_in_cell(msh, pt_tmp2, cl)
                      << " , pt_in_cel( pt_tmp3 ) = " << pt_in_cell(msh, pt_tmp3, cl) << std::endl;
            T pp = pts[0].x();
            T dist = std::abs(pp - p_init.x()) / 10.0;
            std::cout << "DIST = " << dist << " and pp = " << pp << " and p_init.x() = " << p_init.x() << std::endl;
            point_type p0 = point_type(pp + dist, m * (pp - dist) + q);
            point_type p1 = point_type(pp + (dist * 2), m * (pp + (dist * 2)) + q);
            point_type p2 = point_type(pp + (dist * 3), m * (pp + (dist * 3)) + q);
            point_type p3 = point_type(pp + (dist * 4), m * (pp + (dist * 4)) + q);
            point_type p4 = point_type(pp + (dist * 5), m * (pp + (dist * 5)) + q);
            point_type p5 = point_type(pp + (dist * 6), m * (pp + (dist * 6)) + q);
            point_type p6 = point_type(pp + (dist * 7), m * (pp + (dist * 7)) + q);
            point_type p7 = point_type(pp + (dist * 8), m * (pp + (dist * 8)) + q);
            point_type p8 = point_type(pp + (dist * 9), m * (pp + (dist * 9)) + q);
            std::cout << "p0 = " << p0 << " , level_set = " << level_set(p0, msh, cl) << " , p1 = " << p1
                      << " , level_set = " << level_set(p1, msh, cl) << " , p2 = " << p2 << " , level_set = "
                      << level_set(p2, msh, cl) << " , p3 = " << p3 << " , level_set = " << level_set(p3, msh, cl)
                      << " ,p4 = " << p4 << " , level_set = " << level_set(p4, msh, cl) << " ,p5 = " << p5
                      << " , level_set = " << level_set(p5, msh, cl) << " , p6 = " << p6 << " , level_set = "
                      << level_set(p6, msh, cl) << ", p7 = " << p7 << " , level_set = " << level_set(p7, msh, cl)
                      << " , p8 = " << p8 << " , level_set = " << level_set(p8, msh, cl) << std::endl;

//throw std::logic_error("search_boundary not find -> Stefano");
//return p_init ;

            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, pt_tmp0, cl) && std::abs(ls0) < val_min) {
                val_min = std::abs(ls0);
                ret = pt_tmp0;

            }
            if (pt_in_cell(msh, pt_tmp1, cl) && std::abs(ls1) < val_min) {
                val_min = std::abs(ls1);
                ret = pt_tmp1;

            }
            if (pt_in_cell(msh, pt_tmp2, cl) && std::abs(ls2) < val_min) {
                val_min = std::abs(ls2);
                ret = pt_tmp2;

            }
            if (pt_in_cell(msh, pt_tmp3, cl) && std::abs(ls3) < val_min) {
                val_min = std::abs(ls3);
                ret = pt_tmp3;

            }
            return ret;

        }


    }


    template<typename T, size_t ET>
    typename cuthho_mesh<T, ET>::point_type
    search_boundary(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                    typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q) {
        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        auto pts = points(msh, cl);

        point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
        point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
        point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
        point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());


        if (pt_in_cell(msh, pt_tmp0, cl) && !(p_init == pt_tmp0))
            return pt_tmp0;
        if (pt_in_cell(msh, pt_tmp1, cl) && !(p_init == pt_tmp1))
            return pt_tmp1;
        if (pt_in_cell(msh, pt_tmp2, cl) && !(p_init == pt_tmp2))
            return pt_tmp2;
        if (pt_in_cell(msh, pt_tmp3, cl) && !(p_init == pt_tmp3))
            return pt_tmp3;


    }


    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                         const Function &level_set_function, size_t min, size_t max) {
        if ((max - min) < 2)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;

        size_t mid = (max + min) / 2;
        auto p0 = cl.user_data.interface.at(min);
        auto p1 = cl.user_data.interface.at(max);
        auto pm = (p0 + p1) / 2.0;
        auto pt = p1 - p0;
        auto pn = point_type(-pt.y(), pt.x());
        auto ps1 = pm + pn;
        auto ps2 = pm - pn;


        auto lm = level_set_function(pm, msh, cl);
        auto ls1 = level_set_function(ps1, msh, cl);
        auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
        T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
        T q = pm.y() - m_half * pm.x();
        if (offset(msh, cl) == 119) {
            std::cout << yellow << bold << "CELL 119" << reset << std::endl;
            std::cout << "p0 = " << p0 << " , p1 = " << p1 << std::endl;
            std::cout << "ps1.y() = " << ps1.y() << " , pm.y() = " << pm.y() << std::endl;
            std::cout << "ps1.x() = " << ps1.x() << " , pm.x() = " << pm.x() << std::endl;
            std::cout << "ps1.x() = " << ps1.x() << " , pm.x() = " << pm.x() << std::endl;
        }
/*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
        auto pt_bdry = search_boundary(msh, cl, pm, m_half, q, lm, level_set_function);
        auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


        point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
        if (pt_in_cell(msh, ps1, cl) && (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
        } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
        } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= 0 && lm_bdry >= 0) || (lm < 0 && lm_bdry < 0)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
        } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
            std::cout << yellow << bold << "In cell " << offset(msh, cl)
                      << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, ps1, cl) && std::abs(ls1) < val_min) {
                val_min = std::abs(ls1);
                ret = ps1;
                std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

            }
            if (pt_in_cell(msh, ps2, cl) && std::abs(ls2) < val_min) {
                val_min = std::abs(ls2);
                ret = ps2;
                std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
            }
            if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry) < val_min) {
                val_min = std::abs(lm_bdry);
                ret = pt_bdry;
                std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
            }
            if (pt_in_cell(msh, pm, cl) && std::abs(lm) < val_min) {
                val_min = std::abs(lm);
                ret = pm;
                std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
            }
            std::cout << "ret = " << ret << std::endl;
            ip = ret;

        }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
        cl.user_data.interface.at(mid) = ip;

        refine_interface_pro(msh, cl, level_set_function, min, mid);
        refine_interface_pro(msh, cl, level_set_function, mid, max);
    }

    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
        if (levels == 0)
            return;


        size_t interface_points = iexp_pow(2, levels);

        for (auto &cl: msh.cells) {
            if (!is_cut(msh, cl))
                continue;

/*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
            cl.user_data.interface.resize(interface_points + 1);
            cl.user_data.interface.at(0) = cl.user_data.p0;
            cl.user_data.interface.at(interface_points) = cl.user_data.p1;

            refine_interface_pro(msh, cl, level_set_function, 0, interface_points);
/*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
        }
    }

    template<typename T, size_t ET, typename Function>
    typename cuthho_mesh<T, ET>::point_type
    search_boundary3(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                     typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q, T lm, const Function &level_set,
                     T iso_val_interface) {
        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        auto pts = points(msh, cl);

        point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
        point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
        point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
        point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());
/*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
        auto ls0 = level_set(pt_tmp0, msh, cl);
        auto ls1 = level_set(pt_tmp1, msh, cl);
        auto ls2 = level_set(pt_tmp2, msh, cl);
        auto ls3 = level_set(pt_tmp3, msh, cl);

        if (pt_in_cell(msh, pt_tmp0, cl) && (!((lm >= iso_val_interface && ls0 >= iso_val_interface) ||
                                               (lm < iso_val_interface && ls0 < iso_val_interface))))
            return pt_tmp0;
        if (pt_in_cell(msh, pt_tmp1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                               (lm < iso_val_interface && ls1 < iso_val_interface))))
            return pt_tmp1;
        if (pt_in_cell(msh, pt_tmp2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                               (lm < iso_val_interface && ls2 < iso_val_interface))))
            return pt_tmp2;
        if (pt_in_cell(msh, pt_tmp3, cl) && (!((lm >= iso_val_interface && ls3 >= iso_val_interface) ||
                                               (lm < iso_val_interface && ls3 < iso_val_interface))))
            return pt_tmp3;
        else {
            std::cout << "In cell = " << offset(msh, cl) << " points(msh,cl)[0] = " << points(msh, cl)[0]
                      << " points(msh,cl)[1] = " << points(msh, cl)[1] << " points(msh,cl)[2] = " << points(msh, cl)[2]
                      << " points(msh,cl)[3] = " << points(msh, cl)[3] << std::endl;
            std::cout << "m = " << m << " --> q = " << q << std::endl;
            std::cout << "p_init = " << p_init << " --> pt_tmp0 = " << pt_tmp0 << " , pt_tmp1 = " << pt_tmp1
                      << " , pt_tmp2 = " << pt_tmp2 << " , pt_tmp3 = " << pt_tmp3 << std::endl;
            std::cout << "ls0 = " << ls0 << " , ls1 = " << ls1 << " , ls2 = " << ls2 << " , ls3 = " << ls3 << " AND lm = "
                      << lm << std::endl;
            std::cout << "pt_in_cell( pt_tmp0 ) = " << pt_in_cell(msh, pt_tmp0, cl) << " , pt_in_cell( pt_tmp1 ) = "
                      << pt_in_cell(msh, pt_tmp1, cl) << " , pt_in_cell( pt_tmp2 ) = " << pt_in_cell(msh, pt_tmp2, cl)
                      << " , pt_in_cel( pt_tmp3 ) = " << pt_in_cell(msh, pt_tmp3, cl) << std::endl;
            T pp = pts[0].x();
            T dist = std::abs(pp - p_init.x()) / 10.0;
            std::cout << "DIST = " << dist << " and pp = " << pp << " and p_init.x() = " << p_init.x() << std::endl;
            point_type p0 = point_type(pp + dist, m * (pp - dist) + q);
            point_type p1 = point_type(pp + (dist * 2), m * (pp + (dist * 2)) + q);
            point_type p2 = point_type(pp + (dist * 3), m * (pp + (dist * 3)) + q);
            point_type p3 = point_type(pp + (dist * 4), m * (pp + (dist * 4)) + q);
            point_type p4 = point_type(pp + (dist * 5), m * (pp + (dist * 5)) + q);
            point_type p5 = point_type(pp + (dist * 6), m * (pp + (dist * 6)) + q);
            point_type p6 = point_type(pp + (dist * 7), m * (pp + (dist * 7)) + q);
            point_type p7 = point_type(pp + (dist * 8), m * (pp + (dist * 8)) + q);
            point_type p8 = point_type(pp + (dist * 9), m * (pp + (dist * 9)) + q);
            std::cout << "p0 = " << p0 << " , level_set = " << level_set(p0, msh, cl) << " , p1 = " << p1
                      << " , level_set = " << level_set(p1, msh, cl) << " , p2 = " << p2 << " , level_set = "
                      << level_set(p2, msh, cl) << " , p3 = " << p3 << " , level_set = " << level_set(p3, msh, cl)
                      << " ,p4 = " << p4 << " , level_set = " << level_set(p4, msh, cl) << " ,p5 = " << p5
                      << " , level_set = " << level_set(p5, msh, cl) << " , p6 = " << p6 << " , level_set = "
                      << level_set(p6, msh, cl) << ", p7 = " << p7 << " , level_set = " << level_set(p7, msh, cl)
                      << " , p8 = " << p8 << " , level_set = " << level_set(p8, msh, cl) << std::endl;

//throw std::logic_error("search_boundary not find -> Stefano");
//return p_init ;

            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, pt_tmp0, cl) && std::abs(ls0 - iso_val_interface) < val_min) {
                val_min = std::abs(ls0);
                ret = pt_tmp0;

            }
            if (pt_in_cell(msh, pt_tmp1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
                val_min = std::abs(ls1);
                ret = pt_tmp1;

            }
            if (pt_in_cell(msh, pt_tmp2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
                val_min = std::abs(ls2);
                ret = pt_tmp2;

            }
            if (pt_in_cell(msh, pt_tmp3, cl) && std::abs(ls3 - iso_val_interface) < val_min) {
                val_min = std::abs(ls3);
                ret = pt_tmp3;

            }
            return ret;

        }


    }


// USING INTERFACE = 1/2
    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro3(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                          const Function &level_set_function, size_t min, size_t max) {
        if ((max - min) < 2)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        T iso_val_interface = level_set_function.iso_val_interface;
        size_t mid = (max + min) / 2;
        auto p0 = cl.user_data.interface.at(min);
        auto p1 = cl.user_data.interface.at(max);
        auto pm = (p0 + p1) / 2.0;
        auto pt = p1 - p0;
        auto pn = point_type(-pt.y(), pt.x());
        auto ps1 = pm + pn;
        auto ps2 = pm - pn;


        auto lm = level_set_function(pm, msh, cl);
        auto ls1 = level_set_function(ps1, msh, cl);
        auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
        T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
        T q = pm.y() - m_half * pm.x();
/*
    if( offset(msh,cl) == 119 )
    {
        std::cout<<yellow<<bold<<"CELL 119"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"ps1.y() = "<<ps1.y() << " , pm.y() = "<<pm.y()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
    }

    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
        auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
        auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


        point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
        if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls1 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
        } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                                  (lm < iso_val_interface && ls2 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
        } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                      (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
        } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
            std::cout << yellow << bold << "In cell " << offset(msh, cl)
                      << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
                val_min = std::abs(ls1);
                ret = ps1;
                std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

            }
            if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
                val_min = std::abs(ls2);
                ret = ps2;
                std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
            }
            if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
                val_min = std::abs(lm_bdry);
                ret = pt_bdry;
                std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
            }
            if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
                val_min = std::abs(lm);
                ret = pm;
                std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
            }
            std::cout << "ret = " << ret << std::endl;
            ip = ret;

        }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
        cl.user_data.interface.at(mid) = ip;

        refine_interface_pro3(msh, cl, level_set_function, min, mid);
        refine_interface_pro3(msh, cl, level_set_function, mid, max);
    }


    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro3(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
        if (levels == 0)
            return;


        size_t interface_points = iexp_pow(2, levels);

        for (auto &cl: msh.cells) {
            if (!is_cut(msh, cl))
                continue;

/*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
            cl.user_data.interface.resize(interface_points + 1);
            cl.user_data.interface.at(0) = cl.user_data.p0;
            cl.user_data.interface.at(interface_points) = cl.user_data.p1;

            refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
/*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
        }
    }


    template<typename T, size_t ET, typename Function, typename ITERATOR>
    void
    refine_interface_pro3_disp(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                               const Function &level_set_function, ITERATOR first_pt, ITERATOR second_pt, int &counter,
                               int counter_fin, int curve_degree, T &fraz) {

        if ((counter_fin - counter) == 1)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        T iso_val_interface = level_set_function.iso_val_interface;

        auto p0 = *first_pt;
        auto p1 = *second_pt;

        auto pm = p0 + fraz * (p1 - p0);

//std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<< " , pm = "<<pm<<" , fraz = "<<fraz<<std::endl;
        fraz += 1.0 / curve_degree;
        auto pt = p1 - p0;
        auto pn = point_type(-pt.y(), pt.x());
        auto ps1 = pm + pn;
        auto ps2 = pm - pn;


        auto lm = level_set_function(pm, msh, cl);
        auto ls1 = level_set_function(ps1, msh, cl);
        auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
        T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
        T q = pm.y() - m_half * pm.x();


        auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
        auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


        point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
        if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls1 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
        } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                                  (lm < iso_val_interface && ls2 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
        } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                      (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
        } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
            std::cout << yellow << bold << "In cell " << offset(msh, cl)
                      << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
                val_min = std::abs(ls1);
                ret = ps1;
                std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

            }
            if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
                val_min = std::abs(ls2);
                ret = ps2;
                std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
            }
            if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
                val_min = std::abs(lm_bdry);
                ret = pt_bdry;
                std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
            }
            if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
                val_min = std::abs(lm);
                ret = pm;
                std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
            }
            std::cout << "ret = " << ret << std::endl;
            ip = ret;

        }
        counter++;
        cl.user_data.interface.at(counter) = ip;

        refine_interface_pro3_disp(msh, cl, level_set_function, first_pt, second_pt, counter, counter_fin, curve_degree,
                                   fraz);
    }

    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro3_disp_subcell(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                                       const Function &level_set_function, std::vector <point<T, 2>> &interface_tmp,
                                       size_t min, size_t max) {
        if ((max - min) < 2)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;
        T iso_val_interface = level_set_function.iso_val_interface;
        size_t mid = (max + min) / 2;
        auto p0 = interface_tmp.at(min);
        auto p1 = interface_tmp.at(max);
        auto pm = (p0 + p1) / 2.0;
        auto pt = p1 - p0;
        auto pn = point_type(-pt.y(), pt.x());
        auto ps1 = pm + pn;
        auto ps2 = pm - pn;


        auto lm = level_set_function(pm, msh, cl);
        auto ls1 = level_set_function(ps1, msh, cl);
        auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
        T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
        T q = pm.y() - m_half * pm.x();

/*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
        auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
        auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


        point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
        if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls1 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
        } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                                  (lm < iso_val_interface && ls2 < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
        } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                      (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
            auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
            ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
        } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
            std::cout << yellow << bold << "In cell " << offset(msh, cl)
                      << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
            point_type ret;
            T val_min = 1e10;
            if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
                val_min = std::abs(ls1);
                ret = ps1;
                std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

            }
            if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
                val_min = std::abs(ls2);
                ret = ps2;
                std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
            }
            if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
                val_min = std::abs(lm_bdry);
                ret = pt_bdry;
                std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
            }
            if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
                val_min = std::abs(lm);
                ret = pm;
                std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
            }
            std::cout << "ret = " << ret << std::endl;
            ip = ret;

        }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
        interface_tmp.at(mid) = ip;

        refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, min, mid);
        refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, mid, max);
    }

    template<typename T, size_t ET, typename Function>
    void
    refine_interface_pro3_curve_para(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels,
                                     size_t degree_curve) {

        size_t interface_points;

        if (levels == 0 && degree_curve == 1)
            return;

//if (levels == 0 && degree_curve % 2 == 0 )
//   interface_points = degree_curve+1 ;

        interface_points = iexp_pow(2, levels) * degree_curve;

        for (auto &cl: msh.cells) {
            if (!is_cut(msh, cl))
                continue;


            cl.user_data.interface.resize(interface_points + 1);
            cl.user_data.interface.at(0) = cl.user_data.p0;
            cl.user_data.interface.at(interface_points) = cl.user_data.p1;
            if (degree_curve % 2 == 0)
                refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
            else {
//std::cout<<"--> Attention it works just for P3!!! "<<std::endl;
                size_t num_subcl = iexp_pow(2, levels);
                std::vector <point<T, 2>> interface_tmp(num_subcl + 1);
                interface_tmp.at(0) = cl.user_data.p0;
                interface_tmp.at(num_subcl) = cl.user_data.p1;
                if (levels > 0) {
                    refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, 0, num_subcl);
                }
                int counter = 0;
//std::cout<<"cl.user_data.p0 = "<<cl.user_data.p0<<" ,  cl.user_data.p1 = "<< cl.user_data.p1<<std::endl;
//std::cout<<"interface_tmp[0] = "<<interface_tmp[0]<<" , interface_tmp[1] = "<< interface_tmp[1]<<" , interface_tmp[2] = "<< interface_tmp[2]<<std::endl;
                for (auto first_pt = interface_tmp.begin(); first_pt < interface_tmp.end() - 1; first_pt++) {
                    auto second_pt = first_pt + 1;
                    int counter_fin = counter + degree_curve;
                    T fraz = 1.0 / degree_curve;
//std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<<std::endl;
                    refine_interface_pro3_disp(msh, cl, level_set_function, first_pt, second_pt, counter, counter_fin,
                                               degree_curve, fraz);

                    counter++;
                    if (counter < interface_points)
                        cl.user_data.interface.at(counter) = *second_pt;
                }
            }
        }
    }


    template<typename T, size_t ET, typename Function>
    void
    refine_interface_angle(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                           const Function &level_set_function, size_t min, size_t max,
                           typename cuthho_mesh<T, ET>::point_type &p_init, T h, bool pos, int multiplicity, T angle0,
                           T angle1) {
        if ((max - min) < 2)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;


        T angle_half = (angle0 + angle1) / 2.0;
        T m_half = tan(angle_half);

        std::cout << bold << yellow << "CHECK ANGLE --------> " << reset << "angle0 = " << angle0 * 180 / M_PI
                  << " , angle1 = " << angle1 * 180 / M_PI << " and angle_half = " << angle_half * 180 / M_PI << std::endl;

/*
    // In the case h is not long enough!
    T h_max = 0.0;
    if(multiplicity > 1  )
    {
        T cateto_min = 2*m_half/h ;
        h_max = std::max( h , sqrt( pow(cateto_min,2) + pow(h,2)/4.0 ) );
    }
    */

// CASE h:
        T val = sqrt(pow(h, 2) / (1 + pow(m_half, 2)));

        T x_new0 = p_init.x() + val;
        T y_new0 = p_init.y() + (x_new0 - p_init.x()) * m_half;
        point_type pt_half0 = point_type(x_new0, y_new0);

        auto lm0 = level_set_function(pt_half0, msh, cl);

        T x_new1 = p_init.x() - val;
        T y_new1 = p_init.y() + (x_new1 - p_init.x()) * m_half;
        point_type pt_half1 = point_type(x_new1, y_new1);

        auto lm1 = level_set_function(pt_half1, msh, cl);




// CASE h_max = h*sqrt(2)
        T h_max = h * sqrt(2.0);
        T val_max = sqrt(pow(h_max, 2) / (1 + pow(m_half, 2)));
        T x_new_max0 = p_init.x() + val_max;
        T y_new_max0 = p_init.y() + (x_new_max0 - p_init.x()) * m_half;
        T x_new_max1 = p_init.x() - val_max;
        T y_new_max1 = p_init.y() + (x_new_max1 - p_init.x()) * m_half;


        point_type pt_half_max0 = point_type(x_new_max0, y_new_max0);
        point_type pt_half_max1 = point_type(x_new_max1, y_new_max1);

        auto lm_max0 = level_set_function(pt_half_max0, msh, cl);
        auto lm_max1 = level_set_function(pt_half_max1, msh, cl);

// CASE h_min = h/2
        T h_min = h / 2.0;
        T val_min = sqrt(pow(h_min, 2) / (1 + pow(m_half, 2)));
        T x_new_min0 = p_init.x() + val_min;
        T y_new_min0 = p_init.y() + (x_new_min0 - p_init.x()) * m_half;
        T x_new_min1 = p_init.x() - val_min;
        T y_new_min1 = p_init.y() + (x_new_min1 - p_init.x()) * m_half;


        point_type pt_half_min0 = point_type(x_new_min0, y_new_min0);
        point_type pt_half_min1 = point_type(x_new_min1, y_new_min1);

        auto lm_min0 = level_set_function(pt_half_min0, msh, cl);
        auto lm_min1 = level_set_function(pt_half_min1, msh, cl);



// CASE PT on the boudary
        T q = p_init.y() - m_half * p_init.x();

        auto pt_bdry = search_boundary(msh, cl, p_init, m_half, q);
        auto lm_bdry = level_set_function(pt_bdry, msh, cl);


        size_t mid = (max + min) / 2;
        point_type ip;
        auto p0 = cl.user_data.interface.at(min);
        auto p1 = cl.user_data.interface.at(max);
        auto pm = (p0 + p1) / 2.0;
//std::cout<<"p_init = "<<p_init<< " level_set(p_init) = "<<level_set_function(p_init,msh,cl)<<std::endl;


        if (pt_in_cell(msh, pt_half0, cl) && !((lm0 >= 0 && pos == TRUE) || (lm0 < 0 && pos == FALSE))) {

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half0, level_set_function, threshold, msh, cl);
            std::cout << "NORMAL + --> pt_half0 = " << pt_half0 << " and lm0 = " << lm0 << " ------> ip = " << ip
                      << std::endl;
        } else if (pt_in_cell(msh, pt_half1, cl) && !((lm1 >= 0 && pos == TRUE) || (lm1 < 0 && pos == FALSE))) {

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half1, level_set_function, threshold, msh, cl);
            std::cout << "NORMAL - --> pt_half1 = " << pt_half1 << " and lm1 = " << lm1 << " ------> ip = " << ip
                      << std::endl;

        } else if (pt_in_cell(msh, pt_bdry, cl) && !((lm_bdry >= 0 && pos == TRUE) || (lm_bdry < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_bdry, level_set_function, threshold, msh, cl);
            std::cout << "BDRY - --> pt_bdry = " << pt_bdry << " and lm_bdry = " << lm_bdry << " --> ip = " << ip
                      << std::endl;

        } else if (pt_in_cell(msh, pt_half_max0, cl) && !((lm_max0 >= 0 && pos == TRUE) || (lm_max0 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MAX POINT (WITH +) IS IN CELL"<<std::endl;

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half_max0, level_set_function, threshold, msh, cl);
            std::cout << "MAX + --> pt_max0 = " << pt_half_max0 << " and lm_max0 = " << lm_max0 << " --> ip = " << ip
                      << std::endl;

        } else if (pt_in_cell(msh, pt_half_max1, cl) && !((lm_max1 >= 0 && pos == TRUE) || (lm_max1 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MAX POINT (WITH -) IS IN CELL"<<std::endl;

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half_max1, level_set_function, threshold, msh, cl);
            std::cout << "MAX - --> pt_max1 = " << pt_half_max1 << " and lm_max1 = " << lm_max1 << " --> ip = " << ip
                      << std::endl;

        } else if (pt_in_cell(msh, pt_half_min0, cl) && !((lm_min0 >= 0 && pos == TRUE) || (lm_min0 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH +) IS IN CELL"<<std::endl;

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half_min0, level_set_function, threshold, msh, cl);
            std::cout << "MIN + --> pt_min0 = " << pt_half_min0 << " and lm_min0 = " << lm_min0 << " --> ip = " << ip
                      << std::endl;

        } else if (pt_in_cell(msh, pt_half_min1, cl) && !((lm_min1 >= 0 && pos == TRUE) || (lm_min1 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

            auto threshold = diameter(msh, cl) / 1e20;
            ip = find_zero_crossing_in_cell(p_init, pt_half_min1, level_set_function, threshold, msh, cl);
            std::cout << "MIN - --> pt_min1 = " << pt_half_min1 << " and lm_min1 = " << lm_min1 << " --> ip = " << ip
                      << std::endl;

        } else {
// IN THE CASE I DON'T FIND THE POINT I CONSIDER IT LINEAR

            std::cout << "-----> ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED!"
                      << std::endl;
            std::cout << "p_init = " << p_init << " level_set(p_init) = " << level_set_function(p_init, msh, cl)
                      << std::endl;
            std::cout << "CASE + : pt_half0 = " << pt_half0 << " and lm0 = " << lm0 << std::endl;
            std::cout << "CASE - : pt_half1 = " << pt_half1 << " and lm1 = " << lm1 << std::endl;
            std::cout << "CASE MAX+: pt_half_max0 = " << pt_half_max0 << " and lm_max0 = " << lm_max0 << std::endl;
            std::cout << "CASE MAX-: pt_half_max1 = " << pt_half_max1 << " and lm_max1 = " << lm_max1 << std::endl;
            std::cout << "CASE MIN +: pt_half_min0 = " << pt_half_min0 << " and lm_min0 = " << lm_min0 << std::endl;
            std::cout << "CASE MIN -: pt_half_min1 = " << pt_half_min1 << " and lm_min1 = " << lm_min1 << std::endl;
            std::cout << "CASE BDRY: pt_bdry = " << pt_bdry << " and lm_bdry = " << lm_bdry << std::endl;
            std::cout << "--> ip = pm =  " << pm << std::endl;
            std::cout << "ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED! <-------"
                      << std::endl;
            ip = pm;
        }


        cl.user_data.interface.at(mid) = ip;

        refine_interface_angle(msh, cl, level_set_function, min, mid, p_init, h, pos, multiplicity, angle0, angle_half);
        refine_interface_angle(msh, cl, level_set_function, mid, max, p_init, h, pos, multiplicity, angle_half, angle1);
    }


    template<typename T, size_t ET, typename Function>
    void
    refine_interface_angle(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
        if (levels == 0)
            return;

        typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::node_type node_type;
        size_t interface_points = iexp_pow(2, levels);

        for (auto &cl: msh.cells) {
            if (!is_cut(msh, cl))
                continue;

            cl.user_data.interface.resize(interface_points + 1);
            cl.user_data.interface.at(0) = cl.user_data.p0;
            cl.user_data.interface.at(interface_points) = cl.user_data.p1;
            std::cout << yellow << bold << "--------------------> CELL = " << offset(msh, cl) << " <--------------------"
                      << reset << std::endl;
// ADDED BY STEFANO
            point_type pos0 = cl.user_data.p0;
            point_type pos1 = cl.user_data.p1;

            bool positive = TRUE;
            int multiplicity = 1;
            std::vector <size_t> position_neg, position_pos;
            T angle0, angle1;
            point_type pm;

            size_t counter = 0;
            for (auto &nd: nodes(msh, cl)) {

                if (nd.user_data.location == element_location::IN_NEGATIVE_SIDE) {
                    position_neg.push_back(counter);
                } else {

                    position_pos.push_back(counter);
                }
                counter++;
//std::cout<<"nd = "<<nd.ptid<<std::endl;
            }

/// FIND  EXTREME  ANGLES
            if (position_neg.size() == 1) {

                pm = points(msh, cl)[position_neg[0]];
                std::cout << "POINT" << pm << " , position_neg = " << position_neg[0] << std::endl;
                positive = FALSE;
                if (position_neg[0] == 0) {
                    angle0 = 0.0 * M_PI;
                    angle1 = M_PI / 2.0;
                } else if (position_neg[0] == 1) {
                    angle0 = M_PI / 2.0;
                    angle1 = M_PI;
                } else if (position_neg[0] == 2) {
                    angle0 = M_PI;
                    angle1 = 3.0 * M_PI / 2.0;
                } else if (position_neg[0] == 3) {
                    angle0 = 3.0 * M_PI / 2.0;
                    angle1 = 2.0 * M_PI;
                } else {
                    throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
                }
            } else if (position_pos.size() == 1) {
                std::cout << yellow << bold << "CASO POSITIVO MA TOGLIEREI E METTEREI SOLO CASI NEGATIVI!!!" << reset
                          << std::endl;
                pm = points(msh, cl)[position_pos[0]];
                std::cout << "POINT" << pm << " , position_pos = " << position_pos[0] << std::endl;
                if (position_pos[0] == 0) {
                    angle0 = 0.0 * M_PI;
                    angle1 = M_PI / 2.0;
                } else if (position_pos[0] == 1) {
                    angle0 = M_PI / 2.0;
                    angle1 = M_PI;
                } else if (position_pos[0] == 2) {
                    angle0 = M_PI;
                    angle1 = 3.0 * M_PI / 2.0;
                } else if (position_pos[0] == 3) {
                    angle0 = 3.0 * M_PI / 2.0;
                    angle1 = 2.0 * M_PI;
                } else {
                    throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
                }

            } else {
//std::cout<<"sono qua 4 NEW"<<std::endl;
//if(plus_close(p0,))
// MULTIPLICITY 2 -> #pos_point = #neg_point = 2
                if (position_neg[0] == 0 && position_neg[1] == 1) {
                    positive = FALSE;
                    pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
                    multiplicity = 2;
                    angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                    angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                    if (angle0 < 0)
                        angle0 += M_PI;
                    else
                        angle1 += M_PI;
                } else if (position_neg[0] == 1 && position_neg[1] == 2) {
                    positive = FALSE;
                    pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
                    multiplicity = 2;
                    angle0 = M_PI + atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                    angle1 = M_PI + atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

                } else if (position_neg[0] == 2 && position_neg[1] == 3) {
                    positive = FALSE;
                    pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
                    multiplicity = 2;
                    angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                    angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                    if (angle0 > 0)
                        angle0 += M_PI;
                    else
                        angle1 += M_PI;

                    if (angle0 < 0)
                        angle0 = 2.0 * M_PI + angle0;
                    else
                        angle1 = 2.0 * M_PI + angle1;

                } else if (position_neg[0] == 0 && position_neg[1] == 3) {
                    positive = FALSE;
                    pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
                    multiplicity = 2;
                    angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                    angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

                } else if (position_neg[0] == 0 && position_neg[1] == 2) {
//positive = FALSE ;
                    pm = points(msh, cl)[1];
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
//multiplicity = 2 ;
                    angle0 = M_PI / 2.0;
                    angle1 = M_PI;

                } else if (position_neg[0] == 1 && position_neg[1] == 3) {
//positive = FALSE ;
                    pm = points(msh, cl)[0];
                    std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                              << position_neg[1] << std::endl;
//multiplicity = 2 ;
                    angle0 = 0.0 * M_PI;
                    angle1 = M_PI / 2.0;

                } else {
                    throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
                }
            }


            if (angle0 > angle1) {
                T tmp = angle1;
                angle1 = angle0;
                angle0 = tmp;
            }
//std::cout<<"CHECK ANGLE --------> angle0 = "<<angle0<< " and angle1 = "<<angle1<<std::endl;


            auto checK_sign = level_set_function(pm, msh, cl);

            if ((positive == FALSE && std::signbit(checK_sign) == 0) ||
                (positive == TRUE && std::signbit(checK_sign) == 1)) {
                std::cout << "LEVEL SET(Pm) = " << checK_sign << " and sign used is = " << positive << " and signbit is "
                          << std::signbit(checK_sign) << std::endl;
                throw std::logic_error("HO FATTO ERRORE IN POSITIVE SIGN CHECKING");
            }


            T h = std::min(level_set_function.params.hx(), level_set_function.params.hy());


            refine_interface_angle(msh, cl, level_set_function, 0, interface_points, pm, h, positive, multiplicity, angle0,
                                   angle1);


            std::cout << "LIMIT CELL " << offset(msh, cl) << " are:" << std::endl;
            std::cout << "pt[0] = " << points(msh, cl)[0] << " , pt[1] = " << points(msh, cl)[1] << " , pt[2] = "
                      << points(msh, cl)[2] << " , pt[3] = " << points(msh, cl)[3] << std::endl;

            for (size_t i_int = 0; i_int < interface_points + 1; i_int++)
                std::cout << "refined points are p = " << cl.user_data.interface.at(i_int) << std::endl;
            std::cout << "--------------------> CELL = " << offset(msh, cl) << "<--------------------" << std::endl;
        }

    }



    template<typename T, typename Mesh>
    bool
    pt_in_cell(const Mesh &msh, const point<T, 2> &, const typename Mesh::cell_type &);

    template<typename T, typename Mesh>
    std::vector <point<T, 2>>
    equidistriduted_nodes(const Mesh &, const typename Mesh::cell_type &, size_t);

    template<typename T, typename Mesh>
    std::vector <point<T, 2>>
    equidistriduted_nodes_subcell(const Mesh &,
                                  const typename Mesh::cell_type &,
                                  size_t, const std::vector <size_t> &);








    template<typename FonctionD, typename Mesh>
    void
    testing_level_set(const Mesh &msh, const FonctionD &level_set_disc, std::string &folder) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, derDx, derDy;
        Eigen::Matrix<double, 2, 1> derD;
        point<double, 2> node;
        size_t N, M;

        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!
        auto test_disc = std::make_shared < gnuplot_output_object < double > > (folder + "testing_interface_disc.dat");


        auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_discX.dat");

        auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_discY.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > (folder + "test_profile_disc.dat");

        auto test_profile_obliq_disc =
                std::make_shared < gnuplot_output_object < double > > (folder + "test_profile_obliq.dat");


        auto test_disc_grad = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_disc_fin.dat");

        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();
            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {

                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);
                    valueD = level_set_disc(node, msh, cl);
                    derD = level_set_disc.gradient(node, msh, cl);


                    derDx = derD(0);
                    derDy = derD(1);


                    test_disc->add_data(node, valueD);

                    test_disc_gradX->add_data(node, derDx);
                    test_disc_gradY->add_data(node, derDy);
                    test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));

                }


            }
        }

        for (size_t i = 0; i <= 100; i++) {
            double px = i * ((1.0) / 100.0);
            node = point_type(px, 0.5);
            valueD = level_set_disc(node);
            test_profile_disc->add_data(node, valueD);
        }

        for (size_t i = 0; i <= 100; i++) {
            double px = i * ((1.0) / 100.0);
            node = point_type(px, px);
            valueD = level_set_disc(node);
            test_profile_obliq_disc->add_data(node, valueD);
        }


        postoutput1.add_object(test_disc);

        postoutput1.add_object(test_disc_grad);
        postoutput1.add_object(test_disc_gradX);

        postoutput1.add_object(test_disc_gradY);

        postoutput1.add_object(test_profile_disc);

        postoutput1.add_object(test_profile_obliq_disc);


        postoutput1.write();

    }

    template<typename FonctionD, typename Mesh>
    void
    testing_level_set_mapped(const Mesh &msh, const FonctionD &level_set_disc) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, derDx, derDy;
        Eigen::Matrix<double, 2, 1> derD;
        point<double, 2> node;
        size_t N, M;

        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_mapped.dat");


        auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX_mapped.dat");

        auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY_mapped.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_mapped.dat");

        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();
            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {

                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);
                    valueD = level_set_disc(node, msh, cl);
                    derD = level_set_disc.gradient(node, msh, cl);


                    derDx = derD(0);
                    derDy = derD(1);


                    test_disc->add_data(node, valueD);

                    test_disc_gradX->add_data(node, derDx);
                    test_disc_gradY->add_data(node, derDy);


                }


            }
        }

        for (size_t i = 0; i <= 100; i++) {
            double px = i * ((1.0) / 100.0);
            node = point_type(px, 0.5);
            valueD = level_set_disc(node);
            test_profile_disc->add_data(node, valueD);
        }

        postoutput1.add_object(test_disc);


        postoutput1.add_object(test_disc_gradX);

        postoutput1.add_object(test_disc_gradY);

        postoutput1.add_object(test_profile_disc);


        postoutput1.write();

    }

    template<typename FonctionD, typename Mesh>
    void
    testing_level_set_inverse_mapped(const Mesh &msh, const FonctionD &level_set_disc) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, derDx, derDy;
        Eigen::Matrix<double, 2, 1> derD;
        point<double, 2> node;
        size_t N, M;

        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!
        auto test_disc =
                std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_inverse_mapped.dat");


        auto test_disc_gradX =
                std::make_shared < gnuplot_output_object < double > > ("testing_der_discX_inverse_mapped.dat");

        auto test_disc_gradY =
                std::make_shared < gnuplot_output_object < double > > ("testing_der_discY_inverse_mapped.dat");

        auto test_profile_disc =
                std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_inverse_mapped.dat");

        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();
            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {

                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);
                    valueD = level_set_disc(node, msh, cl);
                    derD = level_set_disc.gradient(node, msh, cl);


                    derDx = derD(0);
                    derDy = derD(1);


                    test_disc->add_data(node, valueD);

                    test_disc_gradX->add_data(node, derDx);
                    test_disc_gradY->add_data(node, derDy);


                }


            }
        }

        for (size_t i = 0; i <= 100; i++) {
            double px = i * ((1.0) / 100.0);
            node = point_type(px, 0.5);
            valueD = level_set_disc(node);
            test_profile_disc->add_data(node, valueD);
        }

        postoutput1.add_object(test_disc);


        postoutput1.add_object(test_disc_gradX);

        postoutput1.add_object(test_disc_gradY);

        postoutput1.add_object(test_profile_disc);


        postoutput1.write();

    }

    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    testing_level_set(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA, derDx, derDy, derAx, derAy, value_profile, value_profile_anal;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        std::cout << "In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_anal.dat");

        auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX.dat");
        auto test_anal_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_analX.dat");

        auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY.dat");
        auto test_anal_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_analY.dat");

        auto test_anal_grad = std::make_shared < gnuplot_output_object < double > > ("testing_der_anal.dat");
        auto test_disc_grad = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc.dat");
        auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_anal.dat");

        auto pt_c_x = level_set_anal.alpha;
        auto pt_c_y = level_set_anal.beta;
        auto pt_c = point_type(pt_c_x, pt_c_y);
        double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();

            if (pt_in_cell(msh, pt_c, cl)) {
                test_disc_gradX->add_data(node, derDx);
                test_anal_gradX->add_data(node, derAx);
                test_disc_gradY->add_data(node, derDy);
                test_anal_gradY->add_data(node, derAy);

                test_anal_grad->add_data(node, sqrt(derAx * derAx + derAy * derAy));
                test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));
            }

            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {
                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);

                    valueA = level_set_anal(node);
                    valueD = level_set_disc(node, msh, cl);


                    test_disc->add_data(node, valueD);
                    test_anal->add_data(node, valueA);


                    derA = level_set_anal.gradient(node);
                    derD = level_set_disc.gradient(node, msh, cl);
                    derDx = derD(0);
                    derDy = derD(1);
                    derAx = derA(0);
                    derAy = derA(1);

                    test_disc_gradX->add_data(node, derDx);
                    test_anal_gradX->add_data(node, derAx);
                    test_disc_gradY->add_data(node, derDy);
                    test_anal_gradY->add_data(node, derAy);

                    test_anal_grad->add_data(node, sqrt(derAx * derAx + derAy * derAy));
                    test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));

                }

                node = point_type(px, py);
                value_profile = level_set_disc(node, msh, cl);
                test_profile_disc->add_data(node, value_profile);
                value_profile_anal = level_set_anal(node);
                test_profile_anal->add_data(node, value_profile_anal);
            }

        }


        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);

        postoutput1.add_object(test_disc_gradX);
        postoutput1.add_object(test_anal_gradX);
        postoutput1.add_object(test_disc_gradY);
        postoutput1.add_object(test_anal_gradY);

        postoutput1.add_object(test_anal_grad);
        postoutput1.add_object(test_disc_grad);


        postoutput1.add_object(test_profile_disc);
        postoutput1.add_object(test_profile_anal);

        postoutput1.write();

    }


    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    testing_level_set_disc(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA, derDx, derDy, derAx, derAy, value_profile, value_profile_anal;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        std::cout << "In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_tmp.dat");

        auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX.dat");
        auto test_anal_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc_tmp_X.dat");

        auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY.dat");
        auto test_anal_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc_tmp_Y.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc.dat");
        auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_tmp.dat");


        double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();

            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {
                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);

                    valueA = level_set_anal(node, msh, cl);
                    valueD = level_set_disc(node, msh, cl);


                    test_disc->add_data(node, valueD);
                    test_anal->add_data(node, valueA);


                    derA = level_set_anal.gradient(node, msh, cl);
                    derD = level_set_disc.gradient(node, msh, cl);
                    derDx = derD(0);
                    derDy = derD(1);
                    derAx = derA(0);
                    derAy = derA(1);

                    test_disc_gradX->add_data(node, derDx);
                    test_anal_gradX->add_data(node, derAx);
                    test_disc_gradY->add_data(node, derDy);
                    test_anal_gradY->add_data(node, derAy);


                }

                node = point_type(px, py);
                value_profile = level_set_disc(node, msh, cl);
                test_profile_disc->add_data(node, value_profile);
                value_profile_anal = level_set_anal(node, msh, cl);
                test_profile_anal->add_data(node, value_profile_anal);
            }

        }


        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);

        postoutput1.add_object(test_disc_gradX);
        postoutput1.add_object(test_anal_gradX);
        postoutput1.add_object(test_disc_gradY);
        postoutput1.add_object(test_anal_gradY);

        postoutput1.add_object(test_profile_disc);
        postoutput1.add_object(test_profile_anal);

        postoutput1.write();

    }


    template<typename FonctionD, typename Mesh>
    void
    testing_level_set2_bis(const Mesh msh, const FonctionD &level_set_disc) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD; // , derDx , derDy ;
        Eigen::Matrix<double, 2, 1> derD;
        point<double, 2> node;
        size_t N, M;
        std::cout
                << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."
                << std::endl;
        N = 40; //80 points to see also the interface!!!
        M = 40; //80 points to see also the interface!!!
        double valueD_gamma;
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_bis.dat");

        auto test_gamma_disc = std::make_shared < gnuplot_output_object < double > > ("test_gamma_disc_bis.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin_bis.dat");

        double iso_val_interface = level_set_disc.iso_val_interface;

        for (size_t i = 0; i <= N; i++) {
            for (size_t j = 0; j <= M; j++) {
                double px = i * (1.0 / N);
                double py = j * (1.0 / M);
                node = point_type(px, py);

                if (std::abs(level_set_disc(node) - iso_val_interface) < 1 * 1e-3) {
                    valueD_gamma = 1;
                } else
                    valueD_gamma = 0;

                valueD = level_set_disc(node);


                if (py == 0.5) {
                    test_profile_disc->add_data(node, valueD);

                }


                test_disc->add_data(node, valueD);

                test_gamma_disc->add_data(node, valueD_gamma);


            }

        }
        postoutput1.add_object(test_disc);

        postoutput1.add_object(test_gamma_disc);

        postoutput1.add_object(test_profile_disc);

        postoutput1.write();

    }

    template<typename FonctionD, typename Mesh>
    void
    testing_level_set2(const Mesh &msh, const FonctionD &level_set_disc) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, value_profile;
        point<double, 2> node;
        size_t N, M;
        std::cout
                << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."
                << std::endl;
        N = 4; //80 points to see also the interface!!!
        M = 4; //80 points to see also the interface!!!

        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc.dat");

//auto test_gamma_disc = std::make_shared< gnuplot_output_object<double> >("test_gamma_disc.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin.dat");

        double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            auto pt0_x = pts[0].x();
            auto pt1_x = pts[1].x();
            auto pt0_y = pts[0].y();
            auto pt1_y = pts[3].y();

            for (size_t i = 0; i <= N; i++) {
                double px = pt0_x + i * ((pt1_x - pt0_x) / N);
                for (size_t j = 0; j <= M; j++) {
                    double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                    node = point_type(px, py);

                    valueD = level_set_disc(node, msh, cl);
                    test_disc->add_data(node, valueD);


                }

                node = point_type(px, py);
                value_profile = level_set_disc(node, msh, cl);
                test_profile_disc->add_data(node, value_profile);
            }

        }
        postoutput1.add_object(test_disc);

        postoutput1.add_object(test_profile_disc);

        postoutput1.write();

    }

    template<typename FonctionD, typename Mesh>
    void
    testing_level_set2(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA; //, derDx , derDy , derAx , derAy;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        std::cout << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
        N = 40; //80 points to see also the interface!!!
        M = 40; //80 points to see also the interface!!!
        double valueA_gamma, valueD_gamma;
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal.dat");
        auto test_gamma_disc = std::make_shared < gnuplot_output_object < double > > ("test_gamma_disc.dat");
        auto test_gamma_anal = std::make_shared < gnuplot_output_object < double > > ("test_gamma_anal.dat");

        auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin.dat");
        auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_anal_fin.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
        for (size_t i = 0; i <= N; i++) {
            for (size_t j = 0; j <= M; j++) {
                double px = i * (1.0 / N);
                double py = j * (1.0 / M);
                node = point_type(px, py);

                if (std::abs(level_set_disc(node)) < 1 * 1e-3) {
                    valueD_gamma = 1;
                } else
                    valueD_gamma = 0;

                valueD = level_set_disc(node);

                if (std::abs(level_set_fin(node)) < 1 * 1e-3) {
                    valueA_gamma = 1;
                } else
                    valueA_gamma = 0;

                valueA = level_set_fin(node);


                if (py == 0.5) {
                    test_profile_disc->add_data(node, valueD);
                    test_profile_anal->add_data(node, valueA);
                }

/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);
                test_gamma_disc->add_data(node, valueD_gamma);
                test_gamma_anal->add_data(node, valueA_gamma);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
            }

        }
        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);
        postoutput1.add_object(test_gamma_disc);
        postoutput1.add_object(test_gamma_anal);
        postoutput1.add_object(test_profile_disc);
        postoutput1.add_object(test_profile_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
        postoutput1.write();

    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh>
    void
    testing_level_set_mesh2(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA; //, derDx , derDy , derAx , derAy;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        N = 40;
        M = 40;
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh2.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh2.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
        for (size_t i = 0; i <= N; i++) {
            for (size_t j = 0; j <= M; j++) {
                double px = i * (1.0 / N);
                double py = j * (1.0 / M);
                node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
                valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
                valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
            }

        }
        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
        postoutput1.write();

    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh>
    void
    testing_level_set_mesh1(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA; //, derDx , derDy , derAx , derAy;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        N = 40;
        M = 40;
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh1.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh1.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
        for (size_t i = 0; i <= N; i++) {
            for (size_t j = 0; j <= M; j++) {
                double px = i * (1.0 / N);
                double py = j * (1.0 / M);
                node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
                valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
                valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
            }

        }
        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
        postoutput1.write();

    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh>
    void
    testing_level_set_mesh0(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
        typedef typename Mesh::point_type point_type;
        postprocess_output<double> postoutput1;
        double valueD, valueA; //, derDx , derDy , derAx , derAy;
        Eigen::Matrix<double, 2, 1> derD, derA;
        point<double, 2> node;
        size_t N, M;
        N = 40;
        M = 40;
        auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh0.dat");
        auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh0.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
        for (size_t i = 0; i <= N; i++) {
            for (size_t j = 0; j <= M; j++) {
                double px = i * (1.0 / N);
                double py = j * (1.0 / M);
                node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
                valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
                valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
            }

        }
        postoutput1.add_object(test_disc);
        postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
        postoutput1.write();

    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    test_new_method(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                    const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
        double valueD1, valueD2, valueA;

        auto pts = points(msh, cl);


        timecounter tc1;
        tc1.tic();
        for (auto &pt: pts) {
            valueD1 = level_set_disc(pt, msh, cl);
// valueA = level_set_anal(pt);
// valueD2 = level_set_disc(pt);
// std::cout<<"Differnce between two evaluation system "<<(valueD1-valueD2)<<std::endl;
//  std::cout<<"Im in test_new_method";
        }


        tc1.toc();
        std::cout << bold << yellow << "Time for the new evaluation: " << tc1 << " seconds" << reset << std::endl;

        tc1.tic();
        for (auto &pt: pts) {
            valueD2 = level_set_disc(pt);
//  std::cout<<"Im in test_new_method";
        }
        tc1.toc();
        std::cout << bold << yellow << "Time for the old evaluation: " << tc1 << " seconds" << reset << std::endl;

        tc1.tic();
        for (auto &pt: pts) {
            valueA = level_set_anal(pt);
        }
        tc1.toc();
        std::cout << bold << yellow << "Time for the analytic evaluation: " << tc1 << " seconds" << reset << std::endl;


    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh>
    void
    time_NEWdiscrete_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
        double valueD1; //, valueD2 ,valueA ;

        auto pts = points(msh, cl);


        for (auto &pt: pts) {
            valueD1 = level_set_disc(pt, msh, cl);

        }


    }

// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh>
    void
    time_OLDdiscrete_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
        double valueD1; //, valueA ; // valueD2 ,

        auto pts = points(msh, cl);


        for (auto &pt: pts) {
            valueD1 = level_set_disc(pt);

        }


    }

    template<typename FonctionA, typename Mesh>
    void
    time_analytic_testing(const Mesh msh, const FonctionA &level_set_anal, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
        double valueA; // valueD1 , valueD2 ,

        auto pts = points(msh, cl);


        for (auto &pt: pts) {
            valueA = level_set_anal(pt);

        }


    }


    template<typename FonctionD, typename Mesh>
    void
    time_face_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::face_type &fc) {

//typedef typename Mesh::point_type       point_type;
        double valueD1;// , valueD2 ,valueA ;

        auto pts = points(msh, fc);


        for (auto &pt: pts) {
            valueD1 = level_set_disc(pt, msh, fc);

        }


    }

    template<typename FonctionA, typename Mesh>
    void
    time_faceANALITIC_testing(const Mesh msh, const FonctionA &level_set_anal, const typename Mesh::face_type &fc) {

//typedef typename Mesh::point_type       point_type;
        double valueA; // valueD1 , valueD2 ,

        auto pts = points(msh, fc);


        for (auto &pt: pts) {
            valueA = level_set_anal(pt);

        }


    }


// Qualitative testing of the discrete level set function wrt the analytical one
    template<typename FonctionD, typename Mesh, typename FonctionA>
    void
    test_new_method(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                    const typename Mesh::cell_type &cl, const typename Mesh::face_type &fc) {
//typedef typename Mesh::point_type       point_type;
        double valueD1, valueA, valueD3; //, valueD2

        auto pts = points(msh, fc);


        timecounter tc1;
        tc1.tic();
        for (auto &pt: pts) {
            valueD1 = level_set_disc(pt, msh, fc);
            valueA = level_set_anal(pt);
//valueD2 = level_set_disc(pt,msh,cl);
            valueD3 = level_set_disc(pt);

            std::cout << "Differnce between FACE and OLD evaluation system " << (valueD1 - valueD3) << std::endl;
            std::cout << "Error between analytic and face evaluation " << (valueD1 - valueA) << std::endl;
        }


    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type, typename VEC>
    void Lp_space_Tfin_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                                 size_t degree, double p, VEC &error) {
        T errorLp = 0.;
        for (auto &cl: msh.cells) {
            auto qps = integrate(msh, cl, 2 * degree + 2);
            for (auto &qp: qps) {
                auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
                errorLp += qp.second * pow(diff_val, p);
            }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
        }
//std::cout<<"The L^"<<p<<" error is "<< pow (errorLp , 1.0/p )<<std::endl;
        error.push_back(pow(errorLp, 1.0 / p));
    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    void Lp_space_Tfin_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                                 size_t degree, double p) {
        T errorLp = 0.;
        for (auto &cl: msh.cells) {
            auto qps = integrate(msh, cl, 2 * degree + 2);
            for (auto &qp: qps) {
                auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
                errorLp += qp.second * pow(diff_val, p);
            }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
        }
        std::cout << "The L^" << p << " error is " << pow(errorLp, 1.0 / p) << std::endl;
    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T
    Linf_error_FEM_new(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
        T errorLinf = ((level_set_final.sol_HHO - level_set_initial.sol_HHO).cwiseAbs()).maxCoeff();
        return errorLinf;

    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T W1inf_error_FEM_new(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                          size_t degree) {
        T errorLinf0 = 0.0, errorLinf1 = 0.0;

        for (auto &cl: msh.cells) {
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
//auto pts = points(msh,cl);
            for (auto &pt: pts) {
                auto diff_val0 = std::abs(
                        level_set_final.gradient(pt, msh, cl)(0) - level_set_initial.gradient(pt, msh, cl)(0));
                errorLinf0 = std::max(errorLinf0, diff_val0);
                auto diff_val1 = std::abs(
                        level_set_final.gradient(pt, msh, cl)(1) - level_set_initial.gradient(pt, msh, cl)(1));
                errorLinf1 = std::max(errorLinf1, diff_val1);
            }

        }
        return errorLinf0 + errorLinf1;

    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T Lp_space_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree,
                         double p) {
// L^p in space ; l^q in time
        T errorLp = 0.;
        for (auto &cl: msh.cells) {
            auto qps = integrate(msh, cl, 2 * degree + 2); // what orders?
            for (auto &qp: qps) {
                auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
                errorLp += qp.second * pow(diff_val, p);
            }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
        }
        errorLp = pow(errorLp, 1.0 / p);
//std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
        return errorLp;
    }

    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T W1p_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree,
                    double p) {
        T errorH1 = 0.;
        for (auto &cl: msh.cells) {
            auto qps = integrate(msh, cl, 2 * degree + 2); // what orders?
            for (auto &qp: qps) {
                auto diff_val0 = std::abs(
                        level_set_final.gradient(qp.first, msh, cl)(0) - level_set_initial.gradient(qp.first, msh, cl)(0));
                auto diff_val1 = std::abs(
                        level_set_final.gradient(qp.first, msh, cl)(1) - level_set_initial.gradient(qp.first, msh, cl)(1));
                errorH1 += qp.second * (pow(diff_val0, p) + pow(diff_val1, p));
            }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
        }
        errorH1 = pow(errorH1, 1.0 / p);
//std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
        return errorH1;
    }


    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T Linf_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
        T errorLinf = ((level_set_final.vertices - level_set_initial.vertices).cwiseAbs()).maxCoeff();
        return errorLinf;

    }

    template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
    T W1inf_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
        T errorLinf0 = 0, errorLinf1 = 0;

        for (auto &cl: msh.cells) {
            auto pts = points(msh, cl);
            for (auto &pt: pts) {
                auto diff_val0 = std::abs(
                        level_set_final.gradient(pt, msh, cl)(0) - level_set_initial.gradient(pt, msh, cl)(0));
                errorLinf0 = std::max(errorLinf0, diff_val0);
                auto diff_val1 = std::abs(
                        level_set_final.gradient(pt, msh, cl)(1) - level_set_initial.gradient(pt, msh, cl)(1));
                errorLinf1 = std::max(errorLinf1, diff_val1);
            }

        }
        return errorLinf0 + errorLinf1;

    }

}

using namespace random_functions;

namespace level_set_transport{



    template<typename Mesh, typename MeshData, typename T = typename Mesh::coordinate_type>
    void mesh_HHO_LS_correlation(Mesh &msh_HHO, Mesh &msh_LS, MeshData &mip_HHO, MeshData &mip_LS, size_t N_LS_sub) {
        size_t N_x_HHO = mip_HHO.Nx;
        size_t N_y_HHO = mip_HHO.Ny;
        const size_t N_tot_HHO = N_x_HHO * N_y_HHO;

        size_t N_x_LS = mip_LS.Nx;
        size_t N_y_LS = mip_LS.Ny;
        const size_t N_tot_LS = N_x_LS * N_y_LS;

        const size_t Nsub_cell = N_LS_sub * N_LS_sub;

//    std::array<std::array<size_t,Nsub_cell>,N_tot_LS> mapping_LS_HHO;
//    std::array<std::array<size_t,1>,N_tot_HHO> mapping_HHO_LS;

        Eigen::Matrix <size_t, Dynamic, Dynamic> mapping_LS_HHO = Eigen::Matrix<size_t, Dynamic, Dynamic>::Zero(N_tot_LS,
                                                                                                                Nsub_cell);

        Eigen::Matrix<size_t, Dynamic, 1> mapping_HHO_LS = Eigen::Matrix<size_t, Dynamic, 1>::Zero(N_tot_HHO, 1);


        size_t counter = 0;
        size_t i_gl = 0;
        for (size_t j = 0; j < N_y_LS; j++) {
            for (size_t i = 0; i < N_x_LS; i++) {
                size_t counter_loc = 0;
                for (size_t i_loc = i_gl; i_loc < i_gl + N_LS_sub; i_loc++) {
                    for (size_t j_loc = 0; j_loc < N_LS_sub; j_loc++) {
                        mapping_LS_HHO(counter, counter_loc) = i_loc + (N_LS_sub - 1) * N_y_HHO * j + j_loc * N_y_HHO;
                        mapping_HHO_LS(i_loc + (N_LS_sub - 1) * N_y_HHO * j + j_loc * N_y_HHO) = counter;
                        counter_loc++;
                    }


                }
                i_gl += N_LS_sub;
                counter++;
            }
        }

        std::cout << "mapping_LS_HHO" << '\n' << mapping_LS_HHO << '\n' << "mapping_HHO_LS" << '\n' << mapping_HHO_LS
                  << std::endl;

    }



    template<typename Mesh, typename T>
    class cell_basis_Lagrangian_ordered {
        typedef typename Mesh::coordinate_type coordinate_type;
        typedef typename Mesh::point_type point_type;

        point_type cell_bar;
        coordinate_type cell_h;
        size_t basis_degree, basis_size;
        std::vector <point<T, 2>> nodes;
        std::vector <size_t> row_indeces, col_indeces;

    public:
        cell_basis_Lagrangian_ordered(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);
// nodes           = equidistriduted_nodes_ordered<T,Mesh>(msh, cl, degree);
            nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            basis_degree = degree;
            basis_size = (basis_degree + 1) * (basis_degree + 1);
            set_col_row_indeces();

        }

        void set_col_row_indeces() {
//std::cout<<"SONO QUA NEL SET INDECES "<<row_indeces.size()<<" and "<<col_indeces.size()<<std::endl;
// It could be cool to just save once and not call each time. To do that or call the  variable Static(?) or give it just as external fx and initiliaze once.
            if (row_indeces.size() == 0 && col_indeces.size() == 0) {
                row_indeces.push_back(0);
                row_indeces.push_back(1);
                col_indeces.push_back(0);
                col_indeces.push_back(3);
                for (size_t i = 0; i < basis_degree - 1; i++) {
                    row_indeces.push_back(4 + i);
                    col_indeces.push_back(3 * basis_degree + 1);
                }

            }
        }


/*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

        Matrix<T, Dynamic, 1>
        eval_basis(const point_type &pt) {
            Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_degree + 1);
            Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_degree + 1);
            Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);


/*
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<row_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<col_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        */
// the indeces of first row and column are already saved. Just need a loop over them and then do the right tensor product maintaining the ordering of the nodes.
            size_t ct = 0;
            for (auto &k: row_indeces) {
                T bk = 1;
                for (auto &j: row_indeces) {
                    if (j != k) {
                        bk *= ((pt.x() - (nodes.at(j)).x()) / ((nodes.at(k)).x() - (nodes.at(j)).x()));
                    }
                }

                retx(ct) = bk;
                ct++;
            }

            ct = 0;
            for (auto &l: col_indeces) {
                T bl = 1;
                for (auto &j: col_indeces) {
                    if (j != l) {
                        bl *= ((pt.y() - (nodes.at(j)).y()) / ((nodes.at(l)).y() - (nodes.at(j)).y()));
                    }
                }
                rety(ct) = bl;
                ct++;
            }



// VERTICES FUNCTIONS:
            if (basis_degree == 0) {
                ret(0) = rety(0) * retx(0);
                return ret;
            }


            ret(0) = rety(0) * retx(0);
            ret(1) = rety(0) * retx(1);
            ret(2) = rety(1) * retx(1);
            ret(3) = rety(1) * retx(0);

            if (basis_degree == 1)
                return ret;

            int count0 = 4, count1 = 4 + basis_degree - 1, count2 = 4 + 2 * (basis_degree - 1), count3 =
                    4 + 3 * (basis_degree - 1);
            int count_bis0 = 4 * basis_degree; // counter initialisation (USELESS)
            int j_max = floor((basis_degree - 1) / 2); // number of internal layour of points
            int pos_right = 100; // initial point from the right from bottom -> up
            int pos_left = 100; // initial point from the left from left -> right

            for (int j = 0; j <= j_max; j++) { // for each layout of point
// bool i_loop = FALSE;
                for (int i = std::max(0, j - 1);
                     i < basis_degree - 1 - j; i++) // I move from left into the points over a side of each layout
                {
                    if (i == std::max(0, j - 1) && j > 0) // vertices
                    {
// different pos_left depending on the layout. Especially this rules the y starting point
                        if (j == 0)
                            pos_left = 0;
                        else if (j == 1)
                            pos_left = 2;
                        else
                            pos_left = 2 + (j - 1);

// Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                        count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
//std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                        ret(count_bis0) = (retx(2 + i) * rety(pos_left)); // adding point bottom layout
                        count_bis0++;
                        if (j == 0)
                            pos_right = 1;
                        else
                            pos_right = basis_degree + 1 - j;

                        ret(count_bis0) = (retx(pos_right) * rety(2 + i)); // adding point right layout in count_bis0 pos.
                        count_bis0++;

                        ret(count_bis0) = (retx(basis_degree - i) *
                                           rety(pos_right)); // adding point top layout in count_bis0 pos.

                        count_bis0++;

                        ret(count_bis0) = (retx(pos_left) * rety(basis_degree - i));

                        count_bis0++;

// Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                        count0 = count_bis0;
                        count1 = count0 + std::ceil((basis_degree - 2.0 * j) / 2.0); //  count0 + (degree - 2); it was
                        count2 = count1 + std::ceil((basis_degree - 2.0 * j) / 2.0);
                        count3 = count2 + std::ceil((basis_degree - 2.0 * j) / 2.0);

                    } else // NOT vertices -> node in the sides of each layout
                    {
//   std::cout<<"i "<<i<<" j "<<j<<std::endl;
// vertical position where starting for each bottom side layout.
                        if (j == 0)
                            pos_left = 0;
                        else if (j == 1)
                            pos_left = 2;
                        else
                            pos_left = 2 + (j - 1);

                        ret(count0) = (retx(2 + i) * rety(pos_left));
                        count0++;
// x-position where to start to increase to get points for each right side layout of points
                        if (j == 0)
                            pos_right = 1;
                        else
                            pos_right = basis_degree + 1 - j;

                        ret(count1) = (retx(pos_right) * rety(2 + i));
                        count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                        ret(count2) = (retx(basis_degree - i) * rety(pos_right));
                        count2++; // count2 just enumerate top faces' layout

                        ret(count3) = (retx(pos_left) * rety(basis_degree - i));
                        count3++; // count3 just enumerate left faces' layout


                    }
                }
// Updating for the next layout.
                count0 = count3;
                count1 = count0 + (basis_degree - 2 * (j + 1));
                count2 = count1 + (basis_degree - 2 * (j + 1));
                count3 = count2 + (basis_degree - 2 * (j + 1));

            }

/// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
            if (basis_degree % 2 == 0)
                ret(count0) = (retx(basis_degree - floor((basis_degree - 1) / 2)) *
                               rety(basis_degree - floor((basis_degree - 1) / 2)));

            return ret;


        }


        Matrix<T, Dynamic, 2>
        eval_gradients(const point_type &pt) {
// Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

            Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

            Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


// for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

            for (size_t l = 0; l < basis_size; l++) {
                size_t col = l % (basis_degree + 1);
                T bl = 1.0, bl_der = 1.0;
                T sumy = 0.0;
                for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                    T sumyy = 1.0;
                    if (tmpy != l) {

                        bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));

                        bl_der *= (1.0 / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                        for (size_t jy = col; jy <= col + (basis_degree + 1) * basis_degree; jy += (basis_degree + 1)) {
                            if (jy != tmpy && jy != l) {
                                sumyy *= (pt.y() - (nodes.at(jy)).y());
                            }
                        }
                        sumy += sumyy;
                    }
                }
                rety(l) = bl;
                sy(l) = bl_der * sumy;
            }

// For the x-derivative of b_k(x), same procedure of b_l(y)'

            for (size_t k = 0; k < basis_size; k++) {
                size_t row = floor(k / (basis_degree + 1));
                T bk = 1.0, bk_der = 1.0;
                T sumx = 0.0;
                for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                    T sumxx = 1.0;

                    if (tmpx != k) {

                        bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                        bk_der *= (1.0 / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                        for (size_t jx = (basis_degree + 1) * row; jx <= (basis_degree + 1) * (row + 1) - 1; jx++) {
                            if (jx != tmpx && jx != k) {
                                sumxx *= (pt.x() - (nodes.at(jx)).x());
                            }
                        }
                        sumx += sumxx;

                    }
                }
                retx(k) = bk;
                sx(k) = bk_der * sumx;
            }

            for (size_t i = 0; i < basis_size; i++) {
                ret(i, 0) = rety(i) * sx(i);
                ret(i, 1) = retx(i) * sy(i);

            }
            return ret;

        }

        size_t size() const {
            return basis_size;
        }

        size_t degree() const {
            return basis_degree;
        }

        static size_t size(size_t degree) {
            return (degree + 1) * (degree + 1);
        }
    };



    template<typename Mesh, typename VT>
    class cell_basis_Bernstein {
        typedef typename Mesh::coordinate_type coordinate_type;
        typedef typename Mesh::point_type point_type;

        point_type cell_bar;
        coordinate_type cell_h;
        size_t basis_degree, basis_size;
        coordinate_type min_x, max_x, min_y, max_y;
        coordinate_type scaling_x, scaling_y;

#ifdef POWER_CACHE
                std::vector<coordinate_type>
        power_cache,
        power_cache_bis;
        std::vector <size_t> binomial_coeff, binomial_coeff_bis;
#endif

    public:
        cell_basis_Bernstein(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
            basis_degree = degree;
            basis_size = (basis_degree + 1) * (basis_degree + 1);
            min_x = points(msh, cl)[0].x();
            max_x = points(msh, cl)[1].x();
            min_y = points(msh, cl)[0].y();
            max_y = points(msh, cl)[2].y();
            scaling_x = 1.0 / (pow((max_x - min_x), basis_degree));
            scaling_y = 1.0 / (pow((max_y - min_y), basis_degree));

        }

        Matrix<VT, Dynamic, 1>
        eval_basis(const point_type &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

// Creation of the exponential terms
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
//if(i == 0)
//   binomial_coeff[0] = 1.0 ;
//else if(i == basis_degree)
//    binomial_coeff[basis_degree+1] = 1.0 ;
// else

                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);


                power_cache[2 * i] = binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            }

#endif
            size_t pos = 0;

// Case degree FEM = 0
            if (basis_degree == 0) {
                VT one = 1.0;
                ret(pos++) = one;
            }
// Case degree FEM = 1 -> i.e. just vertices
// Cell ordering:
// 3 -- 2
// 0 -- 1

            else if (basis_degree == 1) {
                for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                    if (pow_y == 0) // ordering from sx to dx 0->1
                    {
                        for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef POWER_CACHE
    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                      coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                            ret(pos++) = bv;
                        }
                    } else { // ordering from dx to sx 2->3
                        for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                      coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                            ret(pos++) = bv;
                        }
                    }
                }
            } else {
// case degree FEM >= 2
                int N = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree +
                                     1; // counting the number of layout of internal nodes: initially there are basis_degree +1 nodes

                while (internal_bases > 1) // if there is a deeper layout of nodes
                {
// Vertices nodes of a quadrangular cell. For each loop of internal_bases I add the vertice of "inner quadrangualar nodes" ( it's not properly true speaking of nodes, being a modal approach; better say the picks of the shape functions).
                    for (int pow_y = starter; pow_y <= N; pow_y += (N - starter)) {

                        if (pow_y == starter) // if bottom line -> from sx to dx
                        {
// if not external layout of nodes ( vertices level ) -> I don't take extremes since internal layout has 2 nodes less.
                            for (int pow_x = starter; pow_x <= N; pow_x += (N - starter)) {
#ifdef POWER_CACHE
                                auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;

                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                          coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                                ret(pos++) = bv;
// std::cout<<"pos vertices bottom is "<<pos<<std::endl;
                            }
                        } else { // if top line -> from dx to sx
                            for (int pow_x = N; pow_x >= starter; pow_x -= (N - starter)) {
#ifdef POWER_CACHE
                                auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;

                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                          coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                                ret(pos++) = bv;
// std::cout<<"pos vertices upper is "<<pos<<std::endl;
                            }

                        }

                    }


// After the vertices elements, step by faces bases.

//size_t pos = 4;
// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N - 1; pow_x++) {
                        size_t pow_y = starter;
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv =
                                scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                                iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
//  std::cout<<"pos face 0 is "<<pos<<std::endl;
                    }

// face 1 (RIGHT)
                    for (size_t pow_y = starter + 1; pow_y <= N - 1; pow_y++) {
                        size_t pow_x = N;
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv =
                                scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                                iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
//   std::cout<<"pos face 1 is "<<pos<<std::endl;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N;
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv =
                                scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                                iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
//   std::cout<<"pos face 2 is "<<pos<<std::endl;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv =
                                scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                                iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
//   std::cout<<"pos face 3 is "<<pos<<std::endl;
                    }

                    N--; // for each layout of "nodes", I have un unknown less from right
                    starter++; // for each layout of "nodes", I have un unknown less from left
                    internal_bases -= 2; // each layout I have 2 nodes less than the previous

                }
// for B_k, with k even, odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//   std::cout<<"N is "<<N<< " and starter is "<<starter<<std::endl;
                    assert(N == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;
#ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                              iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                    ret(pos++) = bv;
//  std::cout<<"pos %2 is "<<pos<<std::endl;
                }
            }
// std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;
        }

// Same approach of eval
        Matrix<VT, Dynamic, 2>
        eval_gradients(const point_type &pt) {
            Matrix<VT, Dynamic, 2> ret = Matrix<VT, Dynamic, 2>::Zero(basis_size, 2);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
            auto N = basis_degree - 1;
            auto coeff_dx = basis_degree / (max_x - min_x); // n/(b-a)
            auto coeff_dy = basis_degree / (max_y - min_y);
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (power_cache_bis.size() != (N + 1) * 2)
                power_cache_bis.resize((N + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

            if (binomial_coeff_bis.size() != (N + 1))
                binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
                power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

                if (i < basis_degree) {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                    power_cache_bis[2 * i] =
                            scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                    power_cache_bis[2 * i + 1] =
                            scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

                }

            }
#endif

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0) {
                VT zero = 0.0;
                ret(pos, 0) = zero;
                ret(pos, 1) = zero;
                pos++;
            }
// Case FEM degree = 1
            else if (basis_degree == 1) {
                VT coeffx = 1.0 / (max_x - min_x);
                VT coeffy = 1.0 / (max_y - min_y);
//std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
                auto px = 0.0, py = 0.0;
                int j = 1; // useful for the sign of the derivative in y
// Pick just vertices
                for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                    if (pow_y == 0) // bottom
                    {
                        int i = 1;  // useful for the sign of the derivative in x
                        for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif


                            ret(pos, 0) = py * coeffx * pow(-1, i);
                            ret(pos, 1) = px * coeffy * pow(-1, j);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                            pos++;
                            i++;
                        }

                    } else {
                        int i = 2;
                        for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
                            px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif

                            ret(pos, 0) = py * coeffx * pow(-1, i);
                            ret(pos, 1) = px * coeffy * pow(-1, j);
//  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                            pos++;
                            i--;
                        }
                    }
                    j++;
                }

            } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree + 1;

                while (internal_bases > 1) // for each layour of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                        if (pow_y == starter) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative

#ifdef POWER_CACHE
                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                                else
                                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                                if (pow_y == 0)
                                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                                else
                                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos, 0) = dx * py;
                                ret(pos, 1) = px * dy;
                                pos++;


                            }
                        } else { // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {
                                VT ix_bis = pow_x - 1;
                                VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
                                if (pow_x == 0)
                                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                                else
                                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                                if (pow_y == 0)
                                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                                else
                                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;

                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif

                                ret(pos, 0) = dx * py;
                                ret(pos, 1) = px * dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                        size_t pow_y = starter;

                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"j_x Face0 "<<j_x<<std::endl;
//std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
//std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
//std::cout<<"bx0 Face0 "<<bx0<<std::endl;
//std::cout<<"bx1 Face0 "<<bx1<<std::endl;


// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }

#endif

                        ret(pos, 0) = dx * py;
                        ret(pos, 1) = px * dy;
                        pos++;

                    }

// face 1 (RIGHT)
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos, 0) = dx * py;
                        ret(pos, 1) = px * dy;
                        pos++;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos, 0) = dx * py;
                        ret(pos, 1) = px * dy;
                        pos++;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos, 0) = dx * py;
                        ret(pos, 1) = px * dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert(N_partial == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos, 0) = dx * py;
                    ret(pos, 1) = px * dy;
                    pos++;
                }
            }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }


// Same approach of eval
        Matrix<VT, Dynamic, 1>
        eval_derivative_xy(const point_type &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
            auto N = basis_degree - 1;
            auto coeff_dx = basis_degree / (max_x - min_x); // n/(b-a)
            auto coeff_dy = basis_degree / (max_y - min_y);
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (power_cache_bis.size() != (N + 1) * 2)
                power_cache_bis.resize((N + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

            if (binomial_coeff_bis.size() != (N + 1))
                binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
                power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

                if (i < basis_degree) {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                    power_cache_bis[2 * i] =
                            scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                    power_cache_bis[2 * i + 1] =
                            scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

                }

            }
#endif

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0) {
                VT zero = 0.0;
                ret(pos) = zero;

                pos++;
            }
// Case FEM degree = 1
            else if (basis_degree == 1) {
                VT coeffx = 1.0 / (max_x - min_x);
                VT coeffy = 1.0 / (max_y - min_y);
//std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
                auto px = 0.0, py = 0.0;
                int j = 1; // useful for the sign of the derivative in y
// Pick just vertices
                for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                    if (pow_y == 0) // bottom
                    {
                        int i = 1;  // useful for the sign of the derivative in x
                        for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif


                            ret(pos) = coeffy * pow(-1, j) * coeffx * pow(-1, i);
//ret(pos,1) = px * coeffy * pow(-1,j);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                            pos++;
                            i++;
                        }

                    } else {
                        int i = 2;
                        for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
                            px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif

                            ret(pos) = coeffy * pow(-1, j) * coeffx * pow(-1, i);

//  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                            pos++;
                            i--;
                        }
                    }
                    j++;
                }

            } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree + 1;

                while (internal_bases > 1) // for each layour of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                        if (pow_y == starter) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative

#ifdef POWER_CACHE
                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                                else
                                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                                if (pow_y == 0)
                                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                                else
                                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                                pos++;


                            }
                        } else { // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {
                                VT ix_bis = pow_x - 1;
                                VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
                                if (pow_x == 0)
                                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                                else
                                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                                if (pow_y == 0)
                                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                                else
                                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif

                                ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                        size_t pow_y = starter;

                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"j_x Face0 "<<j_x<<std::endl;
//std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
//std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
//std::cout<<"bx0 Face0 "<<bx0<<std::endl;
//std::cout<<"bx1 Face0 "<<bx1<<std::endl;


// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }

#endif

                        ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                        pos++;

                    }

// face 1 (RIGHT)
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                        pos++;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                        pos++;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x - 1;
                        VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
                        if (pow_x == 0)
                            auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                        else
                            auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                        if (pow_y == 0)
                            auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                        else
                            auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


#endif

                        ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert(N_partial == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                    pos++;
                }
            }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }


// Same approach of eval
        Matrix<VT, Dynamic, 1>
        eval_divergence(const point_type &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
            size_t N;
            if (basis_degree > 1)
                N = basis_degree - 2;
            else
                return ret;
            auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
            auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (power_cache_bis.size() != (N + 1) * 2)
                power_cache_bis.resize((N + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

            if (binomial_coeff_bis.size() != (N + 1))
                binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
                power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

                if (i < basis_degree - 1) {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                    power_cache_bis[2 * i] =
                            scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                    power_cache_bis[2 * i + 1] =
                            scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

                }

            }
#endif

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0 || basis_degree == 1) {
                VT zero = 0.0;
                while (pos < basis_size) {
                    ret(pos) = zero;
                    pos++;
                }
            } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree + 1;

                while (internal_bases > 1) // for each layout of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                        if (pow_y == starter) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE
                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);

                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx * py + px * dy;
                                pos++;


                            }
                        } else { // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);


                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }


                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx * py + px * dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                        size_t pow_y = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py + px * dy;
                        pos++;


                    }

// face 1 (RIGHT) size_t pow_x = N_partial;
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative

                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py + px * dy;
                        pos++;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py + px * dy;
                        pos++;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py + px * dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert(N_partial == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;

                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);

                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py + px * dy;
                    pos++;


                }
            }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }

// Same approach of eval
        Matrix<VT, Dynamic, 1>
        eval_double_derivative_x(const point_type &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
            size_t N;
            if (basis_degree > 1)
                N = basis_degree - 2;
            else
                return ret;

            auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
            auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (power_cache_bis.size() != (N + 1) * 2)
                power_cache_bis.resize((N + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

            if (binomial_coeff_bis.size() != (N + 1))
                binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
                power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

                if (i < basis_degree - 1) {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                    power_cache_bis[2 * i] =
                            scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                    power_cache_bis[2 * i + 1] =
                            scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

                }

            }
#endif

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0 || basis_degree == 1) {
                VT zero = 0.0;
                while (pos < basis_size) {
                    ret(pos) = zero;
                    pos++;
                }
            } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree + 1;

                while (internal_bases > 1) // for each layout of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                        if (pow_y == starter) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE
                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);

                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx * py; //+ px*dy;
                                pos++;


                            }
                        } else { // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);


                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }


                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx * py; // + px*dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                        size_t pow_y = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py; // + px*dy;
                        pos++;


                    }

// face 1 (RIGHT) size_t pow_x = N_partial;
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative

                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py; // + px*dy;
                        pos++;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py; // + px*dy;
                        pos++;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx * py; // + px*dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert(N_partial == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;

                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);

                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py; // + px*dy;
                    pos++;


                }
            }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }

// Same approach of eval
        Matrix<VT, Dynamic, 1>
        eval_double_derivative_y(const point_type &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            auto bx0 = pt.x() - min_x;
            auto bx1 = max_x - pt.x();
            auto by0 = pt.y() - min_y;
            auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
            size_t N;
            if (basis_degree > 1)
                N = basis_degree - 2;
            else
                return ret;
            auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
            auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
            if (power_cache.size() != (basis_degree + 1) * 2)
                power_cache.resize((basis_degree + 1) * 2);

            if (power_cache_bis.size() != (N + 1) * 2)
                power_cache_bis.resize((N + 1) * 2);

            if (binomial_coeff.size() != (basis_degree + 1))
                binomial_coeff.resize(basis_degree + 1);

            if (binomial_coeff_bis.size() != (N + 1))
                binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
            for (size_t i = 0; i <= basis_degree; i++) {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
                power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
                power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

                if (i < basis_degree - 1) {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                    power_cache_bis[2 * i] =
                            scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                    power_cache_bis[2 * i + 1] =
                            scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

                }

            }
#endif

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0 || basis_degree == 1) {
                VT zero = 0.0;
                while (pos < basis_size) {
                    ret(pos) = zero;
                    pos++;
                }
            } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;
                int internal_bases = basis_degree + 1;

                while (internal_bases > 1) // for each layout of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                        if (pow_y == starter) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE
                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);

                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = px * dy;
                                pos++;


                            }
                        } else { // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                                VT ix_bis = pow_x - 1; // element i-1 for derivative
                                VT iy_bis = pow_y - 1; // element i-1 for derivative
                                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                                auto px = power_cache[2 * pow_x];
                                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if (pow_x == 0)
                                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                                else if (pow_x == basis_degree)
                                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                                else if (pow_x == 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                                else if (pow_x == basis_degree - 1)
                                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                                else
                                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                           power_cache_bis[2 * ix2_bis]);


                                if (pow_y == 0)
                                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                                else if (pow_y == basis_degree)
                                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                                else if (pow_y == 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else if (pow_y == basis_degree - 1)
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                                else
                                    auto dy = coeff_d2y *
                                              (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                VT dx = 0.0, dy = 0.0;

                                if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - ix_bis;
                                    size_t j_x_bis1 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_x_bis0 = N - pow_x;
                                    size_t j_x_bis1 = N - ix_bis;
                                    size_t j_x_bis2 = N - ix2_bis;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                    auto px_bis0 =
                                            scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                                   iexp_pow(bx1, j_x_bis1);
                                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                                   iexp_pow(bx1, j_x_bis2);


                                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }


                                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_y_bis0 = N - iy_bis;
                                    size_t j_y_bis1 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                } else {
                                    size_t j_y_bis0 = N - pow_y;
                                    size_t j_y_bis1 = N - iy_bis;
                                    size_t j_y_bis2 = N - iy2_bis;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                    auto py_bis0 =
                                            scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                                   iexp_pow(by1, j_y_bis1);
                                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                                   iexp_pow(by1, j_y_bis2);


                                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                                ret(pos) = px * dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


// face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                        size_t pow_y = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;

                        if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = px * dy;
                        pos++;


                    }

// face 1 (RIGHT) size_t pow_x = N_partial;
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative

                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = px * dy;
                        pos++;
                    }

// face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE

                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = px * dy;
                        pos++;
                    }


// face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x - 1; // element i-1 for derivative
                        VT iy_bis = pow_y - 1; // element i-1 for derivative
                        VT ix2_bis = pow_x - 2; // element i-2 for derivative
                        VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                        std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                        auto px = power_cache[2 * pow_x];
                        auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                        if (pow_x == 0)
                            auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                        else if (pow_x == basis_degree)
                            auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                        else if (pow_x == 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                        else if (pow_x == basis_degree - 1)
                            auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                        else
                            auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                   power_cache_bis[2 * ix2_bis]);


                        if (pow_y == 0)
                            auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                        else if (pow_y == basis_degree)
                            auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                        else if (pow_y == 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else if (pow_y == basis_degree - 1)
                            auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                        else
                            auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                                   power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0, dy = 0.0;


                        if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 =
                                    scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        } else {
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 =
                                    scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 =
                                    scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        } else {
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 =
                                    scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                        }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                        ret(pos) = px * dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
                if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert(N_partial == starter);
                    size_t pow_x = starter;
                    size_t pow_y = starter;

                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);

                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = px * dy;
                    pos++;


                }
            }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }

        size_t size() const {
            return basis_size;
        }

        size_t degree() const {
            return basis_degree;
        }

        static size_t size(size_t degree) {
            return (degree + 1) * (degree + 1);
        }
    };


    template<typename Mesh, typename VT>
    class cell_basis_Bernstein_1d_reference {
        typedef typename Mesh::coordinate_type coordinate_type;
        typedef typename Mesh::point_type point_type;
        typedef typename Mesh::cell_type cell_type;

//point_type          cell_bar;
//coordinate_type     cell_h;
        size_t basis_degree, basis_size;
        coordinate_type min_x, max_x, min_y, max_y;
        coordinate_type scaling_x;
        std::vector <point<VT, 2>> physical_pts;
        cell_type m_cl;
        Mesh msh_orig;
        Mesh msh_agglo;

    public:
        cell_basis_Bernstein_1d_reference(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
            basis_degree = degree;
            basis_size = (basis_degree + 1);
            auto ref_nodes = reference_nodes_ordered<VT>(degree);
            physical_pts = cl.user_data.interface;

            min_x = 0.0; // points(msh,cl)[0].x();
            max_x = 1.0; //points(msh,cl)[1].x();
            scaling_x = 1.0 / (pow((max_x - min_x), basis_degree));

            m_cl = cl;

        }


        Matrix<VT, Dynamic, 1>
        eval_basis_1d(const VT &pt) {

            size_t pos = 0;
            auto bx0 = pt - min_x;
            auto bx1 = max_x - pt;

            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);
            if (basis_degree == 0) { // Case degree FEM = 0
                VT one = 1.0;
                ret(pos++) = one;

            } else if (basis_degree == 1) {
                for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
                    size_t j_x = basis_degree - pow_x;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);

                    ret(pos++) = bv;


                }
            } else {
                int N = basis_degree;
                int starter = 0;
                for (int pow_x = starter; pow_x <= N; pow_x += (N - starter)) {

                    size_t j_x = basis_degree - pow_x;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);

                    ret(pos++) = bv;
// std::cout<<"pos vertices bottom is "<<pos<<std::endl;
                }

// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N - 1; pow_x++) {

                    size_t j_x = basis_degree - pow_x;


                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    ret(pos++) = bv;
//  std::cout<<"pos face 0 is "<<pos<<std::endl;
                }
            }
// std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;
        }

        Matrix<VT, 2, 1>
        eval_basis_curv(const VT &pt, int r = 0) {
            Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
            auto basis = eval_basis_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = size_pts / basis_size;


            if (size_cls == 1) {

                ret(0) += basis(0) * physical_pts[0].x();
                ret(0) += basis(1) * physical_pts[basis_degree].x();
                ret(1) += basis(0) * physical_pts[0].y();
                ret(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1].x();
                    ret(1) += basis(i) * physical_pts[i - 1].y();
                }
                return ret;
            } else {
                ret(0) += basis(0) * physical_pts[0 + r * basis_size].x();
                ret(0) += basis(1) * physical_pts[basis_degree + r * basis_size].x();
                ret(1) += basis(0) * physical_pts[0 + r * basis_size].y();
                ret(1) += basis(1) * physical_pts[basis_degree + r * basis_size].y();

                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1 + r * basis_size].x();
                    ret(1) += basis(i) * physical_pts[i - 1 + r * basis_size].y();
                }

                return ret;
            }



//ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
//ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
//return ret ;

        }


// ANCORA DA DEFINIRE
        Matrix<VT, Dynamic, 1>
        eval_gradients_1d(const VT &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);
            auto bx0 = pt - min_x;
            auto bx1 = max_x - pt;
            auto N = basis_degree - 1;

            auto coeff_dx = basis_degree / (max_x - min_x);
            auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
//std::cout<<"check = "<< 1.0 - 1.0/(pow(max_x - min_x,N) ) <<std::endl;

            size_t pos = 0;
// Case FEM degree = 0
            if (basis_degree == 0) {
                VT zero = 0.0;
                ret(pos) = zero;
                pos++;
            }
// Case FEM degree = 1
            else if (basis_degree == 1) {// Pick just vertices
                int i = 1;  // useful for the sign of the derivative in x
                VT coeffx = 1.0 / (max_x - min_x);


                for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
                    ret(pos) = coeffx * pow(-1, i);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                    pos++;
                    i++;
                }

            } else {   // if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree;
                int starter = 0;

                for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {
                    VT ix_bis = pow_x - 1; // element i-1 for derivative

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);

                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }
                    ret(pos) = dx;
                    pos++;
                }

// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {

                    VT ix_bis = pow_x - 1;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    ret(pos, 0) = dx;
                    pos++;

                }


            }


//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


        }


        Matrix<VT, 2, 1>
        eval_gradients_curv(const VT &pt, int r = 0) {
            Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
            auto basis = eval_gradients_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = size_pts / basis_size;


            if (size_cls == 1) {

                ret(0) += basis(0) * physical_pts[0].x();
                ret(0) += basis(1) * physical_pts[basis_degree].x();
                ret(1) += basis(0) * physical_pts[0].y();
                ret(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1].x();
                    ret(1) += basis(i) * physical_pts[i - 1].y();
                }
                return ret;
            } else {
                ret(0) += basis(0) * physical_pts[0 + r * basis_size].x();
                ret(0) += basis(1) * physical_pts[basis_degree + r * basis_size].x();
                ret(1) += basis(0) * physical_pts[0 + r * basis_size].y();
                ret(1) += basis(1) * physical_pts[basis_degree + r * basis_size].y();

                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1 + r * basis_size].x();
                    ret(1) += basis(i) * physical_pts[i - 1 + r * basis_size].y();
                }

                return ret;
            }



//ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
//ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
//return ret ;

        }


        size_t size() const {
            return basis_size;
        }

        size_t degree() const {
            return basis_degree;
        }

        static size_t size(size_t degree) {
            return (degree + 1);
        }
    };


    template<typename Mesh, typename VT>
    class cell_basis_Lagrange_1d_reference {
        typedef typename Mesh::coordinate_type coordinate_type;
        typedef typename Mesh::point_type point_type;
        typedef typename Mesh::cell_type cell_type;

//point_type          cell_bar;
//coordinate_type     cell_h;
        size_t basis_degree, basis_size;
        coordinate_type min_x, max_x, min_y, max_y;
        coordinate_type scaling_x;
        std::vector <point<VT, 2>> physical_pts;
        std::vector <point<VT, 1>> ref_nodes;
        cell_type m_cl;
        Mesh msh_orig;
        Mesh msh_agglo;

    public:
        cell_basis_Lagrange_1d_reference(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
            basis_degree = degree;
            basis_size = (basis_degree + 1);

            ref_nodes = reference_nodes_ordered_01<VT>(degree); //[0,1]
//ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
            physical_pts = cl.user_data.interface;

//min_x = 0.0 ; // points(msh,cl)[0].x();
//max_x = 1.0 ; //points(msh,cl)[1].x();
//scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );

            m_cl = cl;

        }

        cell_basis_Lagrange_1d_reference(size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
            basis_degree = degree;
            basis_size = (basis_degree + 1);

            ref_nodes = reference_nodes_ordered_01<VT>(degree); //[0,1]
//ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
//physical_pts = cl.user_data.interface ;

//min_x = 0.0 ; // points(msh,cl)[0].x();
//max_x = 1.0 ; //points(msh,cl)[1].x();
//scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );

//m_cl = cl ;

        }


        Matrix<VT, Dynamic, 1>
        eval_basis_1d(const VT &pt) {

            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);


            for (size_t k = 0; k < basis_size; k++) {
                VT bk = 1;
                for (size_t j = 0; j < basis_size; j++) {
                    if (j != k) {
                        bk *= ((pt - ref_nodes.at(j).x()) / (ref_nodes.at(k).x() - ref_nodes.at(j).x()));
//std::cout<<"ref_nodes.at(j).x() = " << ref_nodes.at(j).x() << " , ref_nodes.at(k).x() = "<<ref_nodes.at(k).x()<<std::endl;
                    }
                }

                ret(k) = bk;

            }


            return ret;
        }

/*
    Matrix<VT, 2, 1>
    eval_basis_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_basis_1d(pt) ;

        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;


        if (size_cls == 1){

            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();

            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }

        return ret;
        }



        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
    */

// ANCORA DA DEFINIRE
        Matrix<VT, Dynamic, 1>
        eval_gradients_1d(const VT &pt) {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);


            for (size_t k = 0; k < basis_size; k++) {
                VT bk_der = 1.0;
                VT sumx = 0.0;
                for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                    VT sumxx = 1.0;

                    if (tmpx != k) {


                        bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                        for (size_t jx = 0; jx < basis_size; jx++) {
                            if (jx != tmpx && jx != k) {
                                sumxx *= (pt - ref_nodes.at(jx).x());
                            }
                        }
                        sumx += sumxx;

                    }
                }

                ret(k) = bk_der * sumx;
            }


            return ret;


        }


        Matrix<VT, Dynamic, 1>
        eval_double_derivative_1d(const VT &pt) {

            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            if (basis_degree == 0)
                exit(9);
            if (basis_degree == 1)
                return ret;
            if (basis_degree == 2) {
                for (size_t k = 0; k < basis_size; k++) {
                    VT bk_der = 1.0;
                    for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                        if (tmpx != k)
                            bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));

                    }

                    ret(k) = bk_der * 2.0;
                }

                return ret;
            }
            if (basis_degree == 3) {
                for (size_t k = 0; k < basis_size; k++) {
                    VT bk_der = 1.0;
                    VT b_tot = 0.0;
                    for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                        VT b = 1.0;

                        if (tmpx != k) {


                            bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                            size_t jx = tmpx;
                            bool inserted = false;
                            while (!inserted) {
                                if (jx != k) {
                                    b *= (pt - ref_nodes.at(jx).x());
                                    inserted = true;
                                }

                                jx++;

                            }
                            b_tot += 2.0 * b;

                        }

                    }

                    ret(k) = bk_der * b_tot;

                }
                return ret;
            }


            if (basis_degree ==
                4) { // In the generic case it doesn't work since amount is fine for just (x-xj)*(x-xl), with l>j, but iif I have more than two terms it need somehting more general

                for (size_t k = 0; k < basis_size; k++) // basis k
                {
                    VT bk_der = 1.0;
                    VT b_tot = 0.0;
                    size_t pos = 0; // iter
                    for (size_t amount = 0; amount < basis_degree - 1; amount++) {
                        if (pos == k)
                            pos++;

                        size_t jx = pos;
// starting from amount k = 0  num counts how many terms have (x-x1)*(), how many(x-x2)*() etc --> pos defines the term
// For k generic, it always starts from pos=0(at least that k=0) and just skip pos=k
                        for (size_t num = basis_degree - 1 - amount; num > 0; num--) {
                            VT b = (pt - ref_nodes.at(pos).x());
                            size_t m = 0;

                            while (m != basis_degree - 3) {
                                if (jx != k && jx != pos) {
                                    b *= (pt - ref_nodes.at(jx).x());
                                    m++;
                                }

                                jx++;
                            }
                            b_tot += 2.0 * b;
                        }
                        pos++;
                    }

                    for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                        if (tmpx != k)
                            bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                    }


                    ret(k) = bk_der * b_tot;

                }

                return ret;
            }
        }


/*
       Matrix<VT, 2, 1>
    eval_gradients_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_gradients_1d(pt) ;

        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;


        if (size_cls == 1){

            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();

            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }

            return ret;
        }



        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
     */

        size_t size() const {
            return basis_size;
        }

        size_t degree() const {
            return basis_degree;
        }

        static size_t size(size_t degree) {
            return (degree + 1);
        }
    };


    template<typename Mesh, typename T>
    class cell_basis_Lagrangian {
        typedef typename Mesh::coordinate_type coordinate_type;
        typedef typename Mesh::point_type point_type;

        point_type cell_bar;
        coordinate_type cell_h;
        size_t basis_degree, basis_size;
        std::vector <point<T, 2>> nodes;
//std::vector<size_t>         indeces;

    public:
        cell_basis_Lagrangian(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
            nodes = equidistriduted_nodes<T, Mesh>(msh, cl, degree);
//nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);

            basis_degree = degree;
            basis_size = (basis_degree + 1) * (basis_degree + 1);
        }

/*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

        Matrix<T, Dynamic, 1>
        eval_basis(const point_type &pt) {
            Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);

// Per la y, trovo la colonna facendo col = l%(degree+1)
// scorro su tutta la colonna tmpy = [col:(degree+1): col+(degree+1)*degree]
// faccio base bl moltiplicando tutti tranne quando tmpy = l
            for (size_t l = 0; l < basis_size; l++) {
                size_t col = l % (basis_degree + 1);
                T bl = 1.0;
                for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                    if (tmpy != l) {
                        bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                    }
                }
                rety(l) = bl;
            }

// Per la x, trovo la riga facendo riga = floor(k/(degree+1))
//scorro su tutta la riga tmpx = [(degree+1)*riga: (degree+1)*(riga+1)-1]
// faccio base bk moltiplicando tutti tranne quando tmpx = k

            for (size_t k = 0; k < basis_size; k++) {
                T bk = 1.0;
                size_t row = floor(k / (basis_degree + 1));
                for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                    if (tmpx != k) {
                        bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                    }
                }
                retx(k) = bk;
            }

            for (size_t i = 0; i < basis_size; i++) {
                ret(i) = rety(i) * retx(i);
            }
            return ret;

        }

        Matrix<T, Dynamic, 2>
        eval_gradients(const point_type &pt) {
// Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

            Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

            Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
            Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


// for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

            for (size_t l = 0; l < basis_size; l++) {
                size_t col = l % (basis_degree + 1);
                T bl = 1.0, bl_der = 1.0;
                T sumy = 0.0;
                for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                    T sumyy = 1.0;
                    if (tmpy != l) {

                        bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));

                        bl_der *= (1.0 / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                        for (size_t jy = col; jy <= col + (basis_degree + 1) * basis_degree; jy += (basis_degree + 1)) {
                            if (jy != tmpy && jy != l) {
                                sumyy *= (pt.y() - (nodes.at(jy)).y());
                            }
                        }
                        sumy += sumyy;
                    }
                }
                rety(l) = bl;
                sy(l) = bl_der * sumy;
            }

// For the x-derivative of b_k(x), same procedure of b_l(y)'

            for (size_t k = 0; k < basis_size; k++) {
                size_t row = floor(k / (basis_degree + 1));
                T bk = 1.0, bk_der = 1.0;
                T sumx = 0.0;
                for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                    T sumxx = 1.0;

                    if (tmpx != k) {

                        bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                        bk_der *= (1.0 / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                        for (size_t jx = (basis_degree + 1) * row; jx <= (basis_degree + 1) * (row + 1) - 1; jx++) {
                            if (jx != tmpx && jx != k) {
                                sumxx *= (pt.x() - (nodes.at(jx)).x());
                            }
                        }
                        sumx += sumxx;

                    }
                }
                retx(k) = bk;
                sx(k) = bk_der * sumx;
            }

            for (size_t i = 0; i < basis_size; i++) {
                ret(i, 0) = rety(i) * sx(i);
                ret(i, 1) = retx(i) * sy(i);

            }
            return ret;

        }

        size_t size() const {
            return basis_size;
        }

        size_t degree() const {
            return basis_degree;
        }

        static size_t size(size_t degree) {
            return (degree + 1) * (degree + 1);
        }
    };





    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    Matrix<T, Dynamic, 1>
    make_bernstein_local_mass_matrix_lumped(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree,
                                            size_t di = 2) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

        auto qps = integrate(msh, cl, (degree) + 2); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
            ret += qp.second * phi;
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
        }

/*
    Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps2 = integrate(msh, cl, (degree)+2); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi ;
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }

    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<'\n'<<ret-ret2<<'\n'<<std::endl;
    std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<std::endl;


    //ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3
    */
        return ret;
    }


    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    Matrix <T, Dynamic, Dynamic>
    make_bernstein_local_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
            ret += qp.second * phi * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
        }
//ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

// CHECK INTEGRATION
/*
    auto qps2 = integrate(msh, cl, 2*(degree)); // integration of order 2k
    Matrix<T, Dynamic, Dynamic> ret2 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi * phi.transpose();
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<'\n'<<ret-ret2<<'\n'<<std::endl;
     std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<std::endl;
    */
        return ret;
    }


    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
    make_lagrangian_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {
        cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
        Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
            std::cout << "phi " << '\n' << phi << std::endl;
            auto phi_grad = cb.eval_gradients(qp.first);
            std::cout << "phi_grad " << '\n' << phi_grad << std::endl;
            ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

            ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
        }


        return std::make_pair(ret0, ret1);
    }

    template<typename Mesh, typename Velocity, typename T = typename Mesh::coordinate_type>
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
    make_bernstein_local_cij_matrix_with_velocity(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree,
                                                  Velocity &u, size_t di = 1) {
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
        Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
//std::cout<< "phi "<<'\n'<<phi<<std::endl;
            auto phi_grad = cb.eval_gradients(qp.first);
            auto u_val = u(qp.first, msh, cl);
//std::cout<< "phi_grad "<<'\n'<<phi_grad<<std::endl;
            ret0 += qp.second * u_val.first * phi * ((phi_grad).col(0)).transpose();

            ret1 += qp.second * u_val.second * phi * ((phi_grad).col(1)).transpose();
        }


        return std::make_pair(ret0, ret1);
    }

    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
    make_bernstein_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
        Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);

            auto phi_grad = cb.eval_gradients(qp.first);

            ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

            ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
        }

/*
    // CHECKING ORDER INTEGRATION
    Matrix<T, Dynamic, Dynamic> ret1_bis = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps2 = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret1_bis += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    std::cout<<"THE CHECKING FOR CIJ ORDER IS "<<'\n'<<ret1 - ret1_bis<<std::endl;
    */
        return std::make_pair(ret0, ret1);
    }

    template<typename Mesh, typename T = typename Mesh::coordinate_type, typename Fonction>
    std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>>
    make_bernstein_local_RHS_VEC(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, const Fonction &f,
                                 size_t di = 0) {

        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> ret = std::make_pair(Matrix<T, Dynamic, 1>::Zero(cbs, 1),
                                                                                      Matrix<T, Dynamic, 1>::Zero(cbs, 1));

        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto b = cb.eval_basis(qp.first);
            auto value0 = f(qp.first, msh, cl).first;
            auto value1 = f(qp.first, msh, cl).second;
            ret.first += qp.second * value0 * b;
            ret.second += qp.second * value1 * b;
        }

        return ret;
    }


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein_high_order_interpolation :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
        std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

        SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
        SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
        SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

        Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

        SparseMatrix <T> cij_norm, nij0, nij1;
        SparseMatrix <T> cji_norm, nji0, nji1;


        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

        Level_set_berstein_high_order_interpolation(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                                    bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check) {
            if (!analytic_check) {
                timecounter tc_level_set;
                tc_level_set.tic();
                Matrix<T, Dynamic, 1> RHS;    // Known term
                std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation


                last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
                last_row_end = last_row_init + Nx - 1;
                number_faces_one_row = 2 * Nx +
                                       1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

                Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

                Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

                Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


                cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
                vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


// std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                    }


                    auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                    auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                    auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                    for (size_t i = 0; i < local_dim; i++) {
                        size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                        for (size_t j = 0; j < local_dim; j++) {
/*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                            size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                            triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                            triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                            triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                        }
                        Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                        RHS_vandermonde(i) = level_set(qps[i]);
                    }


                    auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                    sol_HHO.col(cell_offset) = sol_tmp;
                    for (size_t i = 0; i < local_dim; i++) {

                        size_t asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                    }
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


                } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
                Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
                triplets.clear();


// Finalisation global assembling
                Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
                triplets_c_term_x.clear();
                Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
                triplets_c_term_y.clear();

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

                cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                            Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
                nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
                nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
                SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
                SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
                cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
                nji0 = cji_x.cwiseQuotient(cji_norm);
                nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

//std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
//std::cout<<"local_dim size "<<local_dim<<std::endl;
//std::cout<<"n_cls "<<n_cls<<std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum

                timecounter tcbis;

// tcbis.tic();
                set_max_min();
// tcbis.toc();
//std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

                tc_level_set.toc();
                std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds"
                          << std::endl;

            } else {
                timecounter tc_level_set;
                tc_level_set.tic();

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

//std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
                    }



// Assembling triplets for global problem
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                        RHS_vandermonde(i) = level_set(qps[i]);


                    auto sol_tmp = cod.solve(RHS_vandermonde);
                    sol_HHO.col(cell_offset) = sol_tmp;
                    for (size_t i = 0; i < local_dim; i++) {
                        size_t asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_HHO(i, cell_offset);
                    }


                } // end of cl loop

                tc_level_set.toc();
                std::cout
                        << "INITIALISATION (projection of analytic solution - no matrix calculation - no min/max calculation) LEVEL SET: t = "
                        << tc_level_set << " seconds" << std::endl;

            }


        }


        Level_set_berstein_high_order_interpolation() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
//std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;

            ret = gradient(pt);
            return ret / ret.norm();
        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
            size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                    auto values_cell = sol_HHO.col(counter);
                    auto grad_eval = cb.eval_gradients(pt);
                    ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                    ret(1) = values_cell.dot(grad_eval.col(1));

                    return ret;
                }
                counter += 1;

            }
            std::cout << "Se compare questo problema in gradient()" << std::endl;
            ret(0) += 1e10;
            ret(1) += 1e10;
            return ret; //to check if doesn't enter in the loop

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

        T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            auto grad = this->gradient(pt, msh, cl);
            T grad_norm = grad.norm();
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

//std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      (pow(grad(0), 2.0) * (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                       pow(grad(1), 2.0) * (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                       2.0 * pow(grad(0), 2.0) * pow(grad(1), 2.0) *
                                       (values_cell.dot(cb.eval_derivative_xy(pt))));

//std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//auto grad_eval = cb.eval_gradients(pt) ;

//T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }


        void normal_continuous_setting() {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            timecounter tc;
            tc.tic();

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
            for (auto &cl: msh.cells) {
                timecounter tc2;
//tc2.tic();
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                    ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

            }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
            normal_c_FEM_0 = solver_global_mass.solve(ret0);
            normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                    normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
                }

            }
            tc.toc();

            std::cout << "----> TIME: normal continuous creation, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
            return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

        }

        void gradient_continuous_setting() {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                    gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1>
        normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }


        T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);

        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein_high_order_interpolation_fast :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping



        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

        Level_set_berstein_high_order_interpolation_fast(const FiniteSpace &fe_data, const Fonction &level_set,
                                                         const Mesh &msh, bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check) {

            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1> RHS;    // Known term

            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);



// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


// std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }



// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {


                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop



            set_max_min();

            tc_level_set.toc();
            std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds"
                      << std::endl;


        }


        Level_set_berstein_high_order_interpolation_fast() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
//std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;

            ret = gradient(pt);
            return ret / ret.norm();
        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
            size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                    auto values_cell = sol_HHO.col(counter);
                    auto grad_eval = cb.eval_gradients(pt);
                    ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                    ret(1) = values_cell.dot(grad_eval.col(1));

                    return ret;
                }
                counter += 1;

            }
            std::cout << "Se compare questo problema in gradient()" << std::endl;
            ret(0) += 1e10;
            ret(1) += 1e10;
            return ret; //to check if doesn't enter in the loop

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

        T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            auto grad = this->gradient(pt, msh, cl);
            T grad_norm = grad.norm();
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

//std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      (pow(grad(0), 2.0) * (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                       pow(grad(1), 2.0) * (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                       2.0 * pow(grad(0), 2.0) * pow(grad(1), 2.0) *
                                       (values_cell.dot(cb.eval_derivative_xy(pt))));

//std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//auto grad_eval = cb.eval_gradients(pt) ;

//T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }


        template<typename Transport_Method>
        void normal_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            timecounter tc;
            tc.tic();

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
            for (auto &cl: msh.cells) {
                timecounter tc2;
//tc2.tic();
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                    ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

            }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
            normal_c_FEM_0 = solver_global_mass.solve(ret0);
            normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                    normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
                }

            }
            tc.toc();

            std::cout << "----> TIME: normal continuous creation, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
            return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

        }


        template<typename Transport_Method>
        void gradient_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                    gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1>
        normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }


        T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);

        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


    };


    template<typename Mesh, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Transport_problem_method {

        Mesh msh;
        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

        SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem


// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
        SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
        SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

        Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

        SparseMatrix <T> cij_norm, nij0, nij1;
        SparseMatrix <T> cji_norm, nji0, nji1;

        Transport_problem_method(const FiniteSpace &fe_data, const Mesh &msh)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {

            timecounter tc_level_set;
            tc_level_set.tic();

            std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation





            Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx


            Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


            cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);


// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    for (size_t j = 0; j < local_dim; j++) {

                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                        triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                        triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                        triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));


                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);

                }


            } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
            Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
            triplets.clear();


// Finalisation global assembling
            Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
            triplets_c_term_y.clear();


// NORM of c_ij

            cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                        Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
            nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
            SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
            SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient(cji_norm);
            nji1 = cji_y.cwiseQuotient(cji_norm);


            tc_level_set.toc();
            std::cout << "Construction of Transport Problem method : machine time t = " << tc_level_set << " seconds"
                      << std::endl;

        }


    };

    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein_high_order_interpolation_grad_cont :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
        std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

        SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
        SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
        SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

        Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

        SparseMatrix <T> cij_norm, nij0, nij1;
        SparseMatrix <T> cji_norm, nji0, nji1;


        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

        Level_set_berstein_high_order_interpolation_grad_cont(const FiniteSpace &fe_data, const Fonction &level_set,
                                                              const Mesh &msh, bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check) {
            if (!analytic_check) {
                timecounter tc_level_set;
                tc_level_set.tic();
                Matrix<T, Dynamic, 1> RHS;    // Known term
                std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation


                last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
                last_row_end = last_row_init + Nx - 1;
                number_faces_one_row = 2 * Nx +
                                       1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

                Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

                Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

                Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


                cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
                vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                    }


                    auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                    auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                    auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                    for (size_t i = 0; i < local_dim; i++) {
                        size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                        for (size_t j = 0; j < local_dim; j++) {
/*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                            size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                            triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                            triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                            triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                        }
                        Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                        RHS_vandermonde(i) = level_set(qps[i]);
                    }


                    auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                    sol_HHO.col(cell_offset) = sol_tmp;
                    for (size_t i = 0; i < local_dim; i++) {

                        size_t asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                    }
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


                } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
                Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
                triplets.clear();


// Finalisation global assembling
                Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
                triplets_c_term_x.clear();
                Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
                triplets_c_term_y.clear();

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

                cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                            Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
                nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
                nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
                SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
                SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
                cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
                nji0 = cji_x.cwiseQuotient(cji_norm);
                nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

//std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
//std::cout<<"local_dim size "<<local_dim<<std::endl;
//std::cout<<"n_cls "<<n_cls<<std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum

                timecounter tcbis;

//tcbis.tic();
                set_max_min();
//tcbis.toc();
//std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

                tc_level_set.toc();
                std::cout << "Initialisation level set (+ matrices transport pb) : machine time t = " << tc_level_set
                          << " seconds" << std::endl;

            } else {
                timecounter tc_level_set;
                tc_level_set.tic();

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

//std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
                    }



// Assembling triplets for global problem
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                        RHS_vandermonde(i) = level_set(qps[i]);


                    auto sol_tmp = cod.solve(RHS_vandermonde);
                    sol_HHO.col(cell_offset) = sol_tmp;
                    for (size_t i = 0; i < local_dim; i++) {
                        size_t asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_HHO(i, cell_offset);
                    }


                } // end of cl loop

                tc_level_set.toc();
                std::cout << bold << yellow << "Initialisation level set: t = " << tc_level_set << " seconds" << reset
                          << std::endl;

            }


        }


        Level_set_berstein_high_order_interpolation_grad_cont() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
            std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min << "." << std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient_disc(pt, msh, cl);
            return ret / ret.norm();

        }

        T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
            auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                    (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                    2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                    (values_cell.dot(grad_eval.col(1))) *
                                                                    (values_cell.dot(cb.eval_derivative_xy(pt)))
            );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }


        void normal_continuous_setting() {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            timecounter tc;
            tc.tic();

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
            for (auto &cl: msh.cells) {
//timecounter tc2 ;
//tc2.tic();
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_normal = (this->normal_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                    ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

            }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
            normal_c_FEM_0 = solver_global_mass.solve(ret0);
            normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                    normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
                }

            }
            tc.toc();

            std::cout << "----> TIME: normal continuous setting, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
            return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

        }

        void gradient_continuous_setting() {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                    gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }


        T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->gradient(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);

        }


//    void curvature_avg_continuous_setting()
//    {
//
//        bool first_cut_cell_found = FALSE ;
//        T distance_pts = 0.0;
//        point<T,2> first_point ;
//        point<T,2> cell_end_point;
//
//        for(auto& cl : msh.cells)
//        {
//
//            if(cl.user_data.location == element_location::ON_INTERFACE)
//            {
//
//                if(!first_cut_cell_found)
//                {
//                        bool agglo_cl = cl.user_data.highlight ;
//                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                        std::vector< size_t > index_inner_cls ;
//                        if( agglo_cl ){
//                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                        }
//        //                if( agglo_cl && amount_sub_cls == 2 )
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                if( agglo_cl && amount_sub_cls == 3 ){
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                    index_inner_cls.push_back( 2.0*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                }
//                        size_t pos_index = 0;
//                        size_t pos_index_bis = 0;
//
//                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                        {
//                            T val0 = ls_cell.divergence( *interface_point );
//
//                            point<T,2> curv_var = point_type(distance_pts , 0.0);
//                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                test_curv_var_cell->add_data(curv_var, val0);
//
//
//                             if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                             {
//                                 auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                 assert(offset_cells.size() == 2);
//                                 auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                 auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                 T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                 T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                 test_inner_cell->add_data(curv_var, val_skeleton0);
//                                 test_inner_cell->add_data(curv_var, val_skeleton1);
//                                 if( pos_index_bis+1 < index_inner_cls.size() )
//                                     pos_index_bis++;
//                             }
//
//                            test_curv_var_divergence0->add_data(curv_var, val0);
//                            if(*interface_point == *(cl.user_data.interface.end() -1))
//                                distance_pts +=  0.0 ;
//                            else
//                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                            // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
//                            pos_index++;
//                        }
//                        first_cut_cell_found = TRUE;
//                        first_point = *cl.user_data.interface.begin() ;
//                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                    }
//                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
//                    {
//                        for(auto& cl : msh_i.cells)
//                        {
//                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
//                            {
//                                ls_cell.cell_assignment(cl);
//
//                                bool agglo_cl = cl.user_data.highlight ;
//                                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                                std::vector< size_t > index_inner_cls ;
//                                if( agglo_cl ){
//                                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                                }
//                                size_t pos_index = 0;
//                                size_t pos_index_bis = 0;
//
//                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                                {
//
//                                    T val0 = ls_cell.divergence( *interface_point );
//
//                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
//                                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                        test_curv_var_cell->add_data(curv_var, val0);
//
//                                    test_curv_var_divergence0->add_data(curv_var, val0);
//
//                                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                                    {
//                                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                        assert(offset_cells.size() == 2);
//                                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                        T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                        T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                        test_inner_cell->add_data(curv_var, val_skeleton0);
//                                        test_inner_cell->add_data(curv_var, val_skeleton1);
//                                        if( pos_index_bis+1 < index_inner_cls.size() )
//                                            pos_index_bis++;
//                                    }
//
//
//                                    if(*interface_point == *(cl.user_data.interface.end() -1))
//                                        distance_pts += 0.0 ;
//                                    else
//                                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                                     pos_index++;
//                                }
//                                cell_end_point = *(cl.user_data.interface.end() -1) ;
//                            }
//
//                        }
//
//                    }
//                    else
//                        break;
//
//                }
//
//
//            }
//
//
//    }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


        void upload_level_set(const std::string &filename_FEM) {
            size_t counter_FEM = 0;

            std::ifstream file_FEM;
            file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
            if (!file_FEM.is_open()) {
                exit(10);
            }

            while (!file_FEM.eof()) {
                if (counter_FEM < sol_FEM.size()) {
                    T val;
                    file_FEM >> val;
                    sol_FEM(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM.close();

// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
                }
            }


        }


    };


    template<typename Mesh>
    struct Interface_parametrisation {
        typedef typename Mesh::cell_type cell_type;
        typedef typename Mesh::coordinate_type T;
        Mesh msh_orig;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh msh_agglo;
        size_t degree_det;
        size_t basis_degree, basis_size;


        Interface_parametrisation(const Mesh &msh, size_t degree) : msh_orig(msh), basis_degree(degree),
                                                                    basis_size(degree + 1), degree_det(2 * degree) {
        }


        Matrix<T, 2, 1>
        operator()(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


            auto physical_pts = cl.user_data.interface;

            cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);

            auto basis = cb.eval_basis_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = (size_pts - 1) / basis_degree;


            if (size_cls == 1) {

                ret(0) += basis(0) * physical_pts[0].x();
                ret(0) += basis(1) * physical_pts[basis_degree].x();
                ret(1) += basis(0) * physical_pts[0].y();
                ret(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1].x();
                    ret(1) += basis(i) * physical_pts[i - 1].y();
                }
                return ret;
            } else {
                ret(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
                ret(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
                ret(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
                ret(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                    ret(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
                }

                return ret;

            }
        }

        Matrix<T, 2, 1>
        operator()(const T &pt, int r = 0) const {

            return this->operator()(pt, msh_agglo, agglo_LS_cl, r);

        }


        Matrix<T, 2, 1>
        derivative(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


            auto physical_pts = cl.user_data.interface;

            cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);

            auto basis = cb.eval_gradients_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = (size_pts - 1) / basis_degree;


            if (size_cls == 1) {

                ret(0) += basis(0) * physical_pts[0].x();
                ret(0) += basis(1) * physical_pts[basis_degree].x();
                ret(1) += basis(0) * physical_pts[0].y();
                ret(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1].x();
                    ret(1) += basis(i) * physical_pts[i - 1].y();
                }
                return ret;
            } else {
                ret(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
                ret(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
                ret(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
                ret(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

                for (size_t i = 2; i < basis_size; i++) {
                    ret(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                    ret(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
                }

                return ret;

            }
        }


        T
        jacobian(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {
            return (this->derivative(pt, msh, cl, r)).norm();
        }


        Matrix<T, 2, 1>
        tangent(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {

            auto der = (this->derivative(pt, msh, cl, r));
            return der / der.norm();


        }

        Matrix<T, 2, 1>
        normal_old(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


            auto physical_pts = cl.user_data.interface;

            cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
            auto basis = cb.eval_double_derivative_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = (size_pts - 1) / basis_degree;

            auto curv_der = (this->derivative(pt, msh, cl, r));
            auto curv_der_norm = curv_der.norm();

            if (size_cls == 1) {

                curv_double_der(0) += basis(0) * physical_pts[0].x();
                curv_double_der(0) += basis(1) * physical_pts[basis_degree].x();
                curv_double_der(1) += basis(0) * physical_pts[0].y();
                curv_double_der(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    curv_double_der(0) += basis(i) * physical_pts[i - 1].x();
                    curv_double_der(1) += basis(i) * physical_pts[i - 1].y();
                }
//return ret;
            } else {
                curv_double_der(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
                curv_double_der(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
                curv_double_der(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
                curv_double_der(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

                for (size_t i = 2; i < basis_size; i++) {
                    curv_double_der(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                    curv_double_der(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
                }

//return ret;

            }
            T coeff = curv_der(0) * curv_double_der(0) + curv_der(1) * curv_double_der(1);
            ret(0) = curv_double_der(0) / curv_der_norm - curv_der(0) / pow(curv_der_norm, 3) * coeff;
            ret(1) = curv_double_der(1) / curv_der_norm - curv_der(1) / pow(curv_der_norm, 3) * coeff;


            return -ret / ret.norm();

        }

        Matrix<T, 2, 1>
        normal(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {

            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            auto tan_pt = (this->tangent(pt, msh, cl, r));
            ret(0) = tan_pt(1);
            ret(1) = -tan_pt(0);
            return ret;

        }

        T
        curvature(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {
            auto physical_pts = cl.user_data.interface;

            cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
            auto basis = cb.eval_double_derivative_1d(pt);

            auto size_pts = physical_pts.size();
            auto size_cls = (size_pts - 1) / basis_degree;

            auto curv_der = (this->derivative(pt, msh, cl, r));
            auto curv_der_norm = curv_der.norm();

            if (size_cls == 1) {

                curv_double_der(0) += basis(0) * physical_pts[0].x();
                curv_double_der(0) += basis(1) * physical_pts[basis_degree].x();
                curv_double_der(1) += basis(0) * physical_pts[0].y();
                curv_double_der(1) += basis(1) * physical_pts[basis_degree].y();
                for (size_t i = 2; i < basis_size; i++) {
                    curv_double_der(0) += basis(i) * physical_pts[i - 1].x();
                    curv_double_der(1) += basis(i) * physical_pts[i - 1].y();
                }
//return ret;
            } else {
                curv_double_der(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
                curv_double_der(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
                curv_double_der(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
                curv_double_der(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

                for (size_t i = 2; i < basis_size; i++) {
                    curv_double_der(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                    curv_double_der(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
                }

//return ret;

            }
            T coeff = curv_der(0) * curv_double_der(0) + curv_der(1) * curv_double_der(1);
            ret(0) = curv_double_der(0) / curv_der_norm - curv_der(0) / pow(curv_der_norm, 3) * coeff;
            ret(1) = curv_double_der(1) / curv_der_norm - curv_der(1) / pow(curv_der_norm, 3) * coeff;
//return -ret/ret.norm() ;

//std::cout<<"curv = "<< ret.norm()/curv_der_norm<<std::endl ;

            return ret.norm() / curv_der_norm;

        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(msh_orig.cells[offset_subcells]);

                }
            }

        }

        void mesh_assignment(const Mesh &msh) {
            msh_agglo = msh;

        }
    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;




//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1;


        Eigen::Matrix <T, Dynamic, Dynamic> divergence_c_HHO;
        Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM;
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix_grad;
        size_t ndof_FE_grad, local_dim_grad;
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix_div;
        size_t ndof_FE_div, local_dim_div;
        size_t degree_grad, degree_div;

        Level_set_berstein(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                           const FiniteSpace &fe_data_gradient, const FiniteSpace &fe_data_divergence,
                           bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check), ndof_FE_grad(fe_data_gradient.ndof_FE),
                  local_dim_grad(fe_data_gradient.local_ndof),
                  connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE),
                  local_dim_div(fe_data_divergence.local_ndof),
                  connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order),
                  degree_div(fe_data_divergence.order) {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

//normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

//gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
            gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
            gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
            gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

            divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_div, n_cls);
            divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }





// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {

                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
//            std::cout << "Level set : t = " << tc_level_set << " seconds" << std::endl;



        }


        Level_set_berstein() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

//        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
//                if( std::abs(phi_max) >= std::abs(phi_min))
//                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
//                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
//                if( std::abs(phi_max) >= std::abs(phi_min))
//                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
//                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
//        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient_disc(pt, msh, cl);
            return ret / ret.norm();

        }

        T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
            auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                    (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                    2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                    (values_cell.dot(grad_eval.col(1))) *
                                                                    (values_cell.dot(cb.eval_derivative_xy(pt))));
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

//        return ( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );
// tolto il meno!!!!
        }

/*
    template< typename Transport_Method >
    void normal_continuous_setting(const Transport_Method& method )
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            //timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous setting, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    template<typename Transport_Method >
    void gradient_continuous_setting_k( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }
    */

        template<typename Transport_Method>
        void gradient_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_grad) + 1); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim_grad; i++) {

                    size_t asm_map = connectivity_matrix_grad[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim_grad; i++) {
                    size_t asm_map = connectivity_matrix_grad[counter_bis][i].first;
                    gradient_c_HHO_low_0(i, counter_bis) = gradient_c_FEM_low_0(asm_map);
                    gradient_c_HHO_low_1(i, counter_bis) = gradient_c_FEM_low_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

/*
    Eigen::Matrix<T,2,1> gradient_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }
    */

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1>
        gradient_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }

/*
    Eigen::Matrix<T,2,1> normal_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }
    */
        Eigen::Matrix<T, 2, 1>
        normal_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }

/*
    T divergence_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient_cont_k( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }
    */
        T divergence_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->gradient_cont(pt, msh, cl)).norm();


            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);
//        return ( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction ); // tolto il meno

        }

        template<typename Transport_Method>
        void divergence_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"check integration order"<<std::endl;
            for (auto &cl: msh.cells) {
//std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);


                auto qps = integrate(msh, cl, 2 * (degree_div) + 1); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_divergence = (this->divergence_grad_cont(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret_loc += qp.second * disc_divergence * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
/*
            auto qps_prova = integrate(msh, cl, 2*(degree_FEM)+2); // integration of order 2k
            Matrix<T, Dynamic, 1> ret_loc_prova = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc_prova += qp.second * disc_divergence * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            std::cout<<ret_loc-ret_loc_prova<<std::endl;

*/            //std::cout<<ret_loc_prova<<std::endl;

//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim_div; i++) {

                    size_t asm_map = connectivity_matrix_div[cell_offset][i].first;

                    ret(asm_map) += ret_loc(i);


                }


            }
//std::cout<<"FINE integration order"<<std::endl;
            divergence_c_FEM = solver_global_mass.solve(ret);

//std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim_div; i++) {
                    size_t asm_map = connectivity_matrix_div[counter_bis][i].first;
//std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                    divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
//auto values_cell = divergence_c_HHO.col(counter);
            return (divergence_c_HHO.col(counter)).dot(cb.eval_basis(pt));
        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


        void upload_level_set(const std::string &filename_FEM) {
            size_t counter_FEM = 0;

            std::ifstream file_FEM;
            file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
            if (!file_FEM.is_open()) {
                exit(10);
            }

            while (!file_FEM.eof()) {
                if (counter_FEM < sol_FEM.size()) {
                    T val;
                    file_FEM >> val;
                    sol_FEM(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM.close();

// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
                }
            }


        }


    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein_curvature2 :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;




//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1;


        Eigen::Matrix <T, Dynamic, Dynamic> divergence_c_HHO;
        Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM;
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix_grad;
        size_t ndof_FE_grad, local_dim_grad;
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix_div;
        size_t ndof_FE_div, local_dim_div;
        size_t degree_grad, degree_div;

        Level_set_berstein_curvature2(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                      const FiniteSpace &fe_data_gradient, const FiniteSpace &fe_data_divergence,
                                      bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check), ndof_FE_grad(fe_data_gradient.ndof_FE),
                  local_dim_grad(fe_data_gradient.local_ndof),
                  connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE),
                  local_dim_div(fe_data_divergence.local_ndof),
                  connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order),
                  degree_div(fe_data_divergence.order) {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

//normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

//gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
            gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
            gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
            gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

            divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_div, n_cls);
            divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }





// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {

                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
            std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;


        }


        Level_set_berstein_curvature2() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
            std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                      << " (SI PUO TOGLIERE)." << std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient_disc(pt, msh, cl);
            return ret / ret.norm();

        }

        T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
            auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                    (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                    2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                    (values_cell.dot(grad_eval.col(1))) *
                                                                    (values_cell.dot(cb.eval_derivative_xy(pt)))
            );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }


        template<typename Transport_Method>
        void gradient_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_grad) + 1); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim_grad; i++) {

                    size_t asm_map = connectivity_matrix_grad[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim_grad; i++) {
                    size_t asm_map = connectivity_matrix_grad[counter_bis][i].first;
                    gradient_c_HHO_low_0(i, counter_bis) = gradient_c_FEM_low_0(asm_map);
                    gradient_c_HHO_low_1(i, counter_bis) = gradient_c_FEM_low_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        gradient_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1>
        normal_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_low_0.col(counter);
            auto values_cell1 = gradient_c_HHO_low_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }


        template<typename Transport_Method>
        void divergence_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"check integration order"<<std::endl;
            for (auto &cl: msh.cells) {
//std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);


                auto qps = integrate(msh, cl, 2 * (degree_div) + 1); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_divergence = (this->divergence_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret_loc += qp.second * disc_divergence * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }

//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim_div; i++) {

                    size_t asm_map = connectivity_matrix_div[cell_offset][i].first;

                    ret(asm_map) += ret_loc(i);


                }


            }
//std::cout<<"FINE integration order"<<std::endl;
            divergence_c_FEM = solver_global_mass.solve(ret);

//std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim_div; i++) {
                    size_t asm_map = connectivity_matrix_div[counter_bis][i].first;
//std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                    divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }


        void divergence_continuous_setting_avg() {


            Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE_div);
            Array<T, Dynamic, 1> sum = Array<T, Dynamic, 1>::Zero(ndof_FE_div);


            size_t counter_cl = 0;
            for (auto &cl: msh.cells) {
                size_t i = 0;
                auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, degree_div);
                for (auto &qp: qps) {
                    size_t asm_map = connectivity_matrix_div[counter_cl][i].first;
                    sum(asm_map) += (this->divergence_disc(qp, msh, cl));
                    counting_avg(asm_map)++;
                }
            }

            divergence_c_FEM = (sum.array()).cwiseQuotient(counting_avg);


            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
                }

            }

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
//auto values_cell = divergence_c_HHO.col(counter);
            return (divergence_c_HHO.col(counter)).dot(cb.eval_basis(pt));
        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


        void upload_level_set(const std::string &filename_FEM) {
            size_t counter_FEM = 0;

            std::ifstream file_FEM;
            file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
            if (!file_FEM.is_open()) {
                exit(10);
            }

            while (!file_FEM.eof()) {
                if (counter_FEM < sol_FEM.size()) {
                    T val;
                    file_FEM >> val;
                    sol_FEM(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM.close();

// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
                }
            }


        }


    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct Level_set_berstein_high_order_interpolation_grad_cont_fast :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

        Level_set_berstein_high_order_interpolation_grad_cont_fast(const FiniteSpace &fe_data, const Fonction &level_set,
                                                                   const Mesh &msh, bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check) {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }





// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {

                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
            std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;


        }


        Level_set_berstein_high_order_interpolation_grad_cont_fast() = default;


        void
        coefficients_mapping() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_mapping_MAX_MAX() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {


            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
            std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                      << " (SI PUO TOGLIERE)." << std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1>
        normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient_disc(pt, msh, cl);
            return ret / ret.norm();

        }

        T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
            auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                    (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                    2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                    (values_cell.dot(grad_eval.col(1))) *
                                                                    (values_cell.dot(cb.eval_derivative_xy(pt)))
            );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }

        template<typename Transport_Method>
        void normal_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            timecounter tc;
            tc.tic();

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
            for (auto &cl: msh.cells) {
//timecounter tc2 ;
//tc2.tic();
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_normal = (this->normal_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                    ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

            }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
            normal_c_FEM_0 = solver_global_mass.solve(ret0);
            normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                    normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
                }

            }
            tc.toc();

            std::cout << "----> TIME: normal continuous setting, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
            return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

        }

        template<typename Transport_Method>
        void gradient_continuous_setting(const Transport_Method &method) {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                    gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
                }

            }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

            return ret / ret.norm();

        }


        T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->gradient(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);

        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                if (!analytic_check) {
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


        void upload_level_set(const std::string &filename_FEM) {
            size_t counter_FEM = 0;

            std::ifstream file_FEM;
            file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
            if (!file_FEM.is_open()) {
                exit(10);
            }

            while (!file_FEM.eof()) {
                if (counter_FEM < sol_FEM.size()) {
                    T val;
                    file_FEM >> val;
                    sol_FEM(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM.close();

// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
                }
            }


        }


    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct L2projected_level_set_high_order_parallelize :
            public level_set<T> {

        bool analytic_check = FALSE;

        T phi_max, phi_min;
        size_t last_row_init, last_row_end, number_faces_one_row;

        T iso_val_interface = 0.0;
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
        std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

        SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
        Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
        SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
        SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

        Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem
//SparseMatrix<T>                 Global_Mass_Lumped_sparse;

        SparseMatrix <T> cij_norm, nij0, nij1;
        SparseMatrix <T> cji_norm, nji0, nji1;


        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
        Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
        Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

        L2projected_level_set_high_order_parallelize(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                                     bool analytic_check = FALSE)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
                  analytic_check(analytic_check) {
            if (!analytic_check) {
                timecounter tc_level_set;
                tc_level_set.tic();
                Matrix<T, Dynamic, 1> RHS;    // Known term



                last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
                last_row_end = last_row_init + Nx - 1;
                number_faces_one_row = 2 * Nx +
                                       1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

                Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

                Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
                Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

                Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
//Global_Mass_Lumped_sparse = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
//Global_Mass_Lumped_sparse.reserve(ndof_FE);

                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


                cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
                nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
                vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


                std::cout
                        << "----> In 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis."
                        << std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
                timecounter tc_prova;
/*
#ifdef HAVE_INTEL_TBB
            //tc_prova.tic();
            //tbb::task_scheduler_init init(1);
            tbb::task_scheduler_init init(tbb::task_scheduler_init::default_num_threads());
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            for (size_t ind = 0; ind < local_dim; ind++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //               [ & ] (size_t & ind){
                local_vandermonde.block(ind,0,1,local_dim) = (cb.eval_basis(pts[ind])).transpose() ;


            }
              //  );

            cod.compute(local_vandermonde);
            //tc_prova.toc();
            //std::cout << bold << yellow << "--> local_vandermonde: t = " << tc_prova << " seconds" << reset << std::endl;

            tc_prova.tic();

            std::vector< Triplet<T> >       triplets_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y_loc; // Position elements: Sparse Matrix Notation
            //std::vector< Triplet<T> >       triplets_lumped_loc; // Position elements: Sparse Matrix Notation
            Matrix<T, Dynamic, 1> RHS_vandermonde_loc = Matrix<T, Dynamic, 1>::Zero(local_dim);

            size_t n_cells = msh.cells.size();
            //std::cout<<" I m in parallel zone"<<std::endl;
            timecounter tc_prova2;
            //for( const auto& cl : msh.cells )
            //{
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                //tc_prova2.tic();
                //size_t cell_ind = offset(msh, cl) ;
                //std::cout<<"----> Pos 0"<<std::endl;
                auto &cl = msh.cells[cell_ind];
                //std::cout<<"---> CELL = "<<cell_ind<<std::endl;
                //std::cout<<"----> Pos 1"<<std::endl;
                //size_t cell_offset = offset(msh, cl) ;
                //std::cout<<"----> Pos 2"<<std::endl;
                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );
                //std::cout<<"----> Pos 3"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);
                //std::cout<<"----> Pos 4"<<std::endl;
                //tc_prova2.toc();

                //std::cout << "----> TIME --> local_cij : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;
                //std::cout<<"----> Pos 5"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_lumped_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                //std::cout<<"-----> Pos 7"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> qps points : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                for (size_t i = 0; i < local_dim; i++)
                {

                    //std::cout<<"----> Pos 6"<<std::endl;
                    size_t asm_map_i = connectivity_matrix[cell_ind][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {
                        size_t asm_map_j = connectivity_matrix[cell_ind][j].first ;
                        //std::cout<<"i = "<<i <<" , j = "<< j <<std::endl;
                        //std::cout<<"asm_map_i = "<<asm_map_i <<" , asm_map_j = "<< asm_map_j <<std::endl;
                        //std::cout<<"-----> Pos 8.0"<<std::endl;
                        //Global_Mass.coeffRef( asm_map_i, asm_map_j ) += local_mass(i,j) ;
                        //std::cout<<"-----> Pos 8.1"<<std::endl;
                        //Global_c_term_x.coeffRef( asm_map_i, asm_map_j ) += local_cij.first(i,j);
                        //std::cout<<"-----> Pos 8.2"<<std::endl;
                        //Global_c_term_y.coeffRef( asm_map_i, asm_map_j ) += local_cij.second(i,j)  ;
                        //std::cout<<"-----> Pos 8.3"<<std::endl;

                      triplets_loc.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                      triplets_c_term_x_loc.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                      triplets_c_term_y_loc.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                    }

                    //std::cout<<"---------> Pos 8.4"<<std::endl;
                    //triplets_lumped_loc.push_back( Triplet<T>( asm_map_i , asm_map_i , local_mass_lumped(i) ) );

                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    RHS_vandermonde_loc(i) = level_set( qps[i]) ;
                    //std::cout<<"----> Pos 8"<<std::endl;
                }
                //tc_prova2.toc();
                //std::cout << "----> TIME --> Double loop : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                //std::cout<<"-----> Pos 9"<<std::endl;
                auto sol_tmp = cod.solve(RHS_vandermonde_loc) ;

                sol_HHO.col(cell_ind) = sol_tmp ;
                for (size_t ind2 = 0; ind2 < local_dim; ind2++)
                {
                    size_t asm_map =  connectivity_matrix[cell_ind][ind2].first ;
                    sol_FEM( asm_map ) = sol_HHO(ind2,cell_ind) ;

                }


                size_t i_vertex = cell_ind+floor(cell_ind/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_ind) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

                //tc_prova2.toc();
                //std::cout << "----> TIME --> RESOLUTION : t = " << tc_prova2 << " seconds" << std::endl;
            }
            );
            //std::cout<<"----------------------> Pos 10"<<std::endl;
            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets_loc.begin(), triplets_loc.end() );
            triplets_loc.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x_loc.begin(), triplets_c_term_x_loc.end() );
            triplets_c_term_x_loc.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y_loc.begin(), triplets_c_term_y_loc.end() );
            triplets_c_term_y_loc.clear();
            //Global_Mass_Lumped_sparse.setFromTriplets( triplets_lumped_loc.begin(), triplets_lumped_loc.end() );
            //triplets_lumped_loc.clear();

            tc_prova.toc();
            std::cout << bold << yellow << "--> COSTRUCTION PROJECTION : t = " << tc_prova << " seconds" << reset << std::endl;

#else
     */
                std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
                std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation

                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                    }


                    auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                    auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                    auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                    for (size_t i = 0; i < local_dim; i++) {
                        size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                        for (size_t j = 0; j < local_dim; j++) {

                            size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                            triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                            triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                            triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                        }
                        Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                        RHS_vandermonde(i) = level_set(qps[i]);
                    }


                    auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                    sol_HHO.col(cell_offset) = sol_tmp;
                    for (size_t i = 0; i < local_dim; i++) {

                        size_t asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                    }
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


                } // end of cl loop

// Finalisation global assembling
                Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
                triplets.clear();


// Finalisation global assembling
                Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
                triplets_c_term_x.clear();
                Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
                triplets_c_term_y.clear();



//#endif

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

                cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                            Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
                nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
                nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
                SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
                SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
                cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
                nji0 = cji_x.cwiseQuotient(cji_norm);
                nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

                std::cout << "sol_FEM size " << sol_FEM.size() << std::endl;
                std::cout << "local_dim size " << local_dim << std::endl;
                std::cout << "n_cls " << n_cls << std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum
                timecounter tcbis;
                tcbis.tic();
                set_max_min();
                tcbis.toc();
                std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

                tc_level_set.toc();
                std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset
                          << std::endl;

            } else {
                timecounter tc_level_set;
                tc_level_set.tic();

                Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
                local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
                sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
                gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
                gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

                CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

                std::cout
                        << "----> FOR ANALYTIC CHECK 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis. JUST HHO FORMULATION IMPLEMENTED"
                        << std::endl;


/*

            // I TOOK AWAY BECAUSE I DO NOT HAVE TBB
#ifdef HAVE_INTEL_TBB
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                                      [&] (size_t & i){
                           local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;


                           }
                           );

            cod.compute(local_vandermonde);


            size_t n_cells = msh.cells.size();
            std::cout<<" I m in parallel zone"<<std::endl;
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                auto& cl = msh.cells[cell_ind];
                size_t cell_offset = offset(msh, cl) ;
                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                        [&] (size_t & i){
                        RHS_vandermonde(i) = level_set( qps[i]) ;
                    }
                    );

                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;


            }
            );

#else
            */
                for (const auto &cl: msh.cells) {
                    size_t cell_offset = offset(msh, cl);

                    if (cell_offset == 0) {
                        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                        for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                            local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                        }

                        cod.compute(local_vandermonde);
                    }



// Assembling triplets for global problem
                    auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                        RHS_vandermonde(i) = level_set(qps[i]);


                    auto sol_tmp = cod.solve(RHS_vandermonde);
                    sol_HHO.col(cell_offset) = sol_tmp;


                } // end of cl loop

//#endif
                tc_level_set.toc();
                std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset
                          << std::endl;

            }


        }


        L2projected_level_set_high_order_parallelize() = default;


        void
        coefficients_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );

                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );
#else
*/

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop


            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

            std::cout << "IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "
                      << (0.0 - phi_min) / (phi_max - phi_min) << std::endl;

            std::cout << "It should be close to 1/2, error = " << 1. / 2. - (0.0 - phi_min) / (phi_max - phi_min)
                      << std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

//#endif

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;


        }


        void
        coefficients_inverse_mapping() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

        }
        );

#else */
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }


//#endif
            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );


#else */

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;

            std::cout << "IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "
                      << (0.0 + phi_max) / (2.0 * phi_max) << std::endl;
            std::cout << "It should be close to 1/2, error = " << 1. / 2. - (0.0 + phi_max) / (2.0 * phi_max) << std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }


//#endif

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;


        }

        void
        coefficients_inverse_mapping_MAX_MAX() {

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(i) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );



#else */
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    if (std::abs(phi_max) >= std::abs(phi_min))
                        RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                    else
                        RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }


//#endif
            std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE_MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                      << std::endl;

        }


        void
        coefficients_sfasamento() {

            std::cout << "---> coefficients_sfasamento is not parallelize for the moment." << std::endl;
            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void
        coefficients_mapping_quadratic() {
            std::cout << "---> coefficients_mapping_quadratic is not parallelize for the moment." << std::endl;

            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
            T b = 1.0 / (phi_max - phi_min);
            T c = 1.0 / 2.0;
            T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    auto val = (*this)(pt, msh, cl);
                    if (val <= 0)
                        RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                    else
                        RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                    ct++;
                }

                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }

            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);
            iso_val_interface = 1.0 / 2.0;
            std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }

        void
        coefficients_inverse_mapping_quadratic() {
            std::cout << "---> coefficients_mapping_quadratic is not parallelize for the moment." << std::endl;
            Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                size_t ct = 0;
                for (auto &pt: nodes) {
                    RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                    ct++;
                }
                sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    mapped_phi(asm_map) = sol_vandermonde(i);
                }


            } // end of cl loop

            sol_FEM = mapped_phi;
            converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
            T ret0 = -10.0;
            T ret1 = 10.0;
            size_t counter_ret0 = 0;

            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

        }


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            sol_HHO = values_new;
            std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_HHO(i,cell_ind) = values_new( asm_map );
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = sol_HHO(0,cell_ind) ;
            vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

        }
        );

#else */
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);

                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

            }
//#endif

            std::cout << " --> converting_into_HHO_formulation. TO BE CHECKED that sol_FEM already uploaded!" << std::endl;

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_FEM( asm_map ) = values_new(i,cell_ind) ;
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = values_new(0,cell_ind) ;
            vertices(i_vertex+1) = values_new(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = values_new(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = values_new(3,cell_ind) ;
        }
        );

#else */
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = values_new(0, counter_bis);
                vertices(i_vertex + 1) = values_new(1, counter_bis);
                vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
                vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

            }

//#endif
            std::cout << " --> converting_into_FE_formulation. TO BE CHECKED that sol_HHO already uploaded!" << std::endl;

        }


        void set_max_min() {

            T ret0 = -10.0;
            T ret1 = 10.0;
/*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];

            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            for(auto& nd : nodes ){
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
            //    auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
           // );
        }
        );
        phi_max = ret0;
        phi_min = ret1;

#else */
            size_t counter_ret0 = 0;
            for (auto &cl: msh.cells) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

                for (auto &nd: nodes) {
                    auto phi_tmp = cb.eval_basis(nd);
                    auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                    auto new_ret = values_cell.dot(phi_tmp);
                    ret0 = std::max(new_ret, ret0);
                    ret1 = std::min(new_ret, ret1);
                }
                counter_ret0++;
            }

            phi_max = ret0;
            phi_min = ret1;
//#endif
            std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                      << " . SI PUO TOGLIERE." << std::endl;
        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
        T operator()(const point<T, 2> &pt) const {
/*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );
            }
        }
        );

        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator() PARALLEL!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop

#else
        */
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                    return values_cell.dot(cb.eval_basis(pt));

                }
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop

//#endif

        }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));

            return tmp;

        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;

            ret = gradient(pt);
            return ret / ret.norm();
        }


// IT WORKS FOR ALL THE MESHES --> SLOW
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
/*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
           if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(cell_ind);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
        }
        );
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;

        return ret; //to check if doesn't enter in the loop


#else
        */
            size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
            for (const auto &cl: msh.cells) {
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                    auto values_cell = sol_HHO.col(counter);
                    auto grad_eval = cb.eval_gradients(pt);
                    ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                    ret(1) = values_cell.dot(grad_eval.col(1));

                    return ret;
                }
                counter += 1;

            }
            std::cout << "Se compare questo problema in gradient()" << std::endl;
            ret(0) += 1e10;
            ret(1) += 1e10;
            return ret; //to check if doesn't enter in the loop
//#endif

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

        T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

            T grad_norm = (this->gradient(pt, msh, cl)).norm();
            auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                    (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                    (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                    2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                    (values_cell.dot(grad_eval.col(1))) *
                                                                    (values_cell.dot(cb.eval_derivative_xy(pt)))
            );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

        }


        void normal_continuous_setting() {


            timecounter tc;
            tc.tic();
            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);


            tc.toc();
            std::cout << "----> TIME: In normal_continuous_setting PARALLEL INVERSIONE MATRIX, time = " << tc << std::endl;
/*
#ifdef HAVE_INTEL_TBB
        tbb::task_scheduler_init init(1);
        size_t n_cells = msh.cells.size();

        tc.tic();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            //timecounter tc2 ;
            //tc2.tic();
            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            for (auto& qp : qps)
            {
            //size_t qps_size = qps.size();
            //tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            //    [&] (size_t & j){
            //    auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                ret1_loc += qp.second * disc_normal(1) * phi.transpose();

            }
           // );
            //tc2.toc();
            //std::cout<<"----> TIME: PARALLEL QPS = "<<tc2<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            //);
        }
        );
        tc.toc();

        std::cout<<"----> TIME: PARALLEL FEM CONSTRUCTION, time = "<<tc<<std::endl;
        tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        tc.toc();

        std::cout<<"----> TIME: FEM SOLVER, time = "<<tc<<std::endl;

        tc.tic();
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
        //    tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
        //    [&] (size_t & i){
             for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                normal_c_HHO_0(i,cell_ind) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,cell_ind) = normal_c_FEM_1( asm_map ) ;
            }
         //   );

        }
        );

        tc.toc();

        std::cout<<"----> TIME: PARALLEL HHO, time = "<<tc<<std::endl;

#else */


//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                    ret1_loc += qp.second * disc_normal(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            normal_c_FEM_0 = solver_global_mass.solve(ret0);
            normal_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                    normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
                }

            }

//#endif
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1>
        normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell0 = normal_c_HHO_0.col(counter);
            auto values_cell1 = normal_c_HHO_1.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
            return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

        }

        void gradient_continuous_setting() {


            Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(Global_Mass);




/*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            size_t qps_size = qps.size();
            tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            [&] (size_t & j){

                auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
            }
            );


            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            );
        }
        );


        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                gradient_c_HHO_0(i,cell_ind) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,cell_ind) = gradient_c_FEM_1( asm_map ) ;
            }
            );

        }
        );


#else  */

//std::cout<<"sono qua 0"<<std::endl;
            for (auto &cl: msh.cells) {

                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                auto cbs = cb.size();
                size_t cell_offset = offset(msh, cl);
                Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
                Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

                auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

                for (auto &qp: qps) {
                    auto phi = cb.eval_basis(qp.first);
                    auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                    ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                    ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
                }
//std::cout<<"sono qua 1"<<std::endl;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                    ret0(asm_map) += ret0_loc(i);
                    ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
//std::cout<<"sono qua 2"<<std::endl;


            }

            gradient_c_FEM_0 = solver_global_mass.solve(ret0);
            gradient_c_FEM_1 = solver_global_mass.solve(ret1);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                    gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
                }

            }

//#endif
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

        }

        Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


        Eigen::Matrix<T, 2, 1>
        normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);


            auto basis_eval = cb.eval_basis(pt);
            ret(0) = values_cell0.dot(basis_eval);
            ret(1) = values_cell1.dot(basis_eval);
            std::cout << "gradient_c_HHO" << '\n' << ret / ret.norm() << std::endl;

            return ret / ret.norm();

        }


        T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell0 = gradient_c_HHO_0.col(counter);
            auto values_cell1 = gradient_c_HHO_1.col(counter);

            auto grad_eval = cb.eval_gradients(pt);
            auto b_eval = cb.eval_basis(pt);
            T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

            T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                      ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                       (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                       (values_cell1.dot(grad_eval.col(0))) +
                                       (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                       (values_cell0.dot(grad_eval.col(1))) +
                                       (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

            return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                     divergence_correction);

        }


        void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde

                if (!analytic_check) {
                    for (size_t i = 0; i < local_dim; i++) {
                        auto asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_loc(i);
                    }
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
        }

        void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


            T hx = params.hx();
            T hy = params.hy();
            T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
            T r_max = std::max(radius_a, radius_b);
            T h = std::max(hx, hy);
            T r0 = r_max + 2 * h * sqrt(2.0);
            C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

            T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





            std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
            auto alfa = [=](const point<T, 2> &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
                }
                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde

                if (!analytic_check) {
                    for (size_t i = 0; i < local_dim; i++) {
                        auto asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_loc(i);
                    }
                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }

            } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();

        }


        void cut_off(T d) {

            Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
            Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
                    auto pt = qps[i];
                    auto asm_map = connectivity_matrix[cell_offset][i].first;

                    if ((*this)(pt, msh, cl) >= d)
                        local_RHS(i) = d;
                    else if ((*this)(pt, msh, cl) <= -d)
                        local_RHS(i) = -d;
                    else
                        local_RHS(i) = (*this)(pt, msh, cl);

                }

                sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
                sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
                if (!analytic_check) {
                    for (size_t i = 0; i < local_dim; i++) {
                        auto asm_map = connectivity_matrix[cell_offset][i].first;
                        sol_FEM(asm_map) = sol_loc(i);
                    }

                    size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                    vertices(i_vertex) = sol_HHO(0, cell_offset);
                    vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                    vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                    vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
                }
            } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
            if (!analytic_check)
                set_max_min();


        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_Bernstein_high_order :
            public Level_set_berstein_high_order_interpolation<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell_Bernstein_high_order(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_Bernstein_high_order() = default;


        LS_cell_Bernstein_high_order(const LS_cell_Bernstein_high_order &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }


        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> normal_cont_normalised(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont_normalised(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont_normalised(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient(pt, level_set.msh, subcl);
            }

        }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence(pt, level_set.msh, subcl);
            }
        }

        T divergence_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }

        T divergence_cont_grad(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont_grad(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont_grad(pt, level_set.msh, subcl);
            }
        }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
            return normal(pt);
        }

        T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            return operator()(pt);
        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_cont :
            public Level_set_berstein_high_order_interpolation_grad_cont<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell_high_order_grad_cont(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_cont() = default;

        LS_cell_high_order_grad_cont(const LS_cell_high_order_grad_cont &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
//        std::cout<<"LEVEL SET NORMAL. TO BE SUBSTITUTED WITH PARAMETRIC ONE!"<<std::endl;
            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient(pt, level_set.msh, subcl);
            }

        }

        Eigen::Matrix<T, 2, 1> gradient_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_disc(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_disc(pt, level_set.msh, subcl);
            }

        }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence(pt, level_set.msh, subcl);
            }
        }

        T divergence_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }

        T divergence_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

//    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
//    {
//        //agglo_LS_cl = cl;
//        cell_assignment(cl);
//        std::cout<<"If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."<<std::endl;
//        exit(9);
//        return normal( pt );
//    }

        T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            std::cout
                    << "If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."
                    << std::endl;
            exit(9);
            return operator()(pt);
        }

        T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence(pt, level_set.msh, cl);
        }

        T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence_disc(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal_disc(pt, level_set.msh, cl);
        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_cont_div_cont2 :
            public Level_set_berstein_curvature2<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

        LS_cell_high_order_grad_cont_div_cont2(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_cont_div_cont2() = default;

        LS_cell_high_order_grad_cont_div_cont2(const LS_cell_high_order_grad_cont_div_cont2 &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_grad_cont(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_cont(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }


    };

    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_disc_div_cont2 :
            public Level_set_berstein_curvature2<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

        LS_cell_high_order_grad_disc_div_cont2(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_disc_div_cont2() = default;

        LS_cell_high_order_grad_disc_div_cont2(const LS_cell_high_order_grad_disc_div_cont2 &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_disc(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_curvature_cont :
            public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell_high_order_curvature_cont(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_curvature_cont() = default;

        LS_cell_high_order_curvature_cont(const LS_cell_high_order_curvature_cont &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal_grad_cont(pt, level_set.msh, subcl);
            }
        }

/*
    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }
    */

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_cont(pt, level_set.msh, subcl);
            }

        }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }
/*
    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_disc( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    */
/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }
/*
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }
    */

    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_div_disc_grad_n_cont :
            public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

        LS_cell_high_order_div_disc_grad_n_cont(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_div_disc_grad_n_cont() = default;

        LS_cell_high_order_div_disc_grad_n_cont(const LS_cell_high_order_div_disc_grad_n_cont &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_grad_cont(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_cont(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_cont_div_disc :
            public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;
        size_t deg, grad_deg, div_deg;

        LS_cell_high_order_grad_cont_div_disc(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface),
                  deg(level_set_.degree_FEM) {
            grad_deg = deg;
            div_deg = deg;
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_cont_div_disc() = default;

        LS_cell_high_order_grad_cont_div_disc(const LS_cell_high_order_grad_cont_div_disc &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;
            deg = other.deg;
            grad_deg = other.grad_deg;
            div_deg = other.div_deg;
        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);

                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_grad_cont(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_cont(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_cont(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_grad_cont(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_grad_cont(pt, level_set.msh, subcl);
            }
        }

        T divergence_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }


        T operator()(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.operator()(pt, level_set.msh, cl);
        }

        T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence_grad_cont(pt, level_set.msh, cl);
        }

        T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence_disc(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal_grad_cont(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal_disc(pt, level_set.msh, cl);
        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_disc_div_disc :
            public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;
        size_t deg, grad_deg, div_deg;


        LS_cell_high_order_grad_disc_div_disc(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
            grad_deg = deg;
            div_deg = deg;
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_disc_div_disc() = default;

        LS_cell_high_order_grad_disc_div_disc(const LS_cell_high_order_grad_disc_div_disc &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;
            grad_deg = other.grad_deg;
            div_deg = other.div_deg;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_disc(pt, level_set.msh, subcl);
            }

        }

        Eigen::Matrix<T, 2, 1> gradient_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient_disc(pt, level_set.msh, cl_old);
            } else {
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient_disc(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }

        T divergence_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

        T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence_disc(pt, level_set.msh, cl);
        }

        T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
            return level_set.divergence_disc(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal_disc(pt, level_set.msh, cl);
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
            return level_set.normal_disc(pt, level_set.msh, cl);
        }

    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_grad_cont_fast :
            public Level_set_berstein_high_order_interpolation_grad_cont_fast<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell_high_order_grad_cont_fast(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_grad_cont_fast() = default;

        LS_cell_high_order_grad_cont_fast(const LS_cell_high_order_grad_cont_fast &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_cont(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_disc(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
                return level_set.normal_disc(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient(pt, level_set.msh, subcl);
            }

        }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence(pt, level_set.msh, subcl);
            }
        }

        T divergence_cont(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_cont(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_cont(pt, level_set.msh, subcl);
            }
        }

        T divergence_disc(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence_disc(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence_disc(pt, level_set.msh, subcl);
            }
        }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
            return normal(pt);
        }

        T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            return operator()(pt);
        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
    struct LS_cell_high_order_fast :
            public Level_set_berstein_high_order_interpolation_fast<Mesh, Fonction, FiniteSpace, T> {

        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;
        T iso_val_interface;
        T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell_high_order_fast(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

        LS_cell_high_order_fast() = default;

        LS_cell_high_order_fast(const LS_cell_high_order_fast &other) {
            agglo_msh = other.agglo_msh;
            level_set = other.level_set;
            iso_val_interface = other.iso_val_interface;
            radius = other.radius;

        }

        T operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
                return level_set.normal(pt, level_set.msh, subcl);
            }
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient(pt, level_set.msh, subcl);
            }

        }


        T divergence(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.divergence(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.divergence(pt, level_set.msh, subcl);
            }
        }


// STARE ATTENTI QUA TORNAREEEE
        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
            return normal(pt);
        }

        T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
            cell_assignment(cl);
            return operator()(pt);
        }


    };


    template<typename T, typename Mesh, typename Fonction>
    struct projected_level_set :
            public level_set<T> {
        std::vector <T> values;
        Eigen::Matrix <T, Dynamic, Dynamic> values_bis; // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh
        std::vector <size_t> boundary_cells;
// In the case in which I use FEM with Qk , k>1 I need another vector for all the values in each node

        size_t degree_FEM;
        size_t number_elements;
        Mesh msh;
        size_t Nx, Ny;
        mesh_init_params <T> params;
        size_t last_row_init, last_row_end, number_faces_one_row;
//  size_t counter_cell , counter_face, num_cell_row;

        T phi_max, phi_min;
        T cut_level;


        projected_level_set(const Fonction &level_set, const Mesh &msh, size_t degree_k, const mesh_init_params <T> &params)
                : number_elements((degree_k + 1) * (degree_k + 1)), msh(msh), degree_FEM(degree_k), Nx(params.Nx),
                  Ny(params.Ny), params(params) {

            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(((Nx + 1) * (Ny + 1)), 1);

//#ifdef NODES
// MATRIX NOTATION
            values_bis = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
// VECTOR NOTATION
//values_bis1= Eigen::Matrix<T, Dynamic, 1>::Zero(number_elements*msh.cells.size(), 1 );

//std::cout<<"Number of cells "<<msh.cells.size()<<std::endl;

// MATRIX NOTATION
// std::cout<<"Dimension of the basis "<<values_bis.size()<<std::endl;
// VECTOR NOTATION
// std::cout<<"Dimension of the basis "<<values_bis1.size()<<std::endl;
            size_t i_global = 0, i_local = 0, i_vertex = 0;
            for (auto &cl: msh.cells) {
/*
            bool boundary_bool = FALSE;
            for (auto& fc:faces(msh,cl)) {
                if (boundary_bool)
                    break;

                if(fc.is_boundary && !boundary_bool){
                    boundary_cells.push_back(offset(msh,cl));
                    boundary_bool = TRUE;
                }
            }
            */

                auto qps = equidistriduted_nodes<T, Mesh>(msh, cl, degree_FEM);
                i_local = 0;
                for (const auto &qp: qps) {

                    values.push_back(level_set(qp)); // I DONT KNOW IF IT IS USEFUL

// if (boundary_bool) {
//      values_bis(i_local,i_global) = 1 ;  // MATRIX NOTATION
// }
                    values_bis(i_local, i_global) = level_set(qp);  // MATRIX NOTATION
//values_bis1(i_local+i_global) = level_set(qp) ; // VECTOR NOTATION
                    i_vertex = i_global + floor(i_global / Nx);
                    if (i_local == 0)
                        vertices(i_vertex) = level_set(qp);

                    if (i_local == 1)
                        vertices(i_vertex + 1) = level_set(qp);

                    if (i_local == (degree_FEM + 2))
                        vertices(i_vertex + Nx + 2) = level_set(qp);

                    if (i_local == (degree_FEM + 1))
                        vertices(i_vertex + Nx + 1) = level_set(qp);
                    i_local++;
                }
                i_global++;  // MATRIX NOTATION
//  i_global+=number_elements;       // VECTOR NOTATION
            }
//#endif


        }

        projected_level_set() = default;


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            values_bis = values_new;
        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &vertices) {
            assert(degree_FEM == 1);
            for (size_t j = 0; j < values_bis.cols(); j++) {

                for (size_t i = 0; i < values_bis.rows(); i++) {
                    auto i_vertex = j + floor(j / Nx);
                    if (i == 0)
                        values_bis(i, j) = vertices(i_vertex);

                    if (i == 1)
                        values_bis(i, j) = vertices(i_vertex + 1);

                    if (i == (degree_FEM + 2))
                        values_bis(i, j) = vertices(i_vertex + Nx + 2);

                    if (i == (degree_FEM + 1))
                        values_bis(i, j) = vertices(i_vertex + Nx + 1);
                }
            }

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values) {
            assert(degree_FEM == 1);
            for (size_t j = 0; j < values_bis.cols(); j++) {

                for (size_t i = 0; i < values_bis.rows(); i++) {
                    auto i_vertex = j + floor(j / Nx);
                    if (i == 0)
                        vertices(i_vertex) = values(i, j);

                    if (i == 1)
                        vertices(i_vertex + 1) = values(i, j);

                    if (i == (degree_FEM + 2))
                        vertices(i_vertex + Nx + 2) = values(i, j);

                    if (i == (degree_FEM + 1))
                        vertices(i_vertex + Nx + 1) = values(i, j);
                }
            }

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
        T operator()(const typename Mesh::node_type &node) const {
// Optimised to check the value of the level set only in the vertices
// std::cout<<"Value in vertices "<<vertices(node.ptid)<<", at position "<<node.ptid<<std::endl;
            return vertices(node.ptid);

        }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
        T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
            size_t counter = 0;

// It looks for in what cell the point is
            for (const auto &cl: msh.cells) {
//std::cout<<"pt_in_cell operator in slow levelset"<<std::endl;
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
                    return values_cell.dot(cb.eval_basis(pt));

// T tmp=0;
// for(auto i = 0; i<number_elements ; i++)
// {
//     tmp += (values.at(i+counter))*(cb.eval_basis(pt))[i];
// }
// return tmp;
                }
//counter+=number_elements; // OLD VERSION OF THE CODE
                counter += 1;
            }
            std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
            return 1e10; //to check if doesn't enter in the loop
        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
// Checking if cell is agglomerated or not
/*
        size_t cell_points = (points(msh,cl)).size();
        size_t cells_number = msh.cells.size();
        bool agglomeration=FALSE;
        if ( cells_number < (Nx*Ny-1) ) {
            agglomeration = TRUE;
        }
        if ( cells_number > (Nx*Ny-1) ) {
                  // throw std::logic_error("shouldn't have arrived here...");
               }
        */

//if(cell_points<5)
//{
// MATRIX NOTATION
//   if (!agglomeration) {
//       counter = offset(msh,cl);
//    }
//   else{
//       counter = 1;//cells_counter(msh_origin,msh,cl);
//   }

//std::cout<<"Value of offset "<<counter<<std::endl;
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
            cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;

// VECTOR NOTATION

//size_t counter = offset(msh,cl)*number_elements;
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
//auto values_cell = (values_bis1.segment(counter,number_elements));
//T tmp = values_cell.dot( cb.eval_basis(pt) );
//return tmp;
// }
/*
        else
        {
            std::vector<size_t> indices = subcell_finder<T,Mesh>(msh, pt , cl , params);
            cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM,indices);
            size_t counter = 1; // DA TROVAREEE!!!!!!!!!!!!!!!
            auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
            T tmp = values_cell.dot( cb.eval_basis(pt) );
            return tmp;
        }
        */


        }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
// MATRIX NOTATION
            auto counter_face = offset(msh, fc);
            size_t counter_cell;
// da fc devo trovare la cella in cui sono per la base
//std::cout<<"Face number "<<counter_face<<std::endl;

// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
            if (counter_face >= last_row_init && counter_face <= last_row_end) {
                counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
            } else {
// Find in what row the face is
                auto num_cell_row = floor(counter_face / (number_faces_one_row));
                if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                    counter_cell = floor((counter_face - num_cell_row) / 2.0);
                } else {
// Face on the right boudary,
                    counter_cell = (num_cell_row + 1) * Nx - 1;
                }

            }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
            auto cl = msh.cells.at(counter_cell);
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
            cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell = (values_bis.block(0, counter_cell, number_elements, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;


        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;

            ret = gradient(pt);
            return ret / ret.norm();
        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
            size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            for (const auto &cl: msh.cells) {
// std::cout<<"pt_in_cell gradient in slow levelset"<<std::endl;
                if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);

                    auto values_cell = values_bis.col(counter);
                    auto grad_eval = cb.eval_gradients(pt);
                    ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                    ret(1) = values_cell.dot(grad_eval.col(1));

                    return ret;
                }
//counter+=number_elements; // OLD VERSION OF THE CODE
                counter += 1;

            }
            std::cout << "Se compare questo problema in gradient()" << std::endl;
            ret(0) += 1e10;
            ret(1) += 1e10;
            return ret; //to check if doesn't enter in the loop

        }


        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
//std::cout<<"the cell in NEW is the number "<<counter<<std::endl;
//std::cout<<"Value of offset "<<counter<<std::endl;
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell = values_bis.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

// VECTOR NOTATION

//size_t counter = offset(msh,cl)*number_elements;
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
//auto values_cell = (values_bis1.segment(counter,number_elements));
//T tmp = values_cell.dot( cb.eval_basis(pt) );
//return tmp;


        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }


// template<typename T , typename MATRIX , typename VECTOR >
        void smooth_cut_off(T C, T x_centre, T y_centre, T radius) {
            T hx = params.hx();
            T hy = params.hy();
            cut_level = C;
// T r0 = radius + 2*sqrt(pow(hx,2) + pow(hy,2)); // check value
//T r0 = radius + 2.5*std::max(hx , hy ); // check value
//T r0 = radius + 2.5*0.0625; // check value
            T pos_r0 = 0.45; //std::min(x_centre , 1 - x_centre );
// IF I wanna define like that I need to pass the value all'inizio, sennò cambia per valure le exact solution (cambiando x_centre).

//T max_r0 = pos_r0-(pos_r0 - 2*0.0625); //2.5*std::max(hx,hy); // if mesh too much coarse
//r0 = std::max(r0 , max_r0);
//r0 = 0.25*max_r0 + 0.75*r0 ;
//if(r0<radius)
//  r0 += 0.0625 ;
            T dist = pos_r0 - radius + 2 * 0.0625;
            T r0 = radius + dist / 2;
            T delta = r0 / 8;
//T delta = 0.0625 ; // r0/20.0; // or better std::max(hx,hy) ??
//T delta = sqrt(pow(hx,2) + pow(hy,2));
//if(std::abs(r0-delta-radius)<2*std::max(hx,hy) )
//   delta = delta/2;

            std::cout << "radius = " << radius << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                      << std::endl;
            std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
            std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;
            auto alfa = [x_centre, y_centre, delta, r0](const typename Mesh::point_type &pt) { // sol
                return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
            };

            size_t counter = 0;
// Eigen::Matrix<T, Dynamic, 1> tmp_vert = Matrix<T, Dynamic, 1>::Zero(vertices.rows(), 1); ;
            for (auto &pt: msh.points) {
// std::cout<<"the point is "<< pt<<" alfa is "<<alfa(pt)<<std::endl;
                vertices(counter) = (1 - alfa(pt)) * C + alfa(pt) * vertices(counter);
                counter++;
            }

            converting_into_HHO_formulation(vertices);
            phi_max = vertices.maxCoeff();
            phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?

            postprocess_output<double> postoutput00;
//typedef typename Mesh::point_type       point_type;
            point<double, 2> node;
            auto alfa_values = std::make_shared < gnuplot_output_object < double > > ("alfa.dat");
//auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
            for (auto &pt: msh.points) {
                alfa_values->add_data(pt, alfa(pt));
            }
            postoutput00.add_object(alfa_values);
            postoutput00.write();
        }


// template<typename T , typename MATRIX , typename VECTOR >
        void cut_off(T d) {
//auto vertices_abs = vertices.cwiseAbs();
//auto phi_max_abs = d*vertices_abs.maxCoeff();
//std::cout<<"MAX VALUE OF PHI ABS"<<phi_max_abs<<std::endl;

            cut_level = d;
//std::cout<<"CUTTING AT d = "<<d<<std::endl;
            T level_set_max = vertices.maxCoeff();
//std::cout<<"MAX VALUE OF PHI BEFORE CUTTING = "<<level_set_max<<std::endl;
//assert(degree_FEM == 1)

            Eigen::Matrix <T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(),
                                                                                                   values_bis.cols()); // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
            Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones(vertices.rows(),
                                                                                      1); // saving level_set on vertices mesh


            auto cut_off_level_vec = d * One_vec;
            auto cut_off_level_mat = d * One_mat;

            vertices /= (level_set_max);
            values_bis /= (level_set_max);
// std::cout<<"MAX VALUE OF NORMALISED PHI = "<<vertices.maxCoeff()<<std::endl;
            auto vertices_prova = vertices;
            auto values_bis_prova = values_bis;

            vertices = vertices.cwiseMin(cut_off_level_vec);
            values_bis = values_bis.cwiseMin(cut_off_level_mat);
// Cut off also in inner domain
            vertices = vertices.cwiseMax(-cut_off_level_vec);
            values_bis = values_bis.cwiseMax(-cut_off_level_mat);

// NOT NORMALISED CUT
//vertices = vertices.cwiseMin(cut_off_level_vec*level_set_max);
//values_bis = values_bis.cwiseMin(cut_off_level_mat*level_set_max);


            phi_max = vertices.maxCoeff();
            phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?
//std::cout<<"MAX VALUE OF PHI_CUT AND NORMALISED = "<<phi_max<<std::endl;
            std::cout << "Cut at " << phi_max << " , MIN VALUE OF PHI_CUT AND NORMALISED = " << phi_min
                      << " (NEGATIVE cut off ACTIVED)." << std::endl;

/*
        postprocess_output<double> postoutput2;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto test_activated_nodes = std::make_shared< gnuplot_output_object<double> >("test_activated_nodes.dat");
        auto test_before_cut_off = std::make_shared< gnuplot_output_object<double> >("test_before_cut_off.dat");

        for (size_t i = 0; i<vertices_prova.rows(); i++) {
            node = msh.points.at(i);
            test_before_cut_off->add_data(node,vertices_prova(i));

            if( std::abs(vertices_prova(i) - vertices(i))>1e-10 )
                vertices_prova(i) = 1;
            else
                vertices_prova(i) = 0;
            test_activated_nodes->add_data(node,vertices_prova(i));


        }


        for (size_t j = 0; j<values_bis.cols(); j++)
        {
            bool active_cell= FALSE;
            size_t i = 0;
            while (i<values_bis.rows() && !active_cell ) {
                if( values_bis_prova(i,j)!= values_bis(i,j) ){
                    active_cell = TRUE;
                //std::cout<<"values_bis_prova(i,j)= "<<values_bis_prova(i,j)<<" , values_bis(i,j)= "<<values_bis(i,j)<<std::endl;
              //  std::cout<<" the cell num "<<j<<" is active."<<std::endl;
                }
                i++;
            }
        }



        postoutput2.add_object(test_before_cut_off);
        postoutput2.add_object(test_activated_nodes);
        postoutput2.write();
        */
/*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

        }

        void boundary_con(T d) {
            T level_set_max = vertices.maxCoeff();
            std::cout << "MAX VALUE OF PHI" << level_set_max << std::endl;
//assert(degree_FEM == 1)

            Eigen::Matrix <T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(),
                                                                                                   values_bis.cols()); // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
            Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones(vertices.rows(),
                                                                                      1); // saving level_set on vertices mesh


            auto cut_off_level_vec = d * One_vec;
            auto cut_off_level_mat = d * One_mat;

            vertices /= (level_set_max);
            values_bis /= (level_set_max);
            vertices = vertices.cwiseMin(cut_off_level_vec);
            values_bis = values_bis.cwiseMin(cut_off_level_mat);
/*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

        }


    };


    template<typename T>
    class velocity_field {
    public:
        virtual Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
        }

/*
     virtual Eigen::Matrix<T,2,1> flux(const point<T,2>& pt) const
    {
    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }
    */

    };

    template<typename T>
    class velocity_field_pair {
    public:
        virtual std::pair <T, T> operator()(const point<T, 2> &pt) const {
        }

/*
     virtual Eigen::Matrix<T,2,1> flux(const point<T,2>& pt) const
    {
    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }
    */

    };


    template<typename T>
    struct rotational_velocity_field :
            public velocity_field<T> {
        T u1, xc, yc;

        rotational_velocity_field(T u1)
                : u1(u1) {
        }

        rotational_velocity_field(T xc, T yc, T u1)
                : u1(u1), xc(xc), yc(yc) {
        }

        Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret(0) = (u1 * pt.y() - xc) / xc;
            ret(1) = (-u1 * pt.x() + yc) / yc;

            return ret;
        }


    };

    template<typename T>
    struct linear_velocity_field :
            public velocity_field<T> {
        T u1, u2, u3, u4;

        linear_velocity_field(T u1, T u2, T u3, T u4)
                : u1(u1), u2(u2), u3(u3), u4(u4) {
        }

        Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret(0) = u1 * pt.x() + u2;
            ret(1) = u3 * pt.y() + u4;

            return ret;
        }
/*
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret(0) = 2*pt.x() - 2*alpha;
        ret(1) = 2*pt.y() - 2*beta;
        return ret;
    }
    */
    };


    template<typename T>
    struct taylor_green_vortex :
            public velocity_field<T> {
        T viscosity = 2.0;
        T time = 0.0;
        T b = 1.0;
        T F = b * std::exp(-2 * viscosity * time);
        bool old_tgv = true;

        taylor_green_vortex(T a, bool old_tgv) : viscosity(a), old_tgv(old_tgv) {};

        taylor_green_vortex(T a, bool old_tgv, T b) : viscosity(a), old_tgv(old_tgv), b(b) {};

        taylor_green_vortex() {};

        taylor_green_vortex(T a) : viscosity(a) {};

        Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
            Eigen::Matrix<T, 2, 1> ret;

            if (old_tgv) {
                ret(0) = std::cos(2 * M_PI * pt.x()) * std::sin(2 * M_PI * pt.y()) * F;
                ret(1) = -std::sin(2 * M_PI * pt.x()) * std::cos(2 * M_PI * pt.y()) * F;
            } else {
                ret(0) = std::sin(2 * M_PI * pt.x()) * std::cos(2 * M_PI * pt.y()) * F;
                ret(1) = -std::cos(2 * M_PI * pt.x()) * std::sin(2 * M_PI * pt.y()) * F;
            }
            return ret;
        }

        void
        set_time(T new_time) {
            time = new_time;
            F = b * std::exp(-2 * viscosity * time);

        }


    };


    template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct projection_velocity_high_order :
            public velocity_field_pair<T> {

        size_t last_row_init, last_row_end, number_faces_one_row;


// NEW IMPLEMENTATION STUFF
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton
// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        T u_max0, u_max1;


//SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
//Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
//Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
//std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

        std::pair <Eigen::Matrix<T, Dynamic, Dynamic>, Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO; // projection saved in HHO format: cell by cell
        std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> sol_FEM; // projection saved in Continuos FE format: global nodes
//std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh


// AGGLOMERATED MESHES DATA:
        typedef typename Mesh::cell_type cell_type;
        Mesh agglo_msh;
        std::vector <cell_type> subcells;
        cell_type agglo_LS_cl;

        projection_velocity_high_order(const FiniteSpace &fe_data, const Mesh &msh)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
            std::cout << "STO USANDO: equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)" << std::endl;
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
            sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

            sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                     Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));


        }

        projection_velocity_high_order(const FiniteSpace &fe_data, const Fonction &u, const Mesh &msh)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
            sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

            sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                     Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));


            size_t i_global = 0, i_local = 0; //, i_vertex=0;
            for (auto &cl: msh.cells) {
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                i_local = 0;
                for (const auto &qp: qps) {
                    auto asm_map = connectivity_matrix[i_global][i_local].first;
                    auto u0 = (u(qp))(0);
                    auto u1 = (u(qp))(1);

                    sol_HHO.first(i_local, i_global) = u0;
                    sol_HHO.second(i_local, i_global) = u1;
                    sol_FEM.first(asm_map) = u0;
                    sol_FEM.second(asm_map) = u1;
/*
                i_vertex = i_global+floor(i_global/Nx);
                if( i_local==0 ){
                    vertices.first(i_vertex) = u0 ;
                    vertices.second(i_vertex) = u1 ;
                }

                if( i_local==1 ){
                    vertices.first(i_vertex+1) = u0 ;
                    vertices.second(i_vertex+1) = u1 ;
                }

                if( i_local==(degree_FEM+2) ){
                    vertices.first(i_vertex+Nx+2) = u0 ;
                    vertices.second(i_vertex+Nx+2) = u1 ;
                }

                if( i_local==(degree_FEM+1) ){
                    vertices.first(i_vertex+Nx+1) = u0 ;
                    vertices.second(i_vertex+Nx+1) = u1 ;
                }
            */

                    i_local++;


                }
                i_global++;


            }

        }


        void set_agglo_mesh(Mesh &m_agglo_msh) {
            agglo_msh = m_agglo_msh;
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(msh.cells[offset_subcells]);

                }
            }

        }

        template<typename MATRIX>
        void set_discrete_points(MATRIX &values_new) {
            sol_HHO = values_new;
            std::cout << " Using set_discrete_points check that sol_FEM already uploaded!" << std::endl;

        }

        template<typename VECTOR>
        void converting_into_HHO_formulation(const VECTOR &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = values_new.first(asm_map);
                    sol_HHO.second(i, counter_bis) = values_new.second(asm_map);
                }
//  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
// vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
            std::cout << " Using converting_into_HHO_formulation check that sol_FEM already uploaded!" << std::endl;
//set_max_min();
//phi_min = sol_HHO.minCoeff() ;
//phi_max = sol_HHO.maxCoeff() ;

        }

        template<typename MATRIX>
        void converting_into_FE_formulation(const MATRIX &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM.first(asm_map) = values_new.first(i, counter_bis);
                    sol_FEM.second(asm_map) = values_new.second(i, counter_bis);
                }
//  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
// vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
            std::cout << " Using converting_into_FE_formulation check that sol_HHO already uploaded!" << std::endl;
//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

        }

        template<typename LEVEL_SET, typename TRANSPORT_METHOD>
        void L2_proj_into_FE_formulation(LEVEL_SET &level_set, const Mesh &msh, const TRANSPORT_METHOD &method) {
            std::cout << "L2 projection to have CONTINUOUS FE: SimplicialLLT to invert global Mass Matrix." << std::endl;
            timecounter tc_vel;
            tc_vel.tic();
            Matrix<T, Dynamic, 1> RHS1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            Matrix<T, Dynamic, 1> RHS2 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);

            for (auto cl: msh.cells) {
                auto local_RHS = make_bernstein_local_RHS_VEC(msh, cl, degree_FEM, *this);
                size_t cell_offset = offset(msh, cl);
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    RHS1(asm_map_i) += local_RHS.first(i);
                    RHS2(asm_map_i) += local_RHS.second(i);
                }

            }
            sol_FEM.first = solver_global_mass.solve(RHS1);
            sol_FEM.second = solver_global_mass.solve(RHS2);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }

            tc_vel.toc();
//std::cout<<"Time to L2 project velocity field : "<<tc_vel<<std::endl;
        }

        template<typename MATRIX>
        void smooth_converting_into_FE_formulation(const MATRIX &values_new) {
            std::cout << "SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."
                      << std::endl;
            Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sum_first(asm_map) += values_new.first(i, counter_bis);
                    sum_second(asm_map) += values_new.second(i, counter_bis);
                    counting_avg(asm_map)++;
                }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
            sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
            sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
            std::cout
                    << "In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"
                    << std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

        }


        std::pair <T, T> operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree_FEM);
//std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
            auto values_cell_first = (sol_HHO.first.block(0, counter, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, counter, local_dim, 1)).col(0);
//std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
//std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));
//std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

            return std::make_pair(tmp1, tmp2);
        }

        std::pair <T, T> operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {

                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = msh.cells[offset_old];

                cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl_old, degree_FEM);

                auto values_cell_first = (sol_HHO.first.block(0, offset_old, local_dim, 1)).col(0);
                auto values_cell_second = (sol_HHO.second.block(0, offset_old, local_dim, 1)).col(0);

                T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
                T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

                return std::make_pair(tmp1, tmp2);

            } else {
//            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
                auto offset = pt_in_subcell(msh, pt, agglo_LS_cl);
                auto subcl = msh.cells[offset];

                cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, subcl, degree_FEM);

                auto values_cell_first = (sol_HHO.first.block(0, offset, local_dim, 1)).col(0);
                auto values_cell_second = (sol_HHO.second.block(0, offset, local_dim, 1)).col(0);

                T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
                T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

                return std::make_pair(tmp1, tmp2);

            }

        }


    };


    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    struct velocity_HHO {


// NEW IMPLEMENTATION STUFF
        Mesh msh; // Original mesh, NOT agglomerated.

        size_t n_cls; // #cells
        size_t local_dim;

        Matrix <T, Dynamic, Dynamic> vel_global_n, vel_global_p, vel_global;


// AGGLOMERATED MESHES DATA:
        typedef typename Mesh::cell_type cell_type;
        Mesh agglo_msh;
        std::vector <cell_type> subcells;
        cell_type agglo_LS_cl;

        velocity_HHO() = default;

        velocity_HHO(const velocity_HHO &other) {
            msh = other.msh;
            n_cls = other.n_cls;
            local_dim = other.local_dim;
            vel_global_n = other.vel_global_n;
            vel_global_p = other.vel_global_p;
            vel_global = other.vel_global;
            agglo_msh = other.agglo_msh;
            subcells = other.subcells;
            agglo_LS_cl = other.agglo_LS_cl;
        }

        velocity_HHO(const Mesh &msh, const hho_degree_info &di)
                : msh(msh), n_cls(msh.cells.size()) {
            const auto celdeg = di.cell_degree();
            local_dim = vector_cell_basis<Mesh, T>::size(celdeg);
            vel_global_n = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            vel_global_p = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            vel_global = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);


        }

        void set_agglo_mesh(const Mesh &m_agglo_msh) {
            agglo_msh = m_agglo_msh;
            n_cls = agglo_msh.cells.size();
            vel_global_n = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            vel_global_p = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            vel_global = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
//        vel_global_n.resize(local_dim, n_cls) ;
//        vel_global_p.resize(local_dim, n_cls) ;
//        vel_global.resize(local_dim, n_cls) ;
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(msh.cells[offset_subcells]);

                }
            }

        }



/*
    std::pair<T,T> operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl) const
    {
        size_t counter = offset(msh,cl) ;
        cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        //std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0,counter,local_dim,1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0,counter,local_dim,1)).col(0);
        //std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
        //std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
        T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );
        //std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1,tmp2);
    }


    //  OPERATOR for MESH AGGLOMERATED
    std::pair<T,T> operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {

            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = msh.cells[offset_old];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl_old , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset_old,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset_old,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }
        else
        {
            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
            auto subcl = msh.cells[offset];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, subcl , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }

    }
    */

    };


    template<typename Mesh, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    struct velocity_high_order {

        size_t last_row_init, last_row_end, number_faces_one_row;


// NEW IMPLEMENTATION STUFF
        Mesh msh; // Original mesh, NOT agglomerated.
        mesh_init_params <T> params; // mesh parameter

        size_t degree_FEM; // FEM degree
        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices
        size_t Nx, Ny; // Number of cells in x and y direciton
// connectivity matrix : for each cell, it stores the global numbering
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;
//std::vector<std::vector<size_t>> connectivity_matrix ;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes

        T u_max0, u_max1;


//SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
//Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
//Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
//std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

        std::pair <Eigen::Matrix<T, Dynamic, Dynamic>, Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO; // projection saved in HHO format: cell by cell
        std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> sol_FEM; // projection saved in Continuos FE format: global nodes
//std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh

// std::vector<T> weightsArea ;
        Eigen::Matrix<T, Dynamic, 1> weightsArea;

// AGGLOMERATED MESHES DATA:
        typedef typename Mesh::cell_type cell_type;
        Mesh agglo_msh;
        std::vector <cell_type> subcells;
        cell_type agglo_LS_cl;


        velocity_high_order(const FiniteSpace &fe_data, const Mesh &msh)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
//std::cout<<"velocity_high_order: -> implemented with equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)"<<std::endl;
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
            sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

            sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                     Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));

            weightsArea = Eigen::Matrix<T, Dynamic, 1>::Zero(n_cls, 1);

        }

        void set_agglo_mesh(Mesh &m_agglo_msh) {
            agglo_msh = m_agglo_msh;
        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;

            if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
                (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(msh.cells[offset_subcells]);

                }
            }

        }


        template<typename MATRIX>
        void set_discrete_points(MATRIX &values_new) {
            sol_HHO = values_new;
            std::cout << " Using set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

        }

        void set_weight_area(size_t posCell, T w) {
            weightsArea(posCell) = 1.0 / w;
        }

        template<typename VECTOR>
        void converting_into_HHO_formulation(const VECTOR &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = values_new.first(asm_map);
                    sol_HHO.second(i, counter_bis) = values_new.second(asm_map);
                }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
//        std::cout<<" Using converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;
//set_max_min();
//phi_min = sol_HHO.minCoeff() ;
//phi_max = sol_HHO.maxCoeff() ;

        }

        template<typename MATRIX>
        void converting_into_FE_formulation(const MATRIX &values_new) {

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM.first(asm_map) = values_new.first(i, counter_bis);
                    sol_FEM.second(asm_map) = values_new.second(i, counter_bis);
                }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }

//std::cout<<"Using converting_into_FE_formulation: sol_FEM has to be already uploaded!"<<std::endl;
//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

        }

        template<typename LEVEL_SET, typename TRANSPORT_METHOD>
        void L2_proj_into_FE_formulation(LEVEL_SET &level_set, const Mesh &msh, const TRANSPORT_METHOD &method) {
            std::cout << "L2 projection to have CONTINUOUS FE: SimplicialLLT to invert global Mass Matrix." << std::endl;
            timecounter tc_vel;
            tc_vel.tic();
            Matrix<T, Dynamic, 1> RHS1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            Matrix<T, Dynamic, 1> RHS2 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            SimplicialLLT <SparseMatrix<T>> solver_global_mass;
            solver_global_mass.compute(method.Global_Mass);

            for (auto cl: msh.cells) {
                auto local_RHS = make_bernstein_local_RHS_VEC(msh, cl, degree_FEM, *this);
                size_t cell_offset = offset(msh, cl);
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    RHS1(asm_map_i) += local_RHS.first(i);
                    RHS2(asm_map_i) += local_RHS.second(i);
                }

            }
            sol_FEM.first = solver_global_mass.solve(RHS1);
            sol_FEM.second = solver_global_mass.solve(RHS2);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }

            tc_vel.toc();
//std::cout<<"Time to L2 project velocity field : "<<tc_vel<<std::endl;
        }

        template<typename MATRIX>
        void smooth_converting_into_FE_formulation(const MATRIX &values_new) {
//        std::cout<<"SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."<<std::endl;
            Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sum_first(asm_map) += values_new.first(i, counter_bis);
                    sum_second(asm_map) += values_new.second(i, counter_bis);
                    counting_avg(asm_map)++;
                }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
            sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
            sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
//        std::cout<<"In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

        }


        template<typename MATRIX>
        void weight_converting_into_FE_formulation(const MATRIX &values_new) {
//        std::cout<<"SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."<<std::endl;
            Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
            Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                T wLoc = weightsArea(counter_bis);

                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sum_first(asm_map) += wLoc * values_new.first(i, counter_bis);
                    sum_second(asm_map) += wLoc * values_new.second(i, counter_bis);
                    counting_avg(asm_map) += wLoc;
                }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
            }
            sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
            sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                    sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
                }

            }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
//        std::cout<<"In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

        }


        std::pair <T, T> operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree_FEM);
//std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
            auto values_cell_first = (sol_HHO.first.block(0, counter, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, counter, local_dim, 1)).col(0);
//std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
//std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));
//std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

            return std::make_pair(tmp1, tmp2);
        }


//  OPERATOR for MESH AGGLOMERATED
        std::pair <T, T> operator()(const point<T, 2> &pt) const {

            if (subcells.size() < 1) {

                assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = msh.cells[offset_old];

                cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl_old, degree_FEM);

                auto values_cell_first = (sol_HHO.first.block(0, offset_old, local_dim, 1)).col(0);
                auto values_cell_second = (sol_HHO.second.block(0, offset_old, local_dim, 1)).col(0);

                T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
                T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

                return std::make_pair(tmp1, tmp2);

            } else {
//            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
                auto offset = pt_in_subcell(msh, pt, agglo_LS_cl);
                auto subcl = msh.cells[offset];

                cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, subcl, degree_FEM);

                auto values_cell_first = (sol_HHO.first.block(0, offset, local_dim, 1)).col(0);
                auto values_cell_second = (sol_HHO.second.block(0, offset, local_dim, 1)).col(0);

                T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
                T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

                return std::make_pair(tmp1, tmp2);

            }

        }


        void upload_velocity(const std::string &filename_FEM0, const std::string &filename_FEM1) {
            size_t counter_FEM = 0;

            std::ifstream file_FEM0;
            file_FEM0.open(filename_FEM0, std::ios::in | std::ios::out);
            if (!file_FEM0.is_open()) {
                exit(10);
            }

            while (!file_FEM0.eof()) {
                if (counter_FEM < sol_FEM.first.size()) {
                    T val;
                    file_FEM0 >> val;
                    sol_FEM.first(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM0.close();



// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO.first(i, counter_HHO) = sol_FEM.first(asm_map);
                }
            }


            counter_FEM = 0;

            std::ifstream file_FEM1;
            file_FEM1.open(filename_FEM1, std::ios::in | std::ios::out);
            if (!file_FEM1.is_open()) {
                exit(10);
            }

            while (!file_FEM1.eof()) {
                if (counter_FEM < sol_FEM.second.size()) {
                    T val;
                    file_FEM1 >> val;
                    sol_FEM.second(counter_FEM) = val;

                    counter_FEM++;
//std::cout<<val <<" , " ;
                } else
                    break;

            }
            std::cout << std::endl;
            file_FEM1.close();



// Uploading also sol_HHO
            for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                    sol_HHO.second(i, counter_HHO) = sol_FEM.second(asm_map);
                }
            }


        }


    };


    template<typename Mesh>
    struct Current_Mesh {
        Mesh current_mesh;

        Current_Mesh(const Mesh &msh) : current_mesh(msh) {
        }

        void set_current_mesh(const Mesh &msh) {
            current_mesh = msh;
        }


    };


    template<typename T, typename Mesh, typename Level_Set, typename Fonction>
    struct LS_cell :
            public projected_level_set<T, Mesh, Fonction> {
        typedef typename Mesh::cell_type cell_type;
        cell_type agglo_LS_cl;
        std::vector <cell_type> subcells;
        Mesh agglo_msh;
        Level_Set level_set;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
        LS_cell(const Level_Set &level_set_, const Mesh &msh)
                : agglo_msh(msh), level_set(level_set_) {
        }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

//LS_cell()=default;

        T operator()(const point<T, 2> &pt) const {
            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set(pt, level_set.msh, cl_old);
            } else {
//std::cout<<"Ls operator"<<std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set(pt, level_set.msh, subcl);
            }

        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
            if (subcells.size() < 1) {
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal(pt, level_set.msh, cl_old);
            } else {

                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal(pt, level_set.msh, subcl);
            }
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
            if (subcells.size() < 1) {
                std::cout << "I m here 2.5 and size is " << agglo_LS_cl.user_data.offset_subcells.size() << std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient(pt, level_set.msh, cl_old);
            } else {
                std::cout << "Ls gradient" << std::endl;
                auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient(pt, level_set.msh, subcl);
            }

        }

        void cell_assignment(const cell_type &cl) {
            subcells.clear();
            agglo_LS_cl = cl;
            if (agglo_LS_cl.user_data.offset_subcells.size() > 1) {

                for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                    subcells.push_back(level_set.msh.cells[offset_subcells]);

                }
            }

        }

        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
            agglo_LS_cl = cl;
            return normal(pt);
        }

        T operator()(const point<T, 2> &pt, const cell_type &cl) {
            agglo_LS_cl = cl;
            return operator()(pt);
        }


//  void get_cell()
//  {
//      auto crr_cl = download_current_cell();
//      std::cout<<"IN get_cell.. size cell "<<crr_cl.user_data.offset_subcells.size()<<std::endl;
//      this->cell_assignment(crr_cl);
//   }

    };




    /**************MOVING INTERFACE: LEVEL SET METHOD  **************/

    template<typename T, typename Mesh>
    struct projection {
        Eigen::Matrix <T, Dynamic, Dynamic> values_bis;
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

        size_t degree_FEM;
        size_t number_elements;
        Mesh msh;
        size_t Nx, Ny;
        mesh_init_params <T> params;
//size_t  last_row_init, last_row_end, number_faces_one_row;

        projection(const Mesh &msh, size_t degree_k, const mesh_init_params <T> &params)
                : number_elements((degree_k + 1) * (degree_k + 1)), msh(msh), degree_FEM(degree_k), Nx(params.Nx),
                  Ny(params.Ny), params(params) {
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(((Nx + 1) * (Ny + 1)), 1);
            values_bis = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
        }

        projection() = default;


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            values_bis = values_new;
        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &vertices) {
            assert(degree_FEM == 1);
            for (size_t j = 0; j < values_bis.cols(); j++) {

                for (size_t i = 0; i < values_bis.rows(); i++) {
                    auto i_vertex = j + floor(j / Nx);
                    if (i == 0)
                        values_bis(i, j) = vertices(i_vertex);

                    if (i == 1)
                        values_bis(i, j) = vertices(i_vertex + 1);

                    if (i == (degree_FEM + 2))
                        values_bis(i, j) = vertices(i_vertex + Nx + 2);

                    if (i == (degree_FEM + 1))
                        values_bis(i, j) = vertices(i_vertex + Nx + 1);
                }
            }

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values) {
            assert(degree_FEM == 1);
            for (size_t j = 0; j < values_bis.cols(); j++) {

                for (size_t i = 0; i < values_bis.rows(); i++) {
                    auto i_vertex = j + floor(j / Nx);
                    if (i == 0)
                        vertices(i_vertex) = values(i, j);

                    if (i == 1)
                        vertices(i_vertex + 1) = values(i, j);

                    if (i == (degree_FEM + 2))
                        vertices(i_vertex + Nx + 2) = values(i, j);

                    if (i == (degree_FEM + 1))
                        vertices(i_vertex + Nx + 1) = values(i, j);
                }
            }

        }


        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);
        }

        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
            auto values_cell = values_bis.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
            ret(1) = values_cell.dot(grad_eval.col(1));
            return ret;
        }


        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }

    };


    template<typename T>
    void positive_part(Eigen::Matrix <T, Dynamic, Dynamic> &mat) {
        for (size_t i = 0; i < mat.rows(); i++) {
            for (size_t j = 0; j < mat.cols(); j++) {
                if (mat(i, j) < 0)
                    mat(i, j) = 0.;
            }
        }

    }





    template<typename T, typename Mesh>
    class entropy {
    public:
        virtual T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        }

        virtual T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        }

    };


    template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
    struct entropy_flux_ANALYTIC_VEL {
        T eps;
        Fonction phi;
        Mesh msh;
        Vel_Field u;
        Entropy_func E;

        Eigen::Matrix<T, Dynamic, 1> values0, values1;

        entropy_flux_ANALYTIC_VEL(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(
                E_entropy), phi(phi), u(u), msh(msh) {
            eps = E.eps;
//        values0 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        values1 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
//        auto ret = E.E_values + std::log10(eps)*One ;
//        values0 = u.sol_FEM.first.cwiseProduct(ret);
//        values1 = u.sol_FEM.second.cwiseProduct(ret);
        }

        std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T ret = E(pt, cl) + std::log10(eps);
            return std::make_pair(u(pt)[0] * ret, u(pt)[1] * ret);
        }
    };


    template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
    struct entropy_flux {
        T eps;
        Fonction phi;
        Mesh msh;
        Vel_Field u;
        Entropy_func E;

        Eigen::Matrix<T, Dynamic, 1> values0, values1;

        Eigen::Matrix <T, Dynamic, Dynamic> values0_HHO, values1_HHO;

        entropy_flux(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(E_entropy),
                                                                                                          phi(phi), u(u),
                                                                                                          msh(msh) {
            eps = E.eps;
            values0 = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            values1 = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);

            values0_HHO = Matrix<T, Dynamic, Dynamic>::Zero(u.local_dim, u.n_cls);
            values1_HHO = Matrix<T, Dynamic, Dynamic>::Zero(u.local_dim, u.n_cls);


            Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            auto ret = E.E_values + std::log10(eps) * One;
            values0 = u.sol_FEM.first.cwiseProduct(ret);
            values1 = u.sol_FEM.second.cwiseProduct(ret);

            Eigen::Matrix <T, Dynamic, Dynamic> One_Mat = Matrix<T, Dynamic, Dynamic>::Ones(u.local_dim, u.n_cls);
            auto ret_HHO = E.E_values_HHO + std::log10(eps) * One_Mat;

            values0_HHO = u.sol_HHO.first.cwiseProduct(ret_HHO);
            values1_HHO = u.sol_HHO.second.cwiseProduct(ret_HHO);
        }

        std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T ret = E(pt, cl) + std::log10(eps);
            return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
        }
    };


    template<typename Entropy_func, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
    struct entropy_flux_generic {
        T eps;
        Mesh msh;
        Vel_Field u;
        Entropy_func E;


        entropy_flux_generic(Entropy_func &E_entropy, const Vel_Field &u, const Mesh &msh) : E(E_entropy), u(u), msh(msh) {
            eps = E.eps;

        }

        std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T ret = E(pt, cl) + std::log10(eps);
            auto u_pt = u(pt, msh, cl);
            return std::make_pair((u_pt.first) * ret, (u_pt.second) * ret);
        }
    };


    template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
    struct entropy_flux_quadratic {
        T eps;
        Fonction phi;
        Mesh msh;
        Vel_Field u;
        Entropy_func E;

        Eigen::Matrix<T, Dynamic, 1> values0, values1;

        entropy_flux_quadratic(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(
                E_entropy), phi(phi), u(u), msh(msh) {
            eps = E.eps;

//        values0 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        values1 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
            auto ret = E.E_values;
            values0 = u.sol_FEM.first.cwiseProduct(ret);
            values1 = u.sol_FEM.second.cwiseProduct(ret);
        }

        std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T ret = E(pt, cl);
            return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
        }
    };


    template<typename Entropy_func, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
    struct entropy_flux_quadratic_piecewise {


        Mesh msh;
        Vel_Field u;
        Entropy_func E;


        entropy_flux_quadratic_piecewise(Entropy_func &E_entropy, const Vel_Field &u, const Mesh &msh) : E(E_entropy), u(u),
                                                                                                         msh(msh) {


        }

        std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T ret = E(pt, cl);
            return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
        }
    };


    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy_new :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;
        Eigen::Matrix<T, Dynamic, 1> E_values, E_der;

        non_linear_entropy_new(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;
            E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Log10 *= std::log(10);

            E_values = -((((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).cwiseAbs() + eps * One).array().log10());

            E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            E_der = (-One.cwiseQuotient(
                    (((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                            Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
            E_der = (E_der.array().cwiseProduct(((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).array().sign()));
            E_der = (E_der.cwiseProduct(One - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;

        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs(f(pt, msh, cl) * (1 - f(pt, msh, cl))) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs(phi(pt, msh, cl) * (1 - phi(pt, msh, cl))) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
            return -1. / ((std::abs((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) + eps) * std::log(10)) *
                   sgn((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) * (1 - 2 * phi(pt, msh, cl));
        }

    };


    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy_new_phimin_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;
        Eigen::Matrix<T, Dynamic, 1> E_values, E_der;
        Eigen::Matrix <T, Dynamic, Dynamic> E_values_HHO, E_der_HHO;

        non_linear_entropy_new_phimin_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;
            E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Log10 *= std::log(10);
            Eigen::Matrix<T, Dynamic, 1> PHI_MAX = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> PHI_MIN = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            PHI_MAX *= phi_max;
            PHI_MIN *= phi_min;

            E_values = -((((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() +
                          eps * One).array().log10());

            E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            E_der = (-One.cwiseQuotient(
                    (((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                            Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
            E_der = (E_der.array().cwiseProduct(
                    ((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).array().sign()));
            E_der = (E_der.cwiseProduct(PHI_MAX + PHI_MIN - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;



            E_values_HHO = Matrix<T, Dynamic, Dynamic>::Zero(phi.local_dim, phi.n_cls);
            Eigen::Matrix <T, Dynamic, Dynamic> One_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
            Eigen::Matrix <T, Dynamic, Dynamic> Log10_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
            Log10_HHO *= std::log(10);
            Eigen::Matrix <T, Dynamic, Dynamic> PHI_MAX_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
            Eigen::Matrix <T, Dynamic, Dynamic> PHI_MIN_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
            PHI_MAX_HHO *= phi_max;
            PHI_MIN_HHO *= phi_min;

            E_values_HHO = -((((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).cwiseAbs() +
                              eps * One_HHO).array().log10());

            E_der_HHO = Matrix<T, Dynamic, Dynamic>::Zero(phi.local_dim, phi.n_cls);
            E_der_HHO = (-One_HHO.cwiseQuotient(
                    (((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).cwiseAbs() +
                     eps * One_HHO).cwiseProduct(
                            Log10_HHO)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
            E_der_HHO = (E_der_HHO.array().cwiseProduct(
                    ((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).array().sign()));
            E_der_HHO = (E_der_HHO.cwiseProduct(PHI_MAX_HHO + PHI_MIN_HHO - 2 * phi.sol_HHO));

        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
            return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
                   sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
                   (phi_max + phi_min - 2 * phi(pt, msh, cl));
        }

    };

    template<typename T, typename Fonction, typename Mesh>
    struct entropy_log_phimin_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;

        entropy_log_phimin_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;

        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            auto f_pt = f(pt, msh, cl);
            return -std::log10(std::abs((f_pt - phi_min) * (phi_max - f_pt)) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            auto phi_pt = phi(pt, msh, cl);
            return -std::log10(std::abs((phi_pt - phi_min) * (phi_max - phi_pt)) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            auto phi_pt = phi(pt, msh, cl);
            return -1. / ((std::abs((phi_max - phi_pt) * (phi_pt - phi_min)) + eps) * std::log(10)) *
                   sgn((phi_max - phi_pt) * (phi_pt - phi_min)) * (phi_max + phi_min - 2.0 * phi_pt);
        }

    };


    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy_new_phimax_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;
        Eigen::Matrix<T, Dynamic, 1> E_values, E_der;

        non_linear_entropy_new_phimax_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = -phi.phi_max;
            E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Log10 *= std::log(10);
            Eigen::Matrix<T, Dynamic, 1> PHI_MAX = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            Eigen::Matrix<T, Dynamic, 1> PHI_MIN = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
            PHI_MAX *= phi_max;
            PHI_MIN *= phi_min;

            E_values = -((((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() +
                          eps * One).array().log10());

            E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
            E_der = (-One.cwiseQuotient(
                    (((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                            Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
            E_der = (E_der.array().cwiseProduct(
                    ((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).array().sign()));
            E_der = (E_der.cwiseProduct(PHI_MAX + PHI_MIN - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;

        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
            return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
                   sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
                   (phi_max + phi_min - 2 * phi(pt, msh, cl));
        }

    };


    template<typename T, typename Fonction, typename Mesh>
    struct entropy_log_phimax_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;


        entropy_log_phimax_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = -phi.phi_max;


        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
            return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
                   sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
                   (phi_max + phi_min - 2 * phi(pt, msh, cl));
        }

    };


    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy_quadratic_piecewise_phimin_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;

        T coeff1, coeff2;
        T pol_order;

        non_linear_entropy_quadratic_piecewise_phimin_phimax(T max_val, const Fonction &phi, const Mesh &msh, T pol_order)
                : eps(eps), phi(phi), msh(msh), pol_order(pol_order) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;


            coeff1 = max_val / (pow(phi_min, pol_order));

            coeff2 = max_val / (pow(phi_max, pol_order));


        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T val = f(pt, msh, cl);
            return (val < 0) ? pow(val, pol_order) * coeff1 : pow(val, pol_order) * coeff2;


        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T val = phi(pt, msh, cl);
            return (val < 0) ? pow(val, pol_order) * coeff1 : pow(val, pol_order) * coeff2;
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            T val = phi(pt, msh, cl);
            return (val < 0) ? (pol_order - 1.0) * pow(val, pol_order - 1) * coeff1 : (pol_order - 1.0) *
                                                                                      pow(val, pol_order - 1) * coeff2;

        }

    };

    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy_quadratic_phimin_phimax :
            public entropy<T, Mesh> {
        T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;
        Eigen::Matrix<T, Dynamic, 1> E_values, E_der;
        T coeff1, coeff2;
        T E0;

        non_linear_entropy_quadratic_phimin_phimax(T max_val, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi),
                                                                                                      msh(msh) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;
            auto phi_FEM = phi.sol_FEM;

            coeff1 = max_val / (phi_min * phi_min);

//        coeff2 = max_val / (phi_max*phi_max) ;

            E_values = phi_FEM.cwiseProduct(phi_FEM) * coeff1;

            E_der = 2.0 * coeff1 * phi_FEM;

            E0 = 0.0;

        }

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return f(pt, msh, cl) * f(pt, msh, cl) * coeff1;

        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return phi(pt, msh, cl) * phi(pt, msh, cl) * coeff1;
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {

            return phi(pt, msh, cl) * 2.0 * coeff1;;
        }

    };


    template<typename T, typename Fonction, typename Mesh>
    struct non_linear_entropy :
            public entropy<T, Mesh> {
        const T eps;
        Fonction phi;
        T phi_max, phi_min;
        Mesh msh;

        non_linear_entropy(const T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
            phi_max = phi.phi_max;
            phi_min = phi.phi_min;

        }

/// THIS WAS FOR A GENERAL PHI, RE-WRITTEN FOR PHI BETWEEN 0 AND 1
/*
    T operator()(const Fonction& f, const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-f(pt,msh,cl))*(f(pt,msh,cl)-phi_min) ) + eps );
    }

    T operator()(const point<T,2>& pt , const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min) ) + eps );
    }

    T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
       // std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1./(( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) +eps)*std::log(10)) * sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) * ( phi_max - 2*phi(pt,msh,cl) + phi_min ) ;
    }
    */

        T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs(f(pt, msh, cl) * (1 - f(pt, msh, cl))) + eps);
        }

        T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
            return -std::log10(std::abs(phi(pt, msh, cl) * (1 - phi(pt, msh, cl))) + eps);
        }

        T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
            return -1. / ((std::abs((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) + eps) * std::log(10)) *
                   sgn((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) * (1 - 2 * phi(pt, msh, cl));
        }

    };


    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    Matrix <T, Dynamic, Dynamic>
    make_lagrange_local_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
            ret += qp.second * phi * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
        }
//ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

        return ret;
    }

    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    Matrix <T, Dynamic, Dynamic>
    make_lagrange_lumped_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

        auto qps = integrate(msh, cl, 2 * (degree + di));

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);
            ret += qp.second * phi;
        }

        return ret;
    }

    template<typename Mesh, typename T = typename Mesh::coordinate_type>
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
    make_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
        auto cbs = cb.size();

        Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
        Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
        auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

        for (auto &qp: qps) {
            auto phi = cb.eval_basis(qp.first);

            auto phi_grad = cb.eval_gradients(qp.first);

            ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

            ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
        }

        return std::make_pair(ret0, ret1);
    }


    template<typename VECTOR, typename Mesh, typename MATRIX, typename T = typename Mesh::coordinate_type>
    Matrix<T, Dynamic, 1> make_dij_vector(const Mesh &msh, const MATRIX &dij, const VECTOR &phi_old) {
        Matrix<T, Dynamic, 1> ret = Eigen::Matrix<T, Dynamic, 1>::Zero(dij.rows(), 1);


        for (size_t i = 0; i < dij.rows(); i++) {
            auto tmp = (dij.row(i)).adjoint();
            ret(i) = tmp.dot(phi_old) - tmp(i) * (phi_old(i));
        }
        return ret;
    }

    template<typename VECTOR, typename T>
    Matrix<T, Dynamic, 1>
    solveFEM(const VECTOR &lumped_mass, const VECTOR &conv, const VECTOR &last_term, const VECTOR &phi_old, T dt,
             const std::vector <size_t> &bdry_nodes) {
/*
    Matrix<T, Dynamic, 1> sol =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    size_t j = 0;
    for (size_t i = 0 ; i < phi_old.rows() ; i++ ) {
        if( i == bdry_nodes.at(j) ){
            sol(i) = phi_old(i);
            j++; // I can do since bdry_nodes is ordered
        }
        else
           sol(i) = phi_old(i) - dt * conv(i)/( lumped_mass(i) ) + dt * last_term(i)/( lumped_mass(i) );
    }
    return sol;
    */
// if I dont consider boundary condition here, but just solve for all


        return phi_old - dt * conv.cwiseQuotient(lumped_mass) + dt * last_term.cwiseQuotient(lumped_mass);

    }


    template<typename Fonction, typename VECTOR, typename MATRIX, typename T>
    Matrix<T, Dynamic, 1>
    solveFEM_Entropic(const MATRIX &mass, const VECTOR &conv, const VECTOR &last_term, const Fonction &phi_old, T dt) {
// if I dont consider boundary condition here, but just solve for all-> look to solveFEM
        auto b = phi_old - dt * conv + dt * last_term;

        return mass.completeOrthogonalDecomposition().solve(b);


    }

    template<typename Fonction, typename VECTOR, typename MATRIX, typename T>
    Matrix<T, Dynamic, 1>
    solveFEM_Entropic_FAST(const MATRIX &llt, const VECTOR &conv, const VECTOR &last_term, const Fonction &phi_old, T dt) {
// if I dont consider boundary condition here, but just solve for all-> look to solveFEM
        auto b = phi_old - dt * conv + dt * last_term;

        return llt.solve(b);


    }




    template<typename T, typename Mesh>
    class Finite_Element {
    public:

        Mesh msh_last;
        Mesh msh_next;

        Mesh msh; // Original mesh, not agglomerated
// number of degree of freedom (HHO setting) , #vertices , #cells
        size_t ndof_disc, n_vertices, n_cls;
        size_t ndof_FE; // number of degree of freedom (Continuous FEM setting)
        size_t num_faces = 4; // #faces
        mesh_init_params <T> params; // parameters mesh
        size_t order; // FE order of polynomial B^k
        size_t local_ndof; // local degree of freedom


        size_t Nx, Ny; // number of cells in x and y direction
        T hx; // step size along x direction
        T hy; // step size along y direction

        std::vector <std::set<size_t>> S_i;
        typedef typename Mesh::point_type point_type;
        typedef typename Mesh::cell_type cell_type;
        std::vector <std::pair<std::pair < point_type, cell_type>, std::map<size_t, std::pair < point_type, cell_type>> > >
        S_pt_cell;


//std::map<size_t , std::pair<typename Mesh::point_type , typename Mesh::cell_type > >>
        std::vector <std::vector<std::pair < size_t, bool>>>
        connectivity_matrix;

        std::vector<bool> Dirichlet_boundary; //(ndof_FE , FALSE );
        std::vector<bool> Dirichlet_boundary_inlet; //(ndof_FE , FALSE );

        Finite_Element(Mesh &other_msh, size_t order, const mesh_init_params <T> &params) : msh(other_msh), n_vertices(
                other_msh.nodes.size()), n_cls(other_msh.cells.size()), order(order), local_ndof((order + 1) * (order + 1)),
                                                                                            hx(params.hx()),
                                                                                            hy(params.hy()),
                                                                                            connectivity_matrix(n_cls,
                                                                                                                std::vector <
                                                                                                                std::pair <
                                                                                                                size_t, bool
                                                                                                                        >> (local_ndof)),
                                                                                            Nx(params.Nx), Ny(params.Ny),
                                                                                            params(params) {


            ndof_disc = n_vertices * n_cls;

//std::cout<<"n_vertices "<<n_vertices<<" , n_cls "<<n_cls<<" , ndof_disc "<<ndof_disc<<std::endl;
            if (order == 0)
                ndof_FE = msh.cells.size();

            size_t counter = 0, i_global = 0;
            for (const auto &cl: msh.cells) {

                if (order == 0) {
                    ndof_FE = msh.cells.size();
                    connectivity_matrix[counter][0].first = counter;
                    connectivity_matrix[counter][0].second = false;

                } else {


                    std::vector <size_t> loc_bdry_nodes;
                    auto fcs = faces(msh, cl);
                    for (size_t face_i = 0; face_i < num_faces; face_i++) {
                        auto fc = fcs[face_i];
//std::cout<<"fc is "<<fc<<std::endl;
// In HHO flow problem I can have different types of boundary;
// For level set evolution, I just focus on Dirichelet boundary
// The indication of the type of boundary in fc is relative to HHO problem, so useless now
                        if (fc.is_boundary) {
                            if (face_i == 0) {
                                loc_bdry_nodes.push_back(0);
                                loc_bdry_nodes.push_back(1);

                                if (order > 1) {
                                    for (size_t j = 0; j <= order - 2; j++)
                                        loc_bdry_nodes.push_back(4 + j);
                                }

                            } else if (face_i == 1) {
                                loc_bdry_nodes.push_back(1);
                                loc_bdry_nodes.push_back(2);
                                if (order > 1) {
                                    for (size_t j = 0; j <= order - 2; j++)
                                        loc_bdry_nodes.push_back(order + 3 + j);
                                }
                            } else if (face_i == 2) {
                                loc_bdry_nodes.push_back(2);
                                loc_bdry_nodes.push_back(3);
                                if (order > 1) {
                                    for (size_t j = 0; j <= order - 2; j++)
                                        loc_bdry_nodes.push_back(2 * order + 2 + j);
                                }
                            } else if (face_i == 3) {
                                loc_bdry_nodes.push_back(0);
                                loc_bdry_nodes.push_back(3);
                                if (order > 1) {
                                    for (size_t j = 0; j <= order - 2; j++)
                                        loc_bdry_nodes.push_back(3 * order + 1 + j);
                                }

                            } else
                                exit(1);

                        }

                    }

                    size_t offset_curr = offset(msh, cl);
                    sort(loc_bdry_nodes.begin(), loc_bdry_nodes.end());
                    loc_bdry_nodes.erase(unique(loc_bdry_nodes.begin(), loc_bdry_nodes.end()), loc_bdry_nodes.end());





//std::cout<<"loc_bdry_nodes "<<std::endl;
//for(auto i : loc_bdry_nodes)
//    std::cout<<i<<" , ";
//std::cout<<std::endl;

                    for (size_t i_local = 0; i_local < local_ndof; i_local++) {
// if boundary = TRUE is node on the boudnary , else not
                        bool boundary = binary_search(loc_bdry_nodes.begin(), loc_bdry_nodes.end(), i_local);

// Case: first cell
                        if (offset_curr == 0) {
                            connectivity_matrix[counter][i_local].first = i_global;
                            connectivity_matrix[counter][i_local].second = boundary;
                            i_global++;
                        }

// Case: First row of cells, a part of cell[0]
// Left face enumeration for cell i = Right face enumeration for cell i-1
                        else if (offset_curr > 0 && offset_curr < Nx) {
                            if (i_local == 0) { // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][1].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local == 3) { // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][2].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local >= 3 * order + 1 && i_local <= 4 * order - 1) // nodes in face 3
                            {
// how many points i_local is distant from v3 vertices
// Idea is f1 of cell[counter-1] = f2 of cell[counter] (i.e. = means same ordering). It means:
//    face 1             face 3
// 2*ordering + 1 ---- 3*ordering + 1
//    |                      |
//    |                      |
//    |                      |
//  ordering + 3  ---- 4*ordering - 1

                                size_t dist_v3 = i_local - (3 * order + 1);
                                size_t j = 2 * order + 1 - dist_v3;
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][j].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else {
                                connectivity_matrix[counter][i_local].first = i_global;
                                connectivity_matrix[counter][i_local].second = boundary;
                                i_global++;
                            }

                        }

// Case: Left Boundary cells
// Bottom face enumeration for cell i = Top face enumeration for cell i-Nx
                        else if (offset_curr % Nx == 0 && offset_curr > 0) {
                            if (i_local == 0) { // vertex 3 of cell[counter-Nx] = vertex 0 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][3].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local == 1) { // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][2].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local >= 4 && i_local <= order + 2) // nodes in face 0
                            {
// how many points i_local is distant from v0 vertices
// Idea is f2 of cell[counter-Nx] = f0 of cell[counter] (i.e. = means same ordering). It means:
//         face 0 ; cell[counter]
//     4        ----     ordering + 2
//     |                      |
//         face 2 ; cell[counter-Nx]
//     |                      |
//  3*ordering  ----    2*ordering +2

                                size_t dist_v0 = i_local - 4;
                                size_t j = 3 * order - dist_v0;
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][j].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else {
                                connectivity_matrix[counter][i_local].first = i_global;
                                connectivity_matrix[counter][i_local].second = boundary;
                                i_global++;
                            }
                        }

// All the other cells ( i.e. internal and right boundary cells ) are both 2 the cases
                        else {
                            if (i_local == 0) { // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][1].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local == 3) { // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][2].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local == 1) { // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][2].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local >= 3 * order + 1 && i_local <= 4 * order - 1) // nodes in face 3
                            {
                                size_t dist_v3 = i_local - (3 * order + 1);
                                size_t j = 2 * order + 1 - dist_v3;
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][j].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else if (i_local >= 4 && i_local <= order + 2) // nodes in face 0
                            {
                                size_t dist_v0 = i_local - 4;
                                size_t j = 3 * order - dist_v0;
                                connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][j].first;
                                connectivity_matrix[counter][i_local].second = boundary;
                            } else {
                                connectivity_matrix[counter][i_local].first = i_global;
                                connectivity_matrix[counter][i_local].second = boundary;
                                i_global++;
                            }
                        }

                    } // End of local loop for each cell
                }
                counter++;

            } // End of loop over the cells.


            if (order == 0)
                ndof_FE = msh.cells.size();
            else
                ndof_FE = i_global;

            S_i.resize(ndof_FE);
            Dirichlet_boundary.resize(ndof_FE);
            Dirichlet_boundary_inlet.resize(ndof_FE);

            S_pt_cell.resize(ndof_FE);

            for (auto &cl: msh.cells) {
                auto offset_cl = offset(msh, cl);
                auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, order);
                for (size_t i = 0; i < local_ndof; i++) {
                    auto asm_map_i = connectivity_matrix[offset_cl][i].first;
                    S_pt_cell[asm_map_i].first = std::make_pair(qps[i], cl);
                    for (size_t j = 0; j < local_ndof; j++) {
                        auto asm_map_j = connectivity_matrix[offset_cl][j].first;
                        S_i[asm_map_i].insert(asm_map_j);

                        S_pt_cell[asm_map_i].second.insert(std::make_pair(asm_map_j, std::make_pair(qps[j], cl)));
//( std::make_pair(qps(i),cl) , std::make_pair(qps(j),cl) ) ;

                    }
                }
            }


/*
        size_t size_supp_nodes = 0;
        std::cout<<"Supporting nodes IN FE METHOD:"<<std::endl;
        size_t jjjj = 0;
        for (auto& i: S_i) {
            size_supp_nodes+=i.size();
            std::cout <<"Node "<<jjjj<<":";
            for (auto it=i.begin(); it != i.end(); ++it)
                std::cout << ' ' << *it;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
        std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;


        jjjj = 0;
        for (auto& i: S_pt_cell) {

            std::cout <<"Node "<<jjjj<<" = ( "<<S_pt_cell[jjjj].first.first<<" , "<< offset(msh,S_pt_cell[jjjj].first.second)<<" ) "<<std::endl;
            for (auto it=i.second.begin(); it != i.second.end(); ++it)
                std::cout << '\t'<<" j = "<< it->first << " -> ( " << it->second.first<<" , "<< offset(msh, it->second.second)<<" ) "<<std::endl;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
         */
//        std::cout<<"Beginning of connectivity matrix"<<std::endl;



// Dirichlet boundary vector
            for (size_t i = 0; i < n_cls; i++) {
                for (size_t j = 0; j < local_ndof; j++) {
//                std::cout<<"( "<<connectivity_matrix[i][j].first<<" , "<<connectivity_matrix[i][j].second<<" ) , ";
                    auto asmap = connectivity_matrix[i][j];
                    Dirichlet_boundary[asmap.first] = asmap.second;
//std::cout<<"Node "<<asmap.first << " is Dirichlet "<<asmap.second<< "  ,  ";
                }
//            std::cout<<std::endl;
            }
//        std::cout<<std::endl;
//        std::cout<<"End of connectivity matrix"<<std::endl;






        }

        Finite_Element(const Finite_Element &other) {
            msh_last = other.msh_last;
            msh_next = other.msh_next;
            msh = other.msh;
            ndof_disc = other.ndof_disc;
            n_vertices = other.n_vertices;
            n_cls = other.n_cls;
            ndof_FE = other.ndof_FE;
            num_faces = other.num_faces;
            params = other.params;
            order = other.order;
            local_ndof = other.local_ndof;


            Nx = other.Nx;
            Ny = other.Ny;
            hx = other.hx;
            hy = other.hy;

            S_i = other.S_i;
            S_pt_cell = other.S_pt_cell;


            connectivity_matrix = other.connectivity_matrix;

            Dirichlet_boundary = other.Dirichlet_boundary;
            Dirichlet_boundary_inlet = other.Dirichlet_boundary_inlet;

        }

        Finite_Element() = default;

// It returns a vector in which each element is a pair (offset cell mesh at t^N , offset integration cell at t^0 )
// Notice that the first element is useful for the basis, the second for the quadrature domain.
        std::vector <std::pair<size_t, size_t>>
        mapping_S(const typename Mesh::cell_type &cl) const {
// cl is in the agglo_mesh at time t+1 -> msh_next
//auto i = offset(msh,cl) ;
//auto S_i = cl.user_data.offset_subcells ;

            std::vector <std::pair<size_t, size_t>> ret;
            size_t i_cl_next = offset(msh_next, cl);
// For each cell of the agglo mesh t^{N+1}, loop the original subcells K_i of mesh t^0
            for (auto &i: cl.user_data.offset_subcells) {

//std::cout<<"i = "<<i<<std::endl;
                if ((cl.user_data.offset_subcells[0] == cl.user_data.offset_subcells[1])) {
                    size_t posp = i_cl_next + 1;
                    size_t pospp = i_cl_next + Nx - 1;
                    int posn = i_cl_next;
                    int posnn = i_cl_next - Nx + 1;
                    int limit_inf = i_cl_next - Nx + 1;
                    int limit_sup = i_cl_next + Nx - 1;
//for( auto& cl_last : msh_last.cells )
                    while (posn > limit_inf || pospp < msh_last.cells.size() || posnn >= 0 || posp < limit_sup) {
                        if (ret.size() == 1)
                            break;

//std::cout<<"posn = "<<posn<<" and i - Nx + 1 = "<<i - Nx + 1<<std::endl;
                        if (posn > limit_inf && posp < msh_last.cells.size()) {
                            auto cl_lastn = msh_last.cells[posn];
                            for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"i_last_n = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                    break;
                                }
                            }
                        }
                        if (ret.size() == 1)
                            break;

                        if (posnn >= 0 && posp < msh_last.cells.size()) {
                            auto cl_lastn = msh_last.cells[posnn];
                            for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"i_last_nn = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                    break;
                                }
                            }
                        }
                        if (ret.size() == 1)
                            break;


                        if (posp < limit_sup && posp < msh_last.cells.size()) {
                            auto cl_lastp = msh_last.cells[posp];
                            for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"i_last_p = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                    break;
                                }
                            }
                        }
                        if (ret.size() == 1)
                            break;

                        if (pospp < msh_last.cells.size()) {
                            auto cl_lastp = msh_last.cells[pospp];
                            for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"i_last_pp = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                    break;
                                }
                            }
                        }
                        if (ret.size() == 1)
                            break;


                        posp++;
                        posn--;
                        pospp++;
                        posnn--;
                    }
                    break;

                } else {
//for( auto& cl_last : msh_last.cells )
                    size_t posp = i_cl_next + 1;
                    size_t pospp = i_cl_next + Nx - 1;
                    int posn = i_cl_next;
                    int posnn = i_cl_next - Nx + 1;
                    int limit_inf = i_cl_next - Nx + 1;
                    int limit_sup = i_cl_next + Nx - 1;


                    while (posn > limit_inf || pospp < msh_last.cells.size() || posnn >= 0 || posp < limit_sup) {
                        bool cell_n_found = FALSE;
                        if (ret.size() == cl.user_data.offset_subcells.size()) // || ret ==  cl.user_data.offset_subcells )
                            break;


                        if (posn > limit_inf && posp < msh_last.cells.size()) {
                            auto cl_lastn = msh_last.cells[posn];
                            for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_n = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                    cell_n_found = TRUE;
                                    break;
                                }
                            }
                        }
                        if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                            break;


                        if (posnn >= 0 && posp < msh_last.cells.size()) {
                            auto cl_lastn = msh_last.cells[posnn];
                            for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_nn = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                    cell_n_found = TRUE;
                                    break;
                                }
                            }
                        }
                        if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                            break;


                        if (posp < limit_sup && posp < msh_last.cells.size()) {
                            auto cl_lastp = msh_last.cells[posp];
                            for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_p = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                    cell_n_found = TRUE;
                                    break;
                                }
                            }
                        }
                        if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                            break;

                        if (pospp < msh_last.cells.size()) {
                            auto cl_lastp = msh_last.cells[pospp];
                            for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_pp = "<<i_last<<std::endl;
                                if (i_last == i) {
                                    ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                    cell_n_found = TRUE;
                                    break;
                                }
                            }
                        }
                        if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                            break;


                        posp++;
                        posn--;
                        pospp++;
                        posnn--;
                    }


                }


            }
            return ret;
        }



//void
//assembling(SparseMatrix<T>& Global_Mass ,SparseMatrix<T>& Global_c_term_x ,SparseMatrix<T>& Global_c_term_y, DiagonalMatrix<T, Dynamic>& Global_Mass_Lumped , Matrix<T, Dynamic, 1>& RHS){


// }

/*
    size_t get_order() const { return order; }
    size_t get_n_nodes() const { return n_nodes; }
    size_t get_n_cells() const { return n_cls; }
    size_t get_hx() const { return hx; }
    size_t get_hy() const { return hy; }
    size_t get_Nx() const { return Nx; }
    size_t get_Ny() const { return Ny; }
    size_t get_local_ndof() const { return local_ndof; }
    size_t get_ndof() const { return ndof; }
    */
    };


    template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
    void global_update_vector(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
            global(kk) += local(i);
            i++;
        }

    }


    template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
    void global_update_vector_NOSUM(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
            global(kk) = local(i);
            i++;
        }

    }


    template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
    void global_update_vector_MAX(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
            auto max_glob = global(kk);
            global(kk) = std::max(local(i), max_glob);
            i++;
        }

    }

    template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
    void global_update_vector_MIN(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
            auto min_glob = global(kk);
            global(kk) = std::min(local(i), min_glob);
            i++;
        }

    }


    template<typename MATRIX_LOC, typename MATRIX_GLOB, typename NODES>
    void global_update_NOSUM(const MATRIX_LOC &local, MATRIX_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t j = 0;
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;

            for (auto &l: nodes_position) {
                size_t ll = l.ptid;

//std::cout<<"colonna "<<ll<<std::endl;
//std::cout<<"j "<<j<<std::endl;
                global(kk, ll) = local(i, j);
                j++;
            }
            i++;

        }

    }


    template<typename MATRIX_LOC, typename MATRIX_GLOB, typename NODES>
    void global_update(const MATRIX_LOC &local, MATRIX_GLOB &global, const NODES &nodes_position) {
        size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
        for (auto &k: nodes_position) {
            size_t j = 0;
            size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;

            for (auto &l: nodes_position) {
                size_t ll = l.ptid;

//std::cout<<"colonna "<<ll<<std::endl;
//std::cout<<"j "<<j<<std::endl;
                global(kk, ll) += local(i, j);
                j++;
            }
            i++;

        }

    }



    std::vector <size_t> boundary_nodes_function(size_t Nx, size_t Ny) {
// IT WORKS ONLY FOR Q1!!!
        std::vector <size_t> bdry_nodes;
        for (size_t j = 1; j <= Ny; j++) {
            bdry_nodes.push_back(j * (Nx + 1) - 1);
            bdry_nodes.push_back(j * (Nx + 1));
        }
        for (size_t j = 1; j < Nx; j++) {
            bdry_nodes.push_back(j);
            bdry_nodes.push_back(Ny * (Nx + 1) + j);
        }
        bdry_nodes.push_back(0);
        bdry_nodes.push_back((Ny + 1) * (Nx + 1) - 1);
        std::sort(bdry_nodes.begin(), bdry_nodes.end());

        return bdry_nodes;
    }


    template<typename Node, typename SUPP_NODES>
    void supporting_nodes(SUPP_NODES &ret, const Node &nodes_position) {

        for (auto &i: nodes_position) {
            for (auto &j: nodes_position) {
                (ret.at(i.ptid)).insert(j.ptid);
//    std::cout<<"ret("<<i.ptid<<") is "<<j<<std::endl;
            }
//std::sort(ret(i.ptid).begin(), ret(i.ptid).end() ); // set already increasing ordered
        }

    }


    template<typename Node, typename MATRIX>
    void division_Si(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(counter, elem) = mat1(counter, elem) / mat2(counter, elem);
            }
            counter++;
        }
    }

    template<typename Node, typename MATRIX>
    void division_Si_T(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(elem, counter) = mat1(elem, counter) / mat2(elem, counter);
            }
            counter++;
        }
    }

    template<typename Node, typename MATRIX>
    void moltiplication_Si_T(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(elem, counter) += (mat1(elem, counter) * mat2(elem, counter));
            }
            counter++;
        }
    }


    template<typename Node, typename MATRIX>
    void moltiplication_Si(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(counter, elem) += (mat1(counter, elem) * mat2(counter, elem));
            }
            counter++;
        }
    }

    template<typename Node, typename MATRIX, typename VECTOR>
    void sum_Si(const Node &S_i, const MATRIX &mat, const VECTOR &vec, VECTOR &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(counter) += mat(counter, elem) * vec(elem);
            }
            counter++;
        }
    }

    template<typename Node, typename MATRIX, typename VECTOR>
    void averaged_sum_Si(const Node &S_i, const MATRIX &mat, const VECTOR &vec, VECTOR &sol) {
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                sol(counter) += mat(counter, elem) * (vec(elem) - vec(counter));
            }
            counter++;
        }
    }



    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Transport_Method, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                                       Fonction &phi, Vel_Field &u,
                                                                       const Transport_Method &method, T &dt) {
// Starting time for FE calculation
//    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND) -----------"<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;
//    std::cout<<"u0"<<'\n'<<u0<<'\n'<<std::endl;
//    std::cout<<"u0_cellwise"<<'\n'<<u0_cellwise<<std::endl;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;





// VANDERMONDE MATRIX INTERPOLATION
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                auto phi_pt = phi(pts[i], msh, cl);
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi_pt;
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi_pt;

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


//    tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



//    timecounter tc_case00;
//    tc_case00.tic();



// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;
        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            for (auto &elem: row_i) {
                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem) {
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                    term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
                }


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
            counter_row++;


        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
        auto CFL_numb = std::make_pair(10,
                                       1); //time_step_CFL_OK( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );



//    std::cout<<"------------------------------------UNSTEADY STOKES CFL COND PROVA!!!!! "<<std::endl;
//    T CFL_numb = time_step_CFL_unstesdy_Stokes( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;

        size_t counter_dir = 0;
        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {

//std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
            if (dir_elem) {
                phi_L(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }








// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_L;
        phi.converting_into_HHO_formulation(phi_L);



//    tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


//    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



//return phi_tilde;
        return CFL_numb;
    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Transport_Method, typename T = typename Mesh::coordinate_type>
    void
    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                                       Fonction &phi, Vel_Field &u,
                                                                       const Transport_Method &method, T &dt,
                                                                       const FiniteSpace &fe_data_u) {
// Starting time for FE calculation
        std::cout << "----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND - VEL L^\tilde{k}) -----------"
                  << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

        timecounter tc;
        tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;

        auto S_pt_cell = fe_data.S_pt_cell;

//size_t degree_u = fe_data_u.order; // finite element order
//size_t dim_u = fe_data_u.ndof_FE ;
//size_t n_cls = fe_data.n_cls ;
//size_t local_ndof_u = fe_data_u.local_ndof ; // local degrees of freedom
//auto S_i_u = fe_data_u.S_i;
//auto S_pt_cell_u = fe_data_u.S_pt_cell ;
//std::cout<<"HP: DoF velocity > DoF level set . "<<std::endl;
//if( degree_u > degree)
//    exit(10) ;

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;





// VANDERMONDE MATRIX INTERPOLATION
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        timecounter tc_solver2;
        tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);

            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u(pts[i], msh, cl).first * phi(pts[i], msh, cl);
                flux1_loc(i) = u(pts[i], msh, cl).second * phi(pts[i], msh, cl);

            }


            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


        tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



        timecounter tc_case00;
        tc_case00.tic();



// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;
        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter_row = 0;
        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            for (auto &elem: row_i.second) {
                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;
                T value0 = std::abs(u(pt_i, msh, cl_i).first * nij0.coeff(counter_row, elem_j) +
                                    u(pt_i, msh, cl_i).second * nij1.coeff(counter_row, elem_j));
                T value1 = std::abs(u(pt_j, msh, cl_j).first * nij0.coeff(counter_row, elem_j) +
                                    u(pt_j, msh, cl_j).second * nij1.coeff(counter_row, elem_j));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(u(pt_i, msh, cl_i).first * nji0.coeff(counter_row, elem_j) +
                                        u(pt_i, msh, cl_i).second * nji1.coeff(counter_row, elem_j));
                T value_adj1 = std::abs(u(pt_j, msh, cl_j).first * nji0.coeff(counter_row, elem_j) +
                                        u(pt_j, msh, cl_j).second * nji1.coeff(counter_row, elem_j));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem_j) {
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));
                    term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem_j) - phi_FEM(counter_row));
                }


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
            counter_row++;


        }
        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();
/*
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
     dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );

     triplets_dij.clear();
    */





        tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
        T dt_old = dt;
        std::cout << "CHECKING OF CFL CONDITION (ALEXANDRE BOOK):" << std::endl;
        T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet,
                                                   dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;
        std::cout << "CFL condition ---------> dt =  " << CFL_numb << std::endl;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
/*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_L;
        phi.converting_into_HHO_formulation(phi_L);


        tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


        std::cout << "----------- FINE TRANSPORT PROBLEM -----------" << std::endl;



//return phi_tilde;

    }



    template<typename VEC, typename DIAG, typename T>
    T time_step_CFL_unstesdy_Stokes(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary,
                                    T &dt) {
        T eps = 0.0;
        T tau_min = dt;
        T CFL_numb = 10.0;
        size_t i = 0;
        for (const auto &dir_elem: Dirichlet_boundary) {
            if (!dir_elem) {
                if ((1 + 2 * tau_min * dii.coeff(i) / lumped_mass(i)) < eps) {
                    std::cout << "tau_min PRE modification is " << tau_min;
                    tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii.coeff(i);
                    std::cout << " and tau_min POST modification is " << tau_min << std::endl;
                }
                CFL_numb = std::min(CFL_numb, (eps - 1.0) / 2.0 * lumped_mass(i) / dii.coeff(i));
            }
            i++;
        }
        std::cout << "CFL_numb ---> " << CFL_numb << std::endl;
        std::cout << yellow << bold << "dt is " << dt << " and tau min is " << tau_min << reset << std::endl;
        dt = std::min(dt, tau_min);
        return CFL_numb;
    }


    template<typename VEC, typename DIAG, typename T>
    T time_step_CFL_L2_velocity_NEW(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary,
                                    T &dt) {
        T eps = 1e-2; //0.0;
        T tau_min = dt;
        T CFL_numb = 1000.0;
        T dt_CFL = 1000.0;
//    T dt_CFL_2 = 1000.0;
//    T CFL_numb_max = -100.0 ;
        size_t i = 0;
        for (const auto &dir_elem: Dirichlet_boundary) {
            if (!dir_elem) {
                if ((1 + 2 * tau_min * dii(i) / lumped_mass(i)) < eps) {
                    std::cout << "----> SMALLER dt_m NEEDED: dt_m PRE modification is " << tau_min;
                    tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i);
                    std::cout << " and POST becomes " << tau_min << std::endl;
                }
//std::cout<<"dii(i) =  "<<dii(i)<<" , lumped_mass(i) = "<< lumped_mass(i)<<" , tau_min = "<< tau_min <<", (1 + 2*tau_min*dii(i)/lumped_mass(i) ) = "<< (1 + 2*tau_min*dii(i)/lumped_mass(i) ) << " , ,(eps-1.0)/2.0*lumped_mass(i)/dii(i)  = " <<(eps-1.0)/2.0*lumped_mass(i)/dii(i)  <<std::endl;
                CFL_numb = std::min(CFL_numb, 1 + 2 * tau_min * dii(i) / lumped_mass(i));
                dt_CFL = std::min(dt_CFL, eps * (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i));
//            dt_CFL_2 = std::min( dt_CFL_2 , (-1.0)/2.0*lumped_mass(i)/dii(i)  );
//            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
            }
            i++;
        }

//std::cout<<"CFL_numb_max ---> "<<CFL_numb_max<<std::endl;
        if (dt != tau_min) {
            tau_min = floorf(tau_min * 10000) / 10000;
            std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << tau_min << std::endl;
            std::cout << "-> CFL number = " << CFL_numb << std::endl;
            dt = std::min(dt, tau_min);
            return CFL_numb;
        } else {
//        std::cout<<"-> dt_CFL = "<<dt_CFL<<std::endl;
            if (dt_CFL < dt) {
                dt_CFL = floorf(dt_CFL * 10000) / 10000;
                std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << dt_CFL << std::endl;
                dt = std::min(dt, dt_CFL);
            }
//        std::cout<<"-> dt_CFL_2 = "<<dt_CFL_2<<std::endl;
//        std::cout<<"-> CFL number = "<<CFL_numb<<std::endl;
            return CFL_numb;
        }
    }

    template<typename VEC, typename DIAG, typename T>
    std::pair <T, T>
    time_step_CFL_OK(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary, T &dt) {
        T eps = 0.0;
        T tau_min = dt;
        T CFL_numb = 1000.0;
        T dt_CFL = 1000.0;
//    T dt_CFL_2 = 1000.0;
//    T CFL_numb_max = -100.0 ;
        size_t i = 0;
        for (const auto &dir_elem: Dirichlet_boundary) {
            if (!dir_elem) {
                if ((1 + 2 * tau_min * dii(i) / lumped_mass(i)) < eps) {
                    std::cout << "----> SMALLER dt_m NEEDED: dt_m PRE modification is " << tau_min;
                    tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i);
                    std::cout << " and POST becomes " << tau_min << std::endl;
                }
//std::cout<<"dii(i) =  "<<dii(i)<<" , lumped_mass(i) = "<< lumped_mass(i)<<" , tau_min = "<< tau_min <<", (1 + 2*tau_min*dii(i)/lumped_mass(i) ) = "<< (1 + 2*tau_min*dii(i)/lumped_mass(i) ) << " , ,(eps-1.0)/2.0*lumped_mass(i)/dii(i)  = " <<(eps-1.0)/2.0*lumped_mass(i)/dii(i)  <<std::endl;
                CFL_numb = std::min(CFL_numb, 1 + 2 * tau_min * dii(i) / lumped_mass(i));
                dt_CFL = std::min(dt_CFL, (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i));
//            dt_CFL_2 = std::min( dt_CFL_2 , (-1.0)/2.0*lumped_mass(i)/dii(i)  );
//            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
            }
            i++;
        }

//std::cout<<"CFL_numb_max ---> "<<CFL_numb_max<<std::endl;
        if (dt != tau_min) {
//        tau_min = floorf(tau_min * 10000) / 10000;
            std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << tau_min << std::endl;
            std::cout << "-> CFL number = " << CFL_numb << std::endl;
            dt = std::min(dt, tau_min);
        } else {
//        std::cout<<"-> dt_CFL = "<<dt_CFL<<std::endl;
            if (dt_CFL < dt) {
//            dt_CFL = floorf(dt_CFL * 10000) / 10000;
                std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << dt_CFL << std::endl;
                dt = std::min(dt, dt_CFL);
            }
//        std::cout<<"-> dt_CFL_2 = "<<dt_CFL_2<<std::endl;
//        std::cout<<"-> CFL number = "<<CFL_numb<<std::endl;

        }
        return std::make_pair(CFL_numb, dt_CFL);
    }


    template<typename Entropy, typename Fonction, typename Fonction_TILDE, typename Mesh, typename Vel_Field, typename T, typename VECTOR>
    void r_i_calculator_Bernstein(const Mesh &msh, const typename Mesh::cell_type &cl, const Entropy &E,
                                  const Fonction_TILDE &phi_tilde, const Fonction &phi, T dt, const Vel_Field &u,
                                  VECTOR &Emax_global, VECTOR &Emin_global, VECTOR &R_i) {
        size_t di = 1;
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        auto qps = integrate(msh, cl, 2 * (phi.degree_FEM + di));

        auto nds = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, phi.degree_FEM);

        size_t offset_cell = offset(msh, cl);

        T max_loc = -1e20;
        T min_loc = 1e20;

        for (auto &ndj: nds) {
            max_loc = std::max(E(ndj, cl), max_loc);
            min_loc = std::min(E(ndj, cl), min_loc);
        }

        for (size_t i = 0; i < phi.local_dim; i++) {
            size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
            Emax_global(asm_map) = std::max(Emax_global(asm_map), max_loc);
            Emin_global(asm_map) = std::min(Emin_global(asm_map), min_loc);
        }

//std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;


        for (auto &qp: qps) {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
            auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

            auto f = (
                    ((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt + u(qp.first, msh, cl).first * phi_grad0 +
                     u(qp.first, msh, cl).second * phi_grad1) *
                    E.derivative(qp.first, cl)); //.cwiseQuotient( Emax - Emin ) ;
            ret += qp.second * bi * f;
        }

        for (size_t i = 0; i < phi.local_dim; i++) {
            size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
            R_i(asm_map) += ret(i);
        }


    }


    template<typename T>
    void positive_part_SPARSE(SparseMatrix <T> &mat) {
        for (size_t i = 0; i < mat.rows(); i++) {
            for (size_t j = 0; j < mat.cols(); j++) {
                if (mat.coeff(i, j) < 0.)
                    mat.coeffRef(i, j) = 0.;
            }
        }

    }


    template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
    VECTOR alfaf_ij_creator_M_LUMPED_SPARSE(const VECTOR &lumped_mass, const VECTOR &delta_phi, const VECTOR &phi_L, T dt,
                                            const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old,
                                            const POSITION &S_i) {


        MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
//    std::cout<<'\n'<<"new_D = "<<'\n'<<new_D<<'\n'<<std::endl;
        SparseMatrix <T> f_ij = SparseMatrix<T>(Dc_ij.rows(), Dc_ij.cols());
        std::vector <Triplet<T>> triplets0;
        SparseMatrix <T> alpha_ij = SparseMatrix<T>(Dc_ij.rows(), Dc_ij.cols());
        std::vector <Triplet<T>> triplets1;


//MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
//MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

        VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);

        VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
        VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
        VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
        VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);

        VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(Dc_ij.rows(), 1);
        VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(Dc_ij.rows(), 1);
        VECTOR phi_max = phi_old;
        VECTOR phi_min = phi_old;


        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
                phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
            }
            counter++;
        }

        counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                auto value = dt * new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));
//            std::cout<<'\n'<<"value = "<<value<<'\n'<<std::endl;
//            std::cout<<'\n'<<"phi_old(elem)-phi_old(counter) = "<<phi_old(elem)-phi_old(counter)<<'\n'<<std::endl;
//            std::cout<<'\n'<<"new_D.coeff(counter,elem) = "<<new_D.coeff(counter,elem)<<'\n'<<std::endl;

                triplets0.push_back(Triplet<T>(counter, elem, value));
                P_plus(counter) += std::max(0., value);
                P_minus(counter) += std::min(0., value);

            }

            Q_plus(counter) = lumped_mass(counter) * (phi_max(counter) - phi_L(counter));
            Q_minus(counter) = lumped_mass(counter) * (phi_min(counter) - phi_L(counter));

            if (std::abs(P_plus(counter)) > 1e-14) {
//            std::cout<<'\n'<<"R_plus(counter) = "<<Q_plus(counter)/P_plus(counter)<<std::endl;
                R_plus(counter) = std::min(1.0, Q_plus(counter) / P_plus(counter));
            }
            if (std::abs(P_minus(counter)) > 1e-14) {
//            std::cout<<'\n'<<"R_minus(counter) = "<<Q_minus(counter)/P_minus(counter)<<std::endl;
                R_minus(counter) = std::min(1.0, Q_minus(counter) / P_minus(counter));
            }


            counter++;
        }

//    std::cout<<'\n'<<"P_plus = "<<'\n'<<P_plus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"P_minus = "<<'\n'<<P_minus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"Q_plus = "<<'\n'<<Q_plus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"Q_minus = "<<'\n'<<Q_minus<<'\n'<<std::endl;
        std::cout << '\n' << "R_plus = " << '\n' << R_plus << '\n' << std::endl;
        std::cout << '\n' << "R_minus = " << '\n' << R_minus << '\n' << std::endl;
        f_ij.setFromTriplets(triplets0.begin(), triplets0.end());
        triplets0.clear();

        size_t i = 0;
        for (auto &row_i: S_i) {
            for (auto &j: row_i) {
                if (f_ij.coeff(i, j) >= 0) {
                    auto value = std::min(R_plus(i), R_minus(j));
                    triplets1.push_back(Triplet<T>(i, j, value));

                } else {
                    auto value = std::min(R_plus(j), R_minus(i));
                    triplets1.push_back(Triplet<T>(i, j, value));

                }
            }
            i++;
        }

        alpha_ij.setFromTriplets(triplets1.begin(), triplets1.end());
        triplets1.clear();
//    std::cout<<'\n'<<"alpha_ij = "<<'\n'<<alpha_ij<<'\n'<<std::endl;

        size_t counter2 = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                ret(counter2) += (alpha_ij.coeff(counter2, elem) * f_ij.coeff(counter2, elem));
            }
            counter2++;
        }

//    std::cout<<'\n'<<"ret = "<<'\n'<<ret<<'\n'<<std::endl;
// CHECKING F and Alpha properties

/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }



    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */



/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    //  CHECKING F_IJ

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    size_t counter4 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));
            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));
        }
        counter++;
    }

    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    //sum_Si( S_i , f_ij , One_Vec , f_i_NEW );
    size_t counter5 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));
        }
        counter5++;
    }

    std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;
    */
        return ret;

    }

    template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
    VECTOR
    alfaf_ij_creator_SPARSE(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, const VECTOR &phi_L,
                            T dt, const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

        MATRIX new_mass = -mass;
        for (size_t i = 0; i < new_mass.rows(); i++) {
            new_mass.coeffRef(i, i) += lumped_mass(i);
        }

        MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

        SparseMatrix <T> f_ij = SparseMatrix<T>(mass.rows(), mass.cols());
        std::vector <Triplet<T>> triplets0;
        SparseMatrix <T> alpha_ij = SparseMatrix<T>(mass.rows(), mass.cols());
        std::vector <Triplet<T>> triplets1;


//MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
//MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

        VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

        VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

        VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
        VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
        VECTOR phi_max = phi_old;
        VECTOR phi_min = phi_old;


        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
                phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
            }
            counter++;
        }

        counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                auto value = new_mass.coeff(counter, elem) * (delta_phi(elem) - delta_phi(counter)) +
                             dt * new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));

                triplets0.push_back(Triplet<T>(counter, elem, value));
                P_plus(counter) += std::max(0., value);
                P_minus(counter) += std::min(0., value);

            }

            Q_plus(counter) = lumped_mass(counter) * (phi_max(counter) - phi_L(counter));
            Q_minus(counter) = lumped_mass(counter) * (phi_min(counter) - phi_L(counter));
            if (std::abs(P_plus(counter)) > 1e-14) {
                R_plus(counter) = std::min(1.0, Q_plus(counter) / P_plus(counter));
            }
            if (std::abs(P_minus(counter)) > 1e-14) {
                R_minus(counter) = std::min(1.0, Q_minus(counter) / P_minus(counter));
            }


            counter++;
        }


        f_ij.setFromTriplets(triplets0.begin(), triplets0.end());
        triplets0.clear();

        size_t i = 0;
        for (auto &row_i: S_i) {
            for (auto &j: row_i) {
                if (f_ij.coeff(i, j) >= 0) {
                    auto value = std::min(R_plus(i), R_minus(j));
                    triplets1.push_back(Triplet<T>(i, j, value));

                } else {
                    auto value = std::min(R_plus(j), R_minus(i));
                    triplets1.push_back(Triplet<T>(i, j, value));

                }
            }
            i++;
        }

        alpha_ij.setFromTriplets(triplets1.begin(), triplets1.end());
        triplets1.clear();


        size_t counter2 = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                ret(counter2) += (alpha_ij.coeff(counter2, elem) * f_ij.coeff(counter2, elem));
            }
            counter2++;
        }


// CHECKING F and Alpha properties

/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }



    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */



/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    //  CHECKING F_IJ

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    size_t counter4 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));
            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));
        }
        counter++;
    }

    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    //sum_Si( S_i , f_ij , One_Vec , f_i_NEW );
    size_t counter5 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));
        }
        counter5++;
    }

    std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;
    */
        return ret;

    }


    template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
    VECTOR
    f_ij_creator_SPARSE(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, T dt, const MATRIX &D_ij,
                        const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

        MATRIX new_mass = -mass;
        MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
        for (size_t i = 0; i < new_mass.rows(); i++) {
            new_mass.coeffRef(i, i) += lumped_mass(i);
        }

/*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

        VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
//averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );
//averaged_sum_Si( S_i , new_D , phi_old , ret1 );

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                ret0(counter) += new_mass.coeff(counter, elem) * (delta_phi(elem) - delta_phi(counter));
                ret1(counter) += new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));


            }
            counter++;
        }

//  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

//    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
//    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

        return (ret0 + dt * ret1);

    }


    template<typename T, typename Mesh, typename FiniteSpace>
    struct L2_projection {
        SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem
        Matrix<T, Dynamic, 1> RHS;    // Known term
        std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation

        Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
        Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
        Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh


        size_t number_elements;

        size_t n_cls; // #cells
        size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
        size_t n_vertices; // #vertices

        size_t degree_FEM;
        Mesh msh;
        size_t Nx, Ny;
        mesh_init_params <T> params;

        std::vector <std::vector<std::pair < size_t, bool>>>
                connectivity_matrix;

        size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
        size_t ndof_FE; // Global dimension FE continuous = #nodes


        L2_projection(const FiniteSpace &fe_data, const Mesh &msh)
                : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
                  params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
                  connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);
        }


        L2_projection() = default;


        void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
            sol_HHO = values_new;
        }


        void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
            std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_HHO(i, counter_bis) = values_new(asm_map);
                }
                size_t i_vertex = counter_bis + floor(counter_bis / Nx);
                vertices(i_vertex) = sol_HHO(0, counter_bis);
                vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);
            }

        }

        void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
            std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
            for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[counter_bis][i].first;
                    sol_FEM(asm_map) = values_new(i, counter_bis);
                }
            }


        }


        T operator()(const typename Mesh::node_type &node) const {
            return vertices(node.ptid);
        }

        T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

            size_t counter = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
            T tmp = values_cell.dot(cb.eval_basis(pt));
            return tmp;
        }

        Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
            size_t counter = offset(msh, cl);
            Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
            auto values_cell = sol_HHO.col(counter);
            auto grad_eval = cb.eval_gradients(pt);
            ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
            ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
            return ret;

        }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
        Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
            Eigen::Matrix<T, 2, 1> ret;
            ret = gradient(pt, msh, cl);
            return ret / ret.norm();

        }


    };




    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                                   Fonction &phi, Vel_Field &u,
                                                                   const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
//        phi.coefficients_mapping_MAX_MAX( );
//        //phi.coefficients_mapping();
//    }
//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;


        T eps = 1e-14; //constant into entropy
// NON LINEAR ENTROPY INITIALISATION [0,1]

//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION [phi_min, phi_max]
        non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
//    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


// SAVING OF USEFUL MATRICES
        auto global_mass = method.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
//    timecounter tc_solver;
//    tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }

//    tc_solver.toc();
//    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


//    tc_solver2.toc();
//    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



//    timecounter tc_case00;
//    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;


// CHECK TIME STEP dt
//    T dt_old = dt ;
//    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//    T nu_max0 = CFL_numb/fe_data.hx;
//    T nu0 = dt_old/fe_data.hx;
//    T nu1 = dt/fe_data.hx;

//    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;






// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

//    timecounter tc_case02;
//    tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
//    timecounter tc_case03;
//    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        T c_e = 1.0;
        T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                    auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                    auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
// IN [phi_min,phi_max]
                    auto value_2 = std::max((value_1 - phi.phi_min) * (phi.phi_max - value_1), 0.0);
//                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 ); // IN [0,1]

//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                    bool check_else = FALSE;
                    T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                    if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
//std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
//std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
//auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
//std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                        check_else = TRUE;
                    }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    if (check_else) {
//std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                        value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                        value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
//std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                    } // CONTROLLA QUAAAAA

                    auto value_dC_ij = value_E * value_C;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();


//    tc_case03.toc();
//    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


//    timecounter tc_solver5;
//    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

//    tc_solver5.toc();
//    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

//    timecounter tc_case06;
//    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

// CORRECTION TERM
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);

//    if(!mapping){
//        phi.coefficients_inverse_mapping_MAX_MAX( );
//        //phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


//    tc_case06.toc();
//    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;
//
//    tc.toc();
//    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



//return phi_tilde;
        return CFL_numb;
    }

    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONS_LIMITED(const Mesh &msh,
                                                                                  const FiniteSpace &fe_data, Fonction &phi,
                                                                                  Vel_Field &u,
                                                                                  const Method_Transport &method, T &dt,
                                                                                  bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//timecounter tc;
//tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );


        non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// SAVING OF USEFUL MATRICES
        auto global_mass = method.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;

//    std::cout<<'\n'<<"global_mass = "<<'\n'<<global_mass<<std::endl;

// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)

//    ConjugateGradient<SparseMatrix<T> > solver_prova;
//    solver_prova.compute(global_mass);
//    if(solver_prova.info()!=Success){
//           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
//           exit(1);
//       }

//timecounter tc_solver;
//tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }



//tc_solver.toc();
//std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


//tc_solver2.toc();
//std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;





// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//    std::cout<<"mass_phi_old  "<<'\n'<<mass_phi_old<<'\n'<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
//    time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );
        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//   std::cout<<'\n'<<"dt = "<<dt<<std::endl;


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
//    T c_e = 1.0;
//    T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]


                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//     Matrix<T, Dynamic, 1> b_prova = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//    Matrix<T, Dynamic, 1> phi_H_prova = solver_prova.solve(b_prova);

//    std::cout<<'\n'<<"b_phiH = "<<'\n'<<b_phiH<<std::endl;
//
//    std::cout<<'\n'<<"phi_H_prova = "<<'\n'<<phi_H_prova<<std::endl;
//
//    std::cout<<'\n'<<"phi_H = "<<'\n'<<phi_H<<std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//    std::cout<<'\n'<<"delta_phi = "<<'\n'<<delta_phi<<std::endl;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

//    std::cout<<'\n'<<"f_i = "<<'\n'<<f_i<<std::endl;

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



        return CFL_numb;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_transport_high_order_FTC_M_consistent(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                              const Method_Transport &method, T &dt, bool mapping) {


        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
        entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// SAVING OF USEFUL MATRICES
        auto global_mass = method.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;


        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                auto val = q_entropy(pts[i], cl);
                entropic_flux0_loc(i) = val.first;
                entropic_flux1_loc(i) = val.second;

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
            Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);
                entropic_flux0(asm_map) = sol0_entropic(i);
                entropic_flux1(asm_map) = sol1_entropic(i);

            }


            i_fl++;
        }




// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;


// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter_row = 0;
        auto S_pt_cell = fe_data.S_pt_cell;


        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;

            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;

            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i.second) {

                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;
                N_i_entropic += ((entropic_flux0(elem_j) - E.derivative(pt_i, cl_i) * flux0(elem_j)) *
                                 global_cij_x.coeff(counter_row, elem_j) +
                                 (entropic_flux1(elem_j) - E.derivative(pt_i, cl_i) * flux1(elem_j)) *
                                 global_cij_y.coeff(counter_row, elem_j));

                D_i_entropic0 += (entropic_flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                                  entropic_flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));
                D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                                  flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

                T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nij1.coeff(counter_row, elem_j));
                T value1 = std::abs(
                        u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                        u1(counter_row) * nji1.coeff(counter_row, elem_j));
                T value_adj1 = std::abs(
                        u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem_j)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


            }

            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
            if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 1.0;
            }
            if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 0.0;
            }

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


// CHECK TIME STEP dt

        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]

                    dii_E(counter) -= value_E;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;
        size_t counter_row_prova = 0;

        postprocess_output<double> postoutput1;

        auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE_piece_qua.dat");
        auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL_piece_qua.dat");
        auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE_piece_qua.dat");

        for (auto &row_i: S_pt_cell) {
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            auto dii = dij.diagonal();

            test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
            test_dii->add_data(pt_i, -dii(counter_row_prova));
            test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
            counter_row_prova++;

        }


        postoutput1.add_object(test_dii_dijE);
        postoutput1.add_object(test_dii);
        postoutput1.add_object(test_dijE);


        postoutput1.write();

///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        size_t counter_dir = 0;

        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
            if (dir_elem) {
                phi_L(counter_dir) = phi_FEM(counter_dir);
                phi_H(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }



// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;


//    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i ); // Calculated into alfaf_ij_creator_SPARSE

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        counter_dir = 0;

        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
            if (dir_elem) {

                phi_new(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



        return CFL_numb;

    }

    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_transport_high_order_FTC_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                          const Method_Transport &method, T &dt, bool mapping) {


        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
        entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// SAVING OF USEFUL MATRICES

        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;





// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                auto val = q_entropy(pts[i], cl);
                entropic_flux0_loc(i) = val.first;
                entropic_flux1_loc(i) = val.second;

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
            Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);
                entropic_flux0(asm_map) = sol0_entropic(i);
                entropic_flux1(asm_map) = sol1_entropic(i);

            }


            i_fl++;
        }






// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;


// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter_row = 0;
        auto S_pt_cell = fe_data.S_pt_cell;


        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;

            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;

            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i.second) {

                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;
                N_i_entropic += ((entropic_flux0(elem_j) - E.derivative(pt_i, cl_i) * flux0(elem_j)) *
                                 global_cij_x.coeff(counter_row, elem_j) +
                                 (entropic_flux1(elem_j) - E.derivative(pt_i, cl_i) * flux1(elem_j)) *
                                 global_cij_y.coeff(counter_row, elem_j));

                D_i_entropic0 += (entropic_flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                                  entropic_flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));
                D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                                  flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

                T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nij1.coeff(counter_row, elem_j));
                T value1 = std::abs(
                        u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                        u1(counter_row) * nji1.coeff(counter_row, elem_j));
                T value_adj1 = std::abs(
                        u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem_j)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


            }

            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
            if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 1.0;
            }
            if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 0.0;
            }

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


// CHECK TIME STEP dt

        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]

                    dii_E(counter) -= value_E;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;
        size_t counter_row_prova = 0;

        postprocess_output<double> postoutput1;

        auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE_piece_qua.dat");
        auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL_piece_qua.dat");
        auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE_piece_qua.dat");

        for (auto &row_i: S_pt_cell) {
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            auto dii = dij.diagonal();

            test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
            test_dii->add_data(pt_i, -dii(counter_row_prova));
            test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
            counter_row_prova++;

        }


        postoutput1.add_object(test_dii_dijE);
        postoutput1.add_object(test_dii);
        postoutput1.add_object(test_dijE);


        postoutput1.write();

///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> phi_H = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij.cwiseQuotient(global_lumped_mass);


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;
//    std::cout<<" delta_phi = "<<delta_phi<<std::endl;

//    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i ); // Calculated into alfaf_ij_creator_SPARSE

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_M_LUMPED_SPARSE(global_lumped_mass, delta_phi, phi_L, dt,
                                                                               dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



        return CFL_numb;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_transport_highorder_limited_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                             const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//timecounter tc;
//tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
//    non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
        non_linear_entropy_new_phimax_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimax_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
        auto global_mass = method.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;

//    std::cout<<'\n'<<"global_mass = "<<'\n'<<global_mass<<std::endl;

// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)

//    ConjugateGradient<SparseMatrix<T> > solver_prova;
//    solver_prova.compute(global_mass);
//    if(solver_prova.info()!=Success){
//           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
//           exit(1);
//       }

//timecounter tc_solver;
//tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }



//tc_solver.toc();
//std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


//tc_solver2.toc();
//std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;





// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//    std::cout<<"mass_phi_old  "<<'\n'<<mass_phi_old<<'\n'<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
//    time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );
        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//   std::cout<<'\n'<<"dt = "<<dt<<std::endl;


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
//    T c_e = 1.0;
//    T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]


                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//     Matrix<T, Dynamic, 1> b_prova = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//    Matrix<T, Dynamic, 1> phi_H_prova = solver_prova.solve(b_prova);

//    std::cout<<'\n'<<"b_phiH = "<<'\n'<<b_phiH<<std::endl;
//
//    std::cout<<'\n'<<"phi_H_prova = "<<'\n'<<phi_H_prova<<std::endl;
//
//    std::cout<<'\n'<<"phi_H = "<<'\n'<<phi_H<<std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//    std::cout<<'\n'<<"delta_phi = "<<'\n'<<delta_phi<<std::endl;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

//    std::cout<<'\n'<<"f_i = "<<'\n'<<f_i<<std::endl;

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



        return CFL_numb;

    }

    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_transport_entropic_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                    const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;

        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
        non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//        non_linear_entropy_new_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//        typedef non_linear_entropy_new_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//        entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);





//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        auto S_pt_cell = fe_data.S_pt_cell;


        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;

            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;

            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i.second) {

                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;

                auto q_etro0j = q_entropy(pt_j, cl_j).first;
                auto q_etro1j = q_entropy(pt_j, cl_j).second;
                auto Ederi = E.derivative(pt_i, cl_i);
                auto flux0j = flux0(elem_j);
                auto flux1j = flux1(elem_j);
                auto gl_cxij = global_cij_x.coeff(counter_row, elem_j);
                auto gl_cyij = global_cij_y.coeff(counter_row, elem_j);

                N_i_entropic += ((q_etro0j - Ederi * flux0j) * gl_cxij + (q_etro1j - Ederi * flux1j) * gl_cyij);
                D_i_entropic0 += (q_etro0j * gl_cxij + q_etro1j * gl_cyij);
                D_i_entropic1 += (flux0j * gl_cxij + flux1j * gl_cyij);

//            N_i_entropic += ( (q_entropy(pt_j,cl_j).first - E.derivative(pt_i,cl_i)*flux0(elem_j) )*global_cij_x.coeff(counter_row,elem_j) + (q_entropy(pt_j,cl_j).second - E.derivative(pt_i,cl_i)*flux1(elem_j) )*global_cij_y.coeff(counter_row,elem_j) );
//            D_i_entropic0 += ( q_entropy(pt_j,cl_j).first * global_cij_x.coeff(counter_row,elem_j) + q_entropy(pt_j,cl_j).second * global_cij_y.coeff(counter_row,elem_j) );
//            D_i_entropic1 += ( flux0(elem_j)*global_cij_x.coeff(counter_row,elem_j) + flux1(elem_j)*global_cij_y.coeff(counter_row,elem_j) ) ;

                T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nij1.coeff(counter_row, elem_j));
                T value1 = std::abs(
                        u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                        u1(counter_row) * nji1.coeff(counter_row, elem_j));
                T value_adj1 = std::abs(
                        u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem_j)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


            }

            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
            if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 1.0;
            }
            if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 0.0;
            }

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

        auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {
                    auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                    auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                    dii_E(counter) -= value_E;
                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
            counter++;
        }


//    size_t counter_row_prova = 0;
//
//    postprocess_output<double> postoutput1;
//
//    auto test_dii_dijE  = std::make_shared< gnuplot_output_object<double> >("test_diiL_diiE_piece_qua.dat");
//    auto test_dii  = std::make_shared< gnuplot_output_object<double> >("test_diiL_piece_qua.dat");
//    auto test_dijE  = std::make_shared< gnuplot_output_object<double> >("test_diiE_piece_qua.dat");
//
//    for(auto& row_i:S_pt_cell)
//    {
//        auto pt_i = row_i.first.first ;
//        auto cl_i = row_i.first.second ;
//        auto dii = dij.diagonal();
////            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
////                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
//        test_dii_dijE->add_data(pt_i,dii(counter_row_prova) - dii_E(counter_row_prova));
//        test_dii->add_data(pt_i,dii(counter_row_prova) );
//        test_dijE->add_data(pt_i, dii_E(counter_row_prova));
//        counter_row_prova++;
//
//    }
//
//
//
//    postoutput1.add_object(test_dii_dijE);
//    postoutput1.add_object(test_dii);
//    postoutput1.add_object(test_dijE);
//
//
//
//    postoutput1.write();


        size_t counter_row_prova = 0;

        postprocess_output<double> postoutput1;

        auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
        auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
        auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");
        auto test_Ri = std::make_shared < gnuplot_output_object < double > > ("test_Ri.dat");

        for (auto &row_i: S_pt_cell) {
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
            test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
            test_dii->add_data(pt_i, -dii(counter_row_prova));
            test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
            test_Ri->add_data(pt_i, R_i(counter_row_prova));


            counter_row_prova++;

        }


        postoutput1.add_object(test_Ri);
        postoutput1.add_object(test_dii_dijE);
        postoutput1.add_object(test_dii);
        postoutput1.add_object(test_dijE);


        postoutput1.write();


//   auto CFL_numb_E = time_step_CFL_OK( dii_E , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );
//    std::cout<<"CFL low order = "<< CFL_numb_L.first << " , CFL entropic = "<<CFL_numb_E.first<<std::endl;
//    std::cout<<"TIME STEP: dt_cfl low order = "<< CFL_numb_L.second << " , dt_cfl entropic = "<<CFL_numb_E.second<<std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
        phi.sol_FEM = phi_E;
        phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
        return CFL_numb_L;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_transport_entropic_M_lumped_Ri_correct(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                               const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;

        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;

        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
        entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);


        Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);



//    Matrix<T, Dynamic, 1> entropic_flux0_loc_prove = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
//    Matrix<T, Dynamic, 1> entropic_flux1_loc_prove = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
//
//    Matrix<T, Dynamic, 1> entropic_flux0_prove = Matrix<T, Dynamic, 1>::Zero(dim) ;
//    Matrix<T, Dynamic, 1> entropic_flux1_prove = Matrix<T, Dynamic, 1>::Zero(dim) ;



//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                auto phi_pt = phi(pts[i], msh, cl);
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi_pt;
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi_pt;

                auto val = q_entropy(pts[i], cl);
                entropic_flux0_loc(i) = val.first;
                entropic_flux1_loc(i) = val.second;

//            entropic_flux0_loc_prove(i) = q_entropy.values0_HHO(i,i_fl) ;
//            entropic_flux1_loc_prove(i) = q_entropy.values1_HHO(i,i_fl);
//            std::cout<<"val.first = "<<val.first<<std::endl;
//            std::cout<<"val.second = "<<val.second<<std::endl;
//            std::cout<<"entropic_flux0_loc_prove(i) = "<<entropic_flux0_loc_prove(i)<<std::endl;
//            std::cout<<"entropic_flux1_loc_prove(i) = "<<entropic_flux1_loc_prove(i)<<std::endl;
            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);


            Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
            Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);

//        Matrix<T, Dynamic, 1> sol0_entropic_prove = cod.solve(entropic_flux0_loc_prove);
//        Matrix<T, Dynamic, 1> sol1_entropic_prove = cod.solve(entropic_flux1_loc_prove);

            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);


                entropic_flux0(asm_map) = sol0_entropic(i);
                entropic_flux1(asm_map) = sol1_entropic(i);

//            entropic_flux0_prove(asm_map) = sol0_entropic_prove(i) ;
//            entropic_flux1_prove(asm_map) = sol1_entropic_prove(i) ;



            }


            i_fl++;
        }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


//    std::cout << "entropic_flux0 - entropic_flux0_prove" <<'\n'<<entropic_flux0 - entropic_flux0_prove<<'\n' << std::endl;
//    std::cout << "entropic_flux1 - entropic_flux1_prove" <<'\n'<<entropic_flux1 - entropic_flux1_prove<<'\n' << std::endl;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        auto S_pt_cell = fe_data.S_pt_cell;


        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;

            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;

            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            auto E_der_i = E.derivative(pt_i, cl_i);
            for (auto &elem: row_i.second) {

                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;
//            std::cout<<"entropic_flux0(elem_j) - q_entropy(pt_i,cl_i) = "<<entropic_flux0(elem_j) - q_entropy(pt_i,cl_i).first<<std::endl;

                auto entr_flux0_j = entropic_flux0(elem_j);
                auto entr_flux1_j = entropic_flux1(elem_j);
                auto gl_c0_ij = global_cij_x.coeff(counter_row, elem_j);
                auto gl_c1_ij = global_cij_y.coeff(counter_row, elem_j);
                auto flux0_j = flux0(elem_j);
                auto flux1_j = flux1(elem_j);

                N_i_entropic += ((entr_flux0_j - E_der_i * flux0_j) * gl_c0_ij +
                                 (entr_flux1_j - E_der_i * flux1_j) * gl_c1_ij);
                D_i_entropic0 += (entr_flux0_j * gl_c0_ij + entr_flux1_j * gl_c1_ij);
                D_i_entropic1 += (flux0_j * gl_c0_ij + flux1_j * gl_c1_ij);

                auto n0ij = nij0.coeff(counter_row, elem_j);
                auto n1ij = nij1.coeff(counter_row, elem_j);

                T value0 = std::abs(u0(counter_row) * n0ij + u1(counter_row) * n1ij);
                T value1 = std::abs(u0(elem_j) * n0ij + u1(elem_j) * n1ij);
                T value = std::max(value0, value1);

                auto n0ji = nji0.coeff(counter_row, elem_j);
                auto n1ji = nji1.coeff(counter_row, elem_j);

                T value_adj0 = std::abs(u0(counter_row) * n0ji + u1(counter_row) * n1ji);
                T value_adj1 = std::abs(u0(elem_j) * n0ji + u1(elem_j) * n1ji);
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;


                if (counter_row != elem_j)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


            }

            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E_der_i);

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
            if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 1.0;
            }
            if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
                R_i(counter_row) = 0.0;
            }

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
        auto CFL_numb_L = std::make_pair(10,
                                         1); // time_step_CFL_OK( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {
                    auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                    auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                    dii_E(counter) -= value_E;
                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
            counter++;
        }


        size_t counter_row_prova = 0;

        postprocess_output<double> postoutput1;

        auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
        auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
        auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");
        auto test_Ri = std::make_shared < gnuplot_output_object < double > > ("test_Ri.dat");

        for (auto &row_i: S_pt_cell) {
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
            test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
            test_dii->add_data(pt_i, -dii(counter_row_prova));
            test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
            test_Ri->add_data(pt_i, R_i(counter_row_prova));


            counter_row_prova++;

        }


        postoutput1.add_object(test_Ri);
        postoutput1.add_object(test_dii_dijE);
        postoutput1.add_object(test_dii);
        postoutput1.add_object(test_dijE);


        postoutput1.write();


//   auto CFL_numb_E = time_step_CFL_OK( dii_E , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );
//    std::cout<<"CFL low order = "<< CFL_numb_L.first << " , CFL entropic = "<<CFL_numb_E.first<<std::endl;
//    std::cout<<"TIME STEP: dt_cfl low order = "<< CFL_numb_L.second << " , dt_cfl entropic = "<<CFL_numb_E.second<<std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
        size_t counter_dir = 0;

        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
            if (dir_elem) {

                phi_E(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
        phi.sol_FEM = phi_E;
        phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
        return CFL_numb_L;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING(const Mesh &msh,
                                                                                        const FiniteSpace &fe_data,
                                                                                        Fonction &phi, Vel_Field &u,
                                                                                        const Method_Transport &method,
                                                                                        T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;

        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
//    non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

        T max_val = 14.0;
        non_linear_entropy_quadratic_phimin_phimax<T, Fonction, Mesh> E(max_val, phi, msh);
        typedef non_linear_entropy_quadratic_phimin_phimax<T, Fonction, Mesh> Entropy_func2;
        entropy_flux_quadratic<Entropy_func2, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

//            if( counter_row == 569 )
//            {
//                std::cout<<"elem = "<<elem<<" , q_entropy.values0(elem) = "<<q_entropy.values0(elem)<<" , E.E_der(counter_row) = "<<E.E_der(counter_row)<<" , flux0(elem) ="<<flux0(elem)<<" , global_cij_x.coeff(counter_row,elem) = "<<global_cij_x.coeff(counter_row,elem)<<std::endl;
//                std::cout<<"elem = "<<elem<<" , q_entropy.values1(elem) = "<<q_entropy.values1(elem)<<" , E.E_der(counter_row) = "<<E.E_der(counter_row)<<" , flux1(elem) ="<<flux1(elem)<<" , global_cij_y.coeff(counter_row,elem) = "<<global_cij_y.coeff(counter_row,elem)<<std::endl;
//                std::cout<<"elem = "<<elem<<" , q_entropy.values0(elem) - E.E_der(counter_row) = "<<q_entropy.values0(elem) - E.E_der(counter_row) <<" , q_entropy.values1(elem) - E.E_der(counter_row) = "<<q_entropy.values1(elem) - E.E_der(counter_row)<<" , Ni0(elem) = "<<(q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem)<<" , Ni1 = "<<(q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) <<std::endl;
//                std::cout<<"elem = "<<elem<<" , D_i_entropic0 = "<<D_i_entropic0<<" , D_i_entropic1 = "<<D_i_entropic1<<" , N_i_entropic ="<<N_i_entropic<<std::endl;
//            }

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
            if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i
                          << " , std::abs(N_i_entropic) = " << std::abs(N_i_entropic) << " , D_i = " << D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
                std::cout << "Imposition of R_i = 1 for i = " << counter_row << ". It was R_i = " << R_i(counter_row)
                          << std::endl;
                R_i(counter_row) = 1.0;
            }
            if (R_i(counter_row) < 0) {
                std::cout << "Imposition of R_i = 0 for i = " << counter_row << ". It was R_i = " << R_i(counter_row)
                          << std::endl;
                R_i(counter_row) = 0.0;
            }

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

        auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {
                    auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                    auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                    dii_E(counter) -= value_E;
                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
            counter++;
        }


        auto S_pt_cell = fe_data.S_pt_cell;
        size_t counter_row_prova = 0;

        postprocess_output<double> postoutput1;

        auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
        auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
        auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");

        for (auto &row_i: S_pt_cell) {
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
            test_dii_dijE->add_data(pt_i, dii(counter_row_prova) - dii_E(counter_row_prova));
            test_dii->add_data(pt_i, dii(counter_row_prova));
            test_dijE->add_data(pt_i, dii_E(counter_row_prova));
            counter_row_prova++;

        }

        postoutput1.add_object(test_dii_dijE);
        postoutput1.add_object(test_dii);
        postoutput1.add_object(test_dijE);


        postoutput1.write();


        auto CFL_numb_E = time_step_CFL_OK(dii_E, global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);
//    std::cout<< "Entropic process."<< std::endl;
        std::cout << "CFL low order = " << CFL_numb_L.first << " , CFL entropic = " << CFL_numb_E.first << std::endl;
        std::cout << "TIME STEP: dt_cfl low order = " << CFL_numb_L.second << " , dt_cfl entropic = " << CFL_numb_E.second
                  << std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
        phi.sol_FEM = phi_E;
        phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
        return CFL_numb_E;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING_ANALYTIC_VEL(const Mesh &msh,
                                                                                                     const FiniteSpace &fe_data,
                                                                                                     Fonction &phi,
                                                                                                     Vel_Field &u,
                                                                                                     const Method_Transport &method,
                                                                                                     T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;

        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;





// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

        non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux_ANALYTIC_VEL<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);



// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u(pts[i])[0] * phi(pts[i], msh, cl);
                flux1_loc(i) = u(pts[i])[1] * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        auto S_pt_cell = fe_data.S_pt_cell;
        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter_row = 0;

        for (auto &row_i: S_pt_cell) {
            T sum_row = 0.0;
            auto pt_i = row_i.first.first;
            auto cl_i = row_i.first.second;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i.second) {
                auto pt_j = elem.second.first;
                auto cl_j = elem.second.second;
                size_t elem_j = elem.first;


//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy(pt_j, cl_j).first - E.E_der(counter_row) * flux0(elem_j)) *
                                 global_cij_x.coeff(counter_row, elem_j) +
                                 (q_entropy(pt_j, cl_j).second - E.E_der(counter_row) * flux1(elem_j)) *
                                 global_cij_y.coeff(counter_row, elem_j));
                D_i_entropic0 += (q_entropy(pt_j, cl_j).first * global_cij_x.coeff(counter_row, elem_j) +
                                  q_entropy(pt_j, cl_j).second * global_cij_y.coeff(counter_row, elem_j));
                D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                                  flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

                T value0 = std::abs(
                        u(pt_i)[0] * nij0.coeff(counter_row, elem_j) + u(pt_i)[1] * nij1.coeff(counter_row, elem_j));
                T value1 = std::abs(
                        u(pt_j)[0] * nij0.coeff(counter_row, elem_j) + u(pt_j)[1] * nij1.coeff(counter_row, elem_j));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u(pt_i)[0] * nji0.coeff(counter_row, elem_j) + u(pt_i)[1] * nji1.coeff(counter_row, elem_j));
                T value_adj1 = std::abs(
                        u(pt_j)[0] * nji0.coeff(counter_row, elem_j) + u(pt_j)[1] * nji1.coeff(counter_row, elem_j));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem_j)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem_j)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

        auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {
                    auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                    auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                    dii_E(counter) -= value_E;
//                std::cout<<"R_ij = "<<R_ij<<"value_E = "<<value_E<<std::endl;
                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
//        std::cout<<"Line = "<<counter<<" -> dii_E(counter) = "<<dii_E(counter)<<std::endl;
            counter++;
        }

        auto CFL_numb_E = time_step_CFL_OK(dii_E, global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);
//    std::cout<< "Entropic process."<< std::endl;
        std::cout << "CFL low order = " << CFL_numb_L.first << " , CFL entropic = " << CFL_numb_E.first << std::endl;
        std::cout << "TIME STEP: dt_cfl low order = " << CFL_numb_L.second << " , dt_cfl entropic = " << CFL_numb_E.second
                  << std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
        phi.sol_FEM = phi_E;
        phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
        return CFL_numb_L;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
    std::pair <T, T>
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONSISTENT_NO_LIMITING(const Mesh &msh,
                                                                                            const FiniteSpace &fe_data,
                                                                                            Fonction &phi, Vel_Field &u,
                                                                                            const Method_Transport &method,
                                                                                            T &dt, bool mapping) {
// Starting time for FE calculation
//    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;

        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

        non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);



// SAVING OF USEFUL MATRICES
        Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;
        auto global_mass = method.Global_Mass;
        auto global_cij_x = method.Global_c_term_x;
        auto global_cij_y = method.Global_c_term_y;
        auto local_vandermonde = method.local_vandermonde;

        auto cij_norm = method.cij_norm;
        auto nij0 = method.nij0;
        auto nij1 = method.nij1;

        auto cji_norm = method.cij_norm;
        auto nji0 = method.nji0;
        auto nji1 = method.nji1;


//    timecounter tc_solver;
//    tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }

//    tc_solver.toc();
//    std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

        auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);



// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {
                    auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                    auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                    term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

//
//    std::cout<< "Entropic process."<< std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
//    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij.cwiseQuotient(global_lumped_mass);

// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;

        Matrix<T, Dynamic, 1> b_phiE = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_E = solver_global_mass.solve(b_phiE);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection



//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

//       T relative_error0 = (global_mass*phi_E - b_phiE).norm() / b_phiE.norm();
//       std::cout << "The relative error in solving the transport problem (mass consistent) is: " << relative_error0 << std::endl;


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
        phi.sol_FEM = phi_E;
        phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;
//
//
//
//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;

        return CFL_numb;
    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    void
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                            Vel_Field &u, T &dt, bool mapping) {
// Starting time for FE calculation
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED) -----------"
                  << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

        timecounter tc;
        tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


        if (!mapping) {
            phi.coefficients_mapping_MAX_MAX();
//phi.coefficients_mapping();
        }
//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
        non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
        auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
        auto global_mass = phi.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

        auto global_cij_x = phi.Global_c_term_x;
        auto global_cij_y = phi.Global_c_term_y;
        auto local_vandermonde = phi.local_vandermonde;

        auto cij_norm = phi.cij_norm;
        auto nij0 = phi.nij0;
        auto nij1 = phi.nij1;

        auto cji_norm = phi.cij_norm;
        auto nji0 = phi.nji0;
        auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
        timecounter tc_solver;
        tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }

        tc_solver.toc();
        std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
                  << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        timecounter tc_solver2;
        tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


        tc_solver2.toc();
        std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
                  << reset << std::endl;


        timecounter tc_case00;
        tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

            if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
                R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
                std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
            } else
                R_i(counter_row) = std::abs(N_i_entropic) / D_i;


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


        tc_case00.toc();
        std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
                  << std::endl;

        timecounter tc_case01;
        tc_case01.tic();

// CHECK TIME STEP dt
        T dt_old = dt;
        std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
        T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

        T nu_max0 = CFL_numb / fe_data.hx;
        T nu0 = dt_old / fe_data.hx;
        T nu1 = dt / fe_data.hx;

        std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
                  << " and with dt appeared by CFL COND " << nu1 << std::endl;

        if (dt_old != dt) {
            std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
            exit(10);
        }

        tc_case01.toc();
        std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

        timecounter tc_case02;
        tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
        timecounter tc_case03;
        tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        T c_e = 1.0;
        T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                    auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                    auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                    auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                    bool check_else = FALSE;
                    T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                    if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
//std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
//std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
//auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
//std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                        check_else = TRUE;
                    }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    if (check_else) {
//std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                        value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                        value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
//std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                    } // CONTROLLA QUAAAAA

                    auto value_dC_ij = value_E * value_C;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();


        tc_case03.toc();
        std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


        timecounter tc_solver5;
        tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

        tc_solver5.toc();
        std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

        T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
        std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

        timecounter tc_case06;
        tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

// CORRECTION TERM
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        size_t counter_dir = 0;

        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
            if (dir_elem) {
//phi_L(counter_dir) = phi_FEM(counter_dir) ;
//phi_H(counter_dir) = phi_FEM(counter_dir) ;
                phi_new(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);

        if (!mapping) {
            phi.coefficients_inverse_mapping_MAX_MAX();
//phi.coefficients_inverse_mapping();
        }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


        tc_case06.toc();
        std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

        tc.toc();
        std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


        std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

    }

    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    void
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP(const Mesh &msh, const FiniteSpace &fe_data,
                                                                   Fonction &phi, Vel_Field &u, T &dt, bool mapping) {
// Starting time for FE calculation
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

        timecounter tc;
        tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


        if (!mapping)
            phi.coefficients_mapping_MAX_MAX();

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
        non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
        auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
        auto global_mass = phi.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

        auto global_cij_x = phi.Global_c_term_x;
        auto global_cij_y = phi.Global_c_term_y;
        auto local_vandermonde = phi.local_vandermonde;

        auto cij_norm = phi.cij_norm;
        auto nij0 = phi.nij0;
        auto nij1 = phi.nij1;

        auto cji_norm = phi.cij_norm;
        auto nji0 = phi.nji0;
        auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
        timecounter tc_solver;
        tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }

        tc_solver.toc();
        std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
                  << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        timecounter tc_solver2;
        tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


        tc_solver2.toc();
        std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
                  << reset << std::endl;


        timecounter tc_case00;
        tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            R_i(counter_row) = std::abs(N_i_entropic) /
                               (std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row)));


            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


        tc_case00.toc();
        std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
                  << std::endl;

        timecounter tc_case01;
        tc_case01.tic();

// CHECK TIME STEP dt
        T dt_old = dt;
        std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
        T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

        T nu_max0 = CFL_numb / fe_data.hx;
        T nu0 = dt_old / fe_data.hx;
        T nu1 = dt / fe_data.hx;

        std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
                  << " and with dt appeared by CFL COND " << nu1 << std::endl;

        if (dt_old != dt) {
            std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
            exit(10);
        }

        tc_case01.toc();
        std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

        timecounter tc_case02;
        tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
        timecounter tc_case03;
        tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        T c_e = 1.0;
        T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                    auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

//auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
//auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
//bool check_else = FALSE;
//T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    //std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    //std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    //auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
/*
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    //std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    //std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;

                } // CONTROLLA QUAAAAA
                */
                    auto value_dC_ij = value_E;  //* value_C ;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();


        tc_case03.toc();
        std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


        timecounter tc_solver5;
        tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

        tc_solver5.toc();
        std::cout << bold << yellow << "SOLUTION phi_H (new method book Alexandre), t = " << tc_solver5 << " seconds"
                  << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

        T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
        std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

        timecounter tc_case06;
        tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

// CORRECTION TERM
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        size_t counter_dir = 0;

        for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
            if (dir_elem) {
//phi_L(counter_dir) = phi_FEM(counter_dir) ;
//phi_H(counter_dir) = phi_FEM(counter_dir) ;
                phi_new(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);

        if (!mapping)
            phi.coefficients_inverse_mapping_MAX_MAX();
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


        tc_case06.toc();
        std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

        tc.toc();
        std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


        std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

    }

    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    void
    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u, T &dt) {
// Starting time for FE calculation
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM NEW D -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

        timecounter tc;
        tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


        phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;


// NON LINEAR ENTROPY INITIALISATION
        T eps = 1e-14; //constant into entropy
        non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
        typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
        entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
        auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
        auto global_mass = phi.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

        auto global_cij_x = phi.Global_c_term_x;
        auto global_cij_y = phi.Global_c_term_y;
        auto local_vandermonde = phi.local_vandermonde;

        auto cij_norm = phi.cij_norm;
        auto nij0 = phi.nij0;
        auto nij1 = phi.nij1;

        auto cji_norm = phi.cij_norm;
        auto nji0 = phi.nji0;
        auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
        timecounter tc_solver;
        tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER LLT." << std::endl;
            exit(1);
        }

        tc_solver.toc();
        std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
                  << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        timecounter tc_solver2;
        tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


        tc_solver2.toc();
        std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
                  << reset << std::endl;


        timecounter tc_case00;
        tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

//Matrix<T, Dynamic, 1> R_i_prova = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            T N_i_entropic = 0.0;
            T D_i_entropic0 = 0.0;
            T D_i_entropic1 = 0.0;
            for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
                N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                                 global_cij_x.coeff(counter_row, elem) +
                                 (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                                 global_cij_y.coeff(counter_row, elem));
                D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
                D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                                  flux1(elem) * global_cij_y.coeff(counter_row, elem));

                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

            R_i(counter_row) = std::abs(N_i_entropic) /
                               (std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row)));
//R_i_prova(counter_row) = std::abs(N_i_entropic) ;

            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


        tc_case00.toc();
        std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
                  << std::endl;

        timecounter tc_case01;
        tc_case01.tic();

// CHECK TIME STEP dt
        T dt_old = dt;
        std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
        T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

        T nu_max0 = CFL_numb / fe_data.hx;
        T nu0 = dt_old / fe_data.hx;
        T nu1 = dt / fe_data.hx;

        std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
                  << " and with dt appeared by CFL COND " << nu1 << std::endl;

        if (dt_old != dt) {
            std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
            exit(10);
        }

        tc_case01.toc();
        std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;


/*

    // CONSTANT TERM (PHI TILDE PROBLEM)
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;

*/

/*
    timecounter tc_case02;
    tc_case02.tic();

    // TERM R_i^n

    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        //auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    //R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i_prova<<" , "<<R_i_bis<<" , DIFF -> "<<R_i_prova- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
*/
        timecounter tc_case03;
        tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        T c_e = 1.0;
        T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                    auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                    auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                    auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                    bool check_else = FALSE;
                    T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                    if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
                        std::cout << "SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "
                                  << std::abs(phi_FEM(counter) - phi_FEM(elem)) << " and value_2 = " << value_2
                                  << std::endl;
                        std::cout << "elem = " << elem << " and counter = " << counter << std::endl;
                        auto value_C = std::max(1.0 - c_comp * value, 0.0);
                        std::cout << "1.0 - c_comp * value = " << (1.0 - c_comp * value) << " and value_C = " << value_C
                                  << std::endl;
                        check_else = TRUE;
                    }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    if (check_else) {
                        std::cout << "value_C GIUSTO = " << value_C << std::endl;
                        value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                        value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
                        std::cout << "Se NaN-> metto dC = 0!!! -> value_C CORRETTO = " << value_C << '\n' << std::endl;
                    } // CONTROLLA QUAAAAA

                    auto value_dC_ij = value_E * value_C;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();


        tc_case03.toc();
        std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


        timecounter tc_solver5;
        tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

        tc_solver5.toc();
        std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

        T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
        std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

        timecounter tc_case06;
        tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

// CORRECTION TERM
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        size_t counter_dir = 0;
        for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
            if (dir_elem) {
                phi_L(counter_dir) = phi_FEM(counter_dir);
                phi_H(counter_dir) = phi_FEM(counter_dir);
                phi_new(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }

        tc_case06.toc();
        std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);
        phi.coefficients_inverse_mapping();

        tc.toc();
        std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


        std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

    }


    template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
    void
    run_FEM_BERNSTEIN_CORRECT_FAST(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u, T &dt) {
// Starting time for FE calculation
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

        timecounter tc;
        tc.tic();

        size_t degree = fe_data.order; // finite element order
        size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
        size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
        auto S_i = fe_data.S_i;


        phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
        auto phi_FEM = phi.sol_FEM;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u0_cellwise = u.sol_HHO.first;
        auto u1_cellwise = u.sol_HHO.second;


// NON LINEAR ENTROPY INITIALISATION
        const T eps = 1e-14; //constant into entropy
        non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);


// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
        auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
        auto global_mass = phi.Global_Mass;
        Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

        auto global_cij_x = phi.Global_c_term_x;
        auto global_cij_y = phi.Global_c_term_y;
        auto local_vandermonde = phi.local_vandermonde;

        auto cij_norm = phi.cij_norm;
        auto nij0 = phi.nij0;
        auto nij1 = phi.nij1;

        auto cji_norm = phi.cij_norm;
        auto nji0 = phi.nji0;
        auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
//ConjugateGradient<SparseMatrix<T> > solver_global_mass;

        timecounter tc_solver;
        tc_solver.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

        if (solver_global_mass.info() != Success) {
            std::cout << "FAILED SOLVER 0->phi_tilde" << std::endl;
            exit(1);
        }

        tc_solver.toc();
        std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
                  << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
        size_t i_fl = 0;
        Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
        Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

        Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
        Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

        timecounter tc_solver2;
        tc_solver2.tic();

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

        for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
            auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
            for (size_t i = 0; i < local_ndof; i++) {
                flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
                flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

            }

            Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
            Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
            if (cod.info() != Success) {
                std::cout << "Not positive" << std::endl;
                assert(0);
            }

            for (size_t i = 0; i < local_ndof; i++) {

                size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
                flux0(asm_map) = sol0(i);
                flux1(asm_map) = sol1(i);

            }


            i_fl++;
        }


        tc_solver2.toc();
        std::cout << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << std::endl;


        timecounter tc_case00;
        tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
        Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
        Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
        SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
        Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
        Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
        Emax_global *= -1e20;
        Emin_global *= 1e20;


        size_t counter_row = 0;
        for (auto &row_i: S_i) {
            T sum_row = 0.0;
            for (auto &elem: row_i) {

                Emax_global(counter_row) = std::max(E.E_values(elem), Emax_global(counter_row));
                Emin_global(counter_row) = std::min(E.E_values(elem), Emin_global(counter_row));


                T value0 = std::abs(
                        u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
                T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
                T value = std::max(value0, value1);

                T value_adj0 = std::abs(
                        u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
                T value_adj1 = std::abs(
                        u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
                T value_adj = std::max(value_adj0, value_adj1);

                T lambda_max = value * cij_norm.coeff(counter_row, elem);
                T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

                T val_dij = std::max(lambda_max, lambda_max_adj);

                if (counter_row == elem)
                    val_dij = 0.0;

                sum_row += val_dij;

                if (counter_row != elem)
                    triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


            }
            triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
            counter_row++;

        }

        dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
        triplets_dij.clear();


        tc_case00.toc();
        std::cout << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

        timecounter tc_case01;
        tc_case01.tic();

// CHECK TIME STEP dt
        T dt_old = dt;
        std::cout << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << std::endl;
        T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

        if (dt_old != dt) {
            std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
            exit(10);
        }

        tc_case01.toc();
        std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
        Matrix<T, Dynamic, 1> b = mass_phi_old - dt * conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


        timecounter tc_solver3;
        tc_solver3.tic();

// RESOLUTION OF PHI_TILDE
        phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection

// norm() is L2 norm
        T relative_error0 = (global_mass * phi_tilde.sol_FEM - b).norm() / b.norm();
        std::cout << "The relative error is: " << relative_error0 << std::endl;

/*
    auto prova_phi_tilde_2 = solver2_bis.solve(b);
    T relative_error2 = (global_mass*prova_phi_tilde_2 - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;


    if(solver_global_mass.info()!=Success) {
        std::cout<<"FAILED SOLVER 1->phi_tilde"<<std::endl;
        exit(1);
    }
    */
        tc_solver3.toc();
        std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

// SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
        std::cout << "CONVERTING phi_tilde" << std::endl;
        timecounter tc_solver4;
        tc_solver4.tic();
        phi_tilde.converting_into_HHO_formulation(phi_tilde.sol_FEM);
        tc_solver4.toc();
        std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


        timecounter tc_case02;
        tc_case02.tic();

// TERM R_i^n
        Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        for (auto &cl: msh.cells) {
            size_t di = 1;
            size_t offset_cell = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, phi.degree_FEM);
            auto cbs = cb.size();
            Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
//auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
//auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
            auto qps = integrate(msh, cl, di);

            for (auto &qp: qps) {
                auto bi = cb.eval_basis(qp.first);
                auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
                auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

                auto f = (((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt +
                           u(qp.first, msh, cl).first * phi_grad0 + u(qp.first, msh, cl).second * phi_grad1) *
                          E.derivative(qp.first, cl));
                ret += qp.second * bi * f;
            }
            for (size_t i = 0; i < phi.local_dim; i++) {
                size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
                R_i(asm_map) += ret(i);
            }

        }


// R_i FINALISATION:
//std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
//R_i = R_i.cwiseQuotient( Emax_global - Emin_global );
//std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
//std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;

        tc_case02.toc();
        std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;

        timecounter tc_case03;
        tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
        T c_e = 1.0;
        T c_comp = 1.0;


        SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
        std::vector <Triplet<T>> triplets_dC_ij;

        Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
        Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {

                if (elem != counter) {

                    auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
                    auto value_E = std::min(dij.coeff(counter, elem), R_i_j);
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                    auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                    auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);

                    bool check_else = FALSE;
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//if( std::abs(phi_FEM(counter_tmp) - phi_FEM(elem))>1e-15 ){
                    auto value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));

                    if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
                        std::cout << "SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "
                                  << std::abs(phi_FEM(counter) - phi_FEM(elem)) << " and value_2 = " << value_2
                                  << std::endl;
                        std::cout << "elem = " << elem << " and counter = " << counter << std::endl;

                        auto value_C = std::max(1.0 - c_comp * value, 0.0);
                        std::cout << "1.0 - c_comp * value = " << (1.0 - c_comp * value) << " and value_C = " << value_C
                                  << std::endl;
                        check_else = TRUE;
                    }


                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    if (check_else) {
                        std::cout << "value_C GIUSTO = " << value_C << std::endl;
                        value = (value_2 + 1e-18) / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
                        value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
                        std::cout << "Se NaN-> metto dC = 0!!! -> value_C CORRETTO = " << value_C << std::endl;
                    }

                    auto value_dC_ij = value_E * value_C;
                    triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                    term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                    term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


                }


            }
            counter++;
        }

        dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
        triplets_dC_ij.clear();


        tc_case03.toc();
        std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
        Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                      dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


        timecounter tc_solver5;
        tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
        Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
        Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

        tc_solver5.toc();
        std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

        relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
        std::cout << "The relative error is: " << relative_error0 << std::endl;
/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

        timecounter tc_case06;
        tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

        Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

        Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                        S_i);

// CORRECTION TERM
        Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                      dij, dC_ij, phi_FEM, S_i);
        Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
        size_t counter_dir = 0;
        for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
            if (dir_elem) {
                phi_L(counter_dir) = phi_FEM(counter_dir);
                phi_H(counter_dir) = phi_FEM(counter_dir);
                phi_new(counter_dir) = phi_FEM(counter_dir);
            }
            counter_dir++;
        }

        tc_case06.toc();
        std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
        phi.sol_FEM = phi_new;
        phi.converting_into_HHO_formulation(phi_new);
        phi.coefficients_inverse_mapping();

        tc.toc();
        std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


        std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

    }



    template<typename Entropy, typename Fonction, typename Fonction_TILDE, typename Mesh, typename Vel_Field, typename T, typename POSITION, typename VECTOR>
    void
    r_i_calculator(const Mesh &msh, const typename Mesh::cell_type &cl, const Entropy &E, const Fonction_TILDE &phi_tilde,
                   const Fonction &phi, T dt, const Vel_Field &u, const POSITION &S_i, VECTOR &Emax_global,
                   VECTOR &Emin_global, VECTOR &R_i) {
        size_t di = 0;
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        auto qps = integrate(msh, cl, 2 * (phi.degree_FEM + di));


        auto nds = nodes(msh, cl);
        iter_swap(nds.end() - 1, nds.end() - 2);

        auto pts = points(msh, cl);
        iter_swap(pts.end() - 1, pts.end() - 2);


        size_t counter = 0;
/// FARE FUNZIONE max_min_entropy PER RENDERE IL CODICE PULITO
        Eigen::Matrix<T, Dynamic, 1> Emax = Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
        Eigen::Matrix<T, Dynamic, 1> Emin = Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
        for (auto &nd: nds) {
            auto i = nd.ptid;
            T max_loc = -1e20;
            T min_loc = 1e20;
            for (auto &pt_j: pts) {
                Emax(counter) = std::max(E(pt_j, cl), max_loc);
                Emin(counter) = std::min(E(pt_j, cl), min_loc);
                max_loc = std::max(Emax(counter), max_loc);
                min_loc = std::min(Emin(counter), min_loc);
            }

            counter++;
        }
        global_update_vector_MAX(Emax, Emax_global, nds);
        global_update_vector_MIN(Emin, Emin_global, nds);
// std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//  std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;

        for (auto &qp: qps) {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
            auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

            auto f = (
                    ((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt + u(qp.first, msh, cl).first * phi_grad0 +
                     u(qp.first, msh, cl).second * phi_grad1) *
                    E.derivative(qp.first, cl)); //.cwiseQuotient( Emax - Emin ) ;
            ret += qp.second * bi * f;
        }
        global_update_vector(ret, R_i, nds);

    }


    template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
    VECTOR
    alfaf_ij_creator(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, const VECTOR &phi_L, T dt,
                     const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

        MATRIX new_mass = -mass;
        for (size_t i = 0; i < new_mass.rows(); i++) {
            new_mass(i, i) += lumped_mass(i);
        }

        MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

        MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(mass.rows(), mass.cols());
        MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(mass.rows(), mass.cols());

        VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

        VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
        VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

        VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
        VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
        VECTOR phi_max = phi_old;
        VECTOR phi_min = phi_old;


        size_t counter = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
                phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
            }
            counter++;
        }

        for (size_t i = 0; i < f_ij.rows(); i++) {
            for (size_t j = 0; j < f_ij.cols(); j++) {
                f_ij(i, j) = new_mass(i, j) * (delta_phi(j) - delta_phi(i)) + dt * new_D(i, j) * (phi_old(j) - phi_old(i));
                T f_tmp = f_ij(i, j);
                P_plus(i) += std::max(0., f_tmp);
                P_minus(i) += std::min(0., f_tmp);
            }
            Q_plus(i) = lumped_mass(i) * (phi_max(i) - phi_L(i));
            Q_minus(i) = lumped_mass(i) * (phi_min(i) - phi_L(i));
            if (std::abs(P_plus(i)) > 1e-20) {
                T Q_P_plus = Q_plus(i) / P_plus(i);
                R_plus(i) = std::min(1., Q_P_plus);
            }
            if (std::abs(P_minus(i)) > 1e-20) {
                T Q_P_minus = Q_minus(i) / P_minus(i);
                R_minus(i) = std::min(1., Q_P_minus);
            }
        }

        for (size_t i = 0; i < f_ij.rows(); i++) {
            for (size_t j = 0; j < f_ij.cols(); j++) {
                if (f_ij(i, j) > 0)
                    alpha_ij(i, j) = std::min(R_plus(i), R_minus(j));
                else
                    alpha_ij(i, j) = std::min(R_plus(j), R_minus(i));
            }

        }

        size_t counter2 = 0;
        for (auto &row_i: S_i) {
            for (auto &elem: row_i) {
                ret(counter2) += (alpha_ij(counter2, elem) * f_ij(counter2, elem));
            }
            counter2++;
        }


// CHECKING F and Alpha properties
/*
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij(i,j)+f_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

/*
    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij(i,j)-alpha_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

/*
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij(counter3,elem)+f_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij(counter3,elem)-alpha_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */
//  CHECKING F_IJ
        VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        averaged_sum_Si(S_i, new_mass, delta_phi, ret0);
        averaged_sum_Si(S_i, new_D, phi_old, ret1);
        VECTOR f_i = (ret0 + dt * ret1);

        VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
        sum_Si(S_i, f_ij, One_Vec, f_i_NEW);

//std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;

        return ret;

    }


    template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
    VECTOR f_ij_creator(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, T dt, const MATRIX &D_ij,
                        const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

        MATRIX new_mass = -mass;
        MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
        for (size_t i = 0; i < new_mass.rows(); i++) {
            new_mass(i, i) += lumped_mass(i);
        }

/*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

        VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
        averaged_sum_Si(S_i, new_mass, delta_phi, ret0);
        averaged_sum_Si(S_i, new_D, phi_old, ret1);
/*
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter) += mat(counter,elem)*(vec(elem)-vec(counter));
        }
        counter++;
    }
    */
//  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

//    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
//    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

        return (ret0 + dt * ret1);

    }

    template<typename FUNCTION, typename T>
    void mapping_phi(FUNCTION &phi, T phi_max, T phi_min) {
        Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones(phi.vertices.rows(), 1);
        Matrix <T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(phi.values_bis.rows(),
                                                                                        phi.values_bis.cols());
// mapping between 0 and 1
        phi.vertices = (phi.vertices - phi_min * Vec_One) / (phi_max - phi_min);
        phi.values_bis = (phi.values_bis - phi_min * Mat_One) / (phi_max - phi_min);
    }

    template<typename FUNCTION, typename T>
    void inverse_mapping_phi(FUNCTION &phi, T phi_max, T phi_min) {
        Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones(phi.vertices.rows(), 1);
        Matrix <T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(phi.values_bis.rows(),
                                                                                        phi.values_bis.cols());
        phi.vertices = phi_min * Vec_One + phi.vertices * (phi_max - phi_min);
        phi.values_bis = phi_min * Mat_One + phi.values_bis * (phi_max - phi_min);
    }


    template<typename LS, typename VL>
    void
    savingVelocityLevelSet(const LS &level_set, const VL &u) {
        auto ls = level_set.sol_FEM;
        auto ls_ndofFE = level_set.ndof_FE;
        auto u0 = u.sol_FEM.first;
        auto u1 = u.sol_FEM.second;
        auto u_ndofFE = u.ndof_FE;
/*
    postprocess_output<double> postoutput;

    auto test_ls  = std::make_shared< gnuplot_output_object<double> >("HHO_level_set.dat");
    auto test_u0  = std::make_shared< gnuplot_output_object<double> >("HHO_velocityX.dat");
    auto test_u1  = std::make_shared< gnuplot_output_object<double> >("HHO_velocityY.dat");

    for( size_t iLS  = 0 ; iLS < ls_ndofFE ; iLS++ )
        // test_ls->add_data(ls);

    for( size_t iLS  = 0 ; iLS < ls_ndofFE ; iLS++ )
    {
        // test_u0->add_data(node,valueD);
        // test_u1->add_data(node,valueD);
    }



    postoutput.add_object(test_ls);
    postoutput.add_object(test_u0);
    postoutput.add_object(test_u1);


    postoutput.write();
    */


        std::string filename_ls = "FEM_level_set.txt";
        std::ofstream interface_fileLS(filename_ls, std::ios::out | std::ios::trunc);


        if (interface_fileLS) {
            for (size_t iLS = 0; iLS < ls_ndofFE; iLS++) {
                interface_fileLS << std::setprecision(15) << ls(iLS) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< ls(iLS) <<std::endl;
            }
            interface_fileLS.close();

        } else
            std::cerr << "File 'FEM_level_set' has not been opened" << std::endl;


        std::string filename_u0 = "FEM_velocityX.txt";
        std::ofstream interface_fileU0(filename_u0, std::ios::out | std::ios::trunc);


        if (interface_fileU0) {
            for (size_t iU = 0; iU < u_ndofFE; iU++) {
                interface_fileU0 << std::setprecision(15) << u0(iU) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< u0(iU) <<std::endl;
            }
            interface_fileU0.close();

        } else
            std::cerr << "File 'FEM_velocityX' has not been opened" << std::endl;

        std::string filename_u1 = "FEM_velocityY.txt";
        std::ofstream interface_fileU1(filename_u1, std::ios::out | std::ios::trunc);


        if (interface_fileU0) {
            for (size_t iU = 0; iU < u_ndofFE; iU++) {
                interface_fileU1 << std::setprecision(15) << u1(iU) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< u1(iU) <<std::endl;
            }
            interface_fileU1.close();

        } else
            std::cerr << "File 'FEM_velocityY' has not been opened" << std::endl;


    }



}


