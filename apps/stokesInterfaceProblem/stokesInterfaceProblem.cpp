/*
 *       /\        Guillaume Delay 2018,2019
 *      /__\       guillaume.delay@enpc.fr
 *     /_\/_\      École Nationale des Ponts et Chaussées - CERMICS
 *    /\    /\
 *   /__\  /__\    This is ProtoN, a library for fast Prototyping of
 *  /_\/_\/_\/_\   Numerical methods.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * If you use this code or parts of it for scientific publications, you
 * are required to cite it as following:
 *
 * Implementation of Discontinuous Skeletal methods on arbitrary-dimensional,
 * polytopal meshes using generic programming.
 * M. Cicuttin, D. A. Di Pietro, A. Ern.
 * Journal of Computational and Applied Mathematics.
 * DOI: 10.1016/j.cam.2017.09.017
 */

#include

<iostream>

#include
<fstream>

#include
<vector>

#include
<array>

#include
<algorithm>

#include
<numeric>

#include
<cassert>

#include
<cmath>

#include
<memory>

#include
<sstream>

#include
<list>

#include
<map>

#include
<iomanip>

#include
<Eigen/Dense>

#include

<Eigen/SparseCore>

#include

<Eigen/SparseLU>

#include

<unsupported/Eigen/SparseExtra>

#include

<Spectra/SymEigsSolver.h>

#include

<Spectra/MatOp/SparseSymMatProd.h>

#include

<unsupported/Eigen/MatrixFunctions> // ADD BY STEFANO

using namespace Eigen;

#include

"core/core"

#include

"core/solvers"

#include

"dataio/silo_io.hpp"

#include

"methods/hho"

#include

"methods/cuthho"

//#include "tbb/tbb.h"
//#define HAVE_INTEL_TBB
//#include "/usr/local/Cellar/tbb/2020_U2/include/tbb/tbb.h"
//#include "/opt/intel/compilers_and_libraries_2020.1.216⁩/mac/tbb/include/tbb/tbb.h"

//using namespace tbb;


///////////////////////   STEFANO FUNCTIONS  ///////////////////////////
/// NEW VERSIONE OF PREVIOUS FUNCTIONS REWRITTEN FOR DISCRETE LEVEL SET FUNCTIONS
template<typename Mesh, typename MeshData, typename T = typename Mesh::coordinate_type>
void mesh_HHO_LS_correlation(Mesh &msh_HHO, Mesh &msh_LS, MeshData &mip_HHO, MeshData &mip_LS, size_t N_LS_sub) {
    size_t N_x_HHO = mip_HHO.Nx;
    size_t N_y_HHO = mip_HHO.Ny;
    const size_t N_tot_HHO = N_x_HHO * N_y_HHO;

    size_t N_x_LS = mip_LS.Nx;
    size_t N_y_LS = mip_LS.Ny;
    const size_t N_tot_LS = N_x_LS * N_y_LS;

    const size_t Nsub_cell = N_LS_sub * N_LS_sub;

//    std::array<std::array<size_t,Nsub_cell>,N_tot_LS> mapping_LS_HHO;
//    std::array<std::array<size_t,1>,N_tot_HHO> mapping_HHO_LS;

    Eigen::Matrix <size_t, Dynamic, Dynamic> mapping_LS_HHO = Eigen::Matrix<size_t, Dynamic, Dynamic>::Zero(N_tot_LS,
                                                                                                            Nsub_cell);

    Eigen::Matrix<size_t, Dynamic, 1> mapping_HHO_LS = Eigen::Matrix<size_t, Dynamic, 1>::Zero(N_tot_HHO, 1);


    size_t counter = 0;
    size_t i_gl = 0;
    for (size_t j = 0; j < N_y_LS; j++) {
        for (size_t i = 0; i < N_x_LS; i++) {
            size_t counter_loc = 0;
            for (size_t i_loc = i_gl; i_loc < i_gl + N_LS_sub; i_loc++) {
                for (size_t j_loc = 0; j_loc < N_LS_sub; j_loc++) {
                    mapping_LS_HHO(counter, counter_loc) = i_loc + (N_LS_sub - 1) * N_y_HHO * j + j_loc * N_y_HHO;
                    mapping_HHO_LS(i_loc + (N_LS_sub - 1) * N_y_HHO * j + j_loc * N_y_HHO) = counter;
                    counter_loc++;
                }


            }
            i_gl += N_LS_sub;
            counter++;
        }
    }

    std::cout << "mapping_LS_HHO" << '\n' << mapping_LS_HHO << '\n' << "mapping_HHO_LS" << '\n' << mapping_HHO_LS
              << std::endl;

}

/// Each mesh has memory of the original nodes: useful to link agglomerated - original mesh
template<typename Mesh>
void offset_definition(Mesh &msh) {
//size_t counter = 0;
    for (auto &cl: msh.cells) {
        auto offset_orig = offset(msh, cl);
//if( !cl.user_data.offset_subcells.empty() )
//   cl.user_data.offset_subcells.erase( cl.user_data.offset_subcells.begin(),cl.user_data.offset_subcells.end() ) ;
        cl.user_data.offset_subcells.push_back(offset_orig);
// counter++;
// std::cout<<"Initialisation cell num "<< cl.user_data.offset_subcells[offset_orig]<<std::endl;
    }
}


template<typename T>
std::vector <point<T, 1>>
reference_nodes_ordered(size_t degree) {
    auto comp_degree = degree + 1;
    size_t reqd_nodes = comp_degree;

    std::vector <point<T, 1>> ret;
    ret.reserve(reqd_nodes);

    point<T, 1> qp, qp_1;
    T a1, a2;
    T delta_x;
    switch (reqd_nodes) {
        case 1:
            qp = point<T, 1>({
                                     0.0
                             });
            ret.push_back(qp);
            return ret;

        case 2:
            qp = point<T, 1>({
                                     1.0
                             });
            ret.push_back(-qp);
            ret.push_back(qp);
            return ret;

        case 3:
            qp = point<T, 1>({
                                     1.0
                             });
            ret.push_back(-qp);
            ret.push_back(qp);
            qp = point<T, 1>({0.0});
            ret.push_back(qp);
            return ret;

        case 4:
            a1 = 1.0 / 3.0;
            qp = point<T, 1>({1.0});
            ret.push_back(-qp);
            ret.push_back(qp);
            qp = point<T, 1>({a1});
            ret.push_back(-qp);
            ret.push_back(qp);
            return ret;

        case 5:
// Be carefull in what order data is inserted in ret!
// In Gauss Legendre the first one was 0.0, now is the last one
            a2 = 0.5;
            a1 = 1.0;
            qp = point<T, 1>({a1});
            ret.push_back(-qp);
            ret.push_back(qp);

            qp = point<T, 1>({a2});
            ret.push_back(-qp);
            qp_1 = point<T, 1>({0.0});
            ret.push_back(qp_1);
            ret.push_back(qp);

//   qp = point<T,1>({ 0.0 });
//   ret.push_back( qp );
            return ret;

        default:

            delta_x = 2.0 / degree;
            a1 = 1.0;
            while (a1 > 1e-10) {
                qp = point<T, 1>({
                                         a1
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                a1 -= delta_x;

            }
            if (a1 < 1e-10 && a1 > -1e-10) {
                qp = point<T, 1>({
                                         0.0
                                 });
                ret.push_back(qp);
            }
            std::sort(ret.begin() + 2, ret.end(), [](point<T, 1> a, point<T, 1> b) {
                return a.x() < b.x();
            });
            return ret;
    }
    return ret;
}

// Lagrangian basis b_kl(x,y) = b_k(x)*b_l(y) over a set of equidistributed 2-dimensional nodes (3D CASE NOT YET IMPLEMENTED)

template<typename T, typename Mesh>
std::vector <point<T, 2>>
equidistriduted_nodes_ordered_bis(const Mesh &msh,
                                  const typename Mesh::cell_type &cl,
                                  size_t degree) {
    typedef typename Mesh::point_type point_type;

    auto qps = reference_nodes_ordered<T>(degree); //Ordering:  0 2 3 4 5 6 ... 1

// 3 -  12 - 11 - 10 - 2
// 13 - 22 - 21 - 20 - 9
// 14 - 23 - 24 - 19 - 8
// 15 - 16 - 17 - 18 - 7
// 0 -  4 -  5  - 6  - 1

    auto pts = points(msh, cl);

//auto v0 = pts[1] - pts[0];
//auto v1 = pts[2] - pts[1];
//auto v2 = pts[3] - pts[2];
//auto v3 = pts[3] - pts[0];

    std::vector <point<T, 2>> ret((degree + 1) * (degree + 1));

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].x() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].x() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].x() * (1 - xi) * (1 + eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].y() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].y() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].y() * (1 - xi) * (1 + eta);
    };

/// ADDING VERTICES:

// (-1,-1)
    auto qp_x = qps[0];
    auto qp_y = qps[0];
    auto xi = qp_x.x();
    auto eta = qp_y.x();
    auto px = P(xi, eta);
    auto py = Q(xi, eta);
    ret[0] = (point_type(px, py));

    if (degree == 0)
        return ret;

// (1,-1)
    qp_x = qps[1];
    qp_y = qps[0];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[1] = (point_type(px, py));
// (1,1)
    qp_x = qps[1];
    qp_y = qps[1];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[2] = (point_type(px, py));
// (-1,1)
    qp_x = qps[0];
    qp_y = qps[1];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[3] = (point_type(px, py));

/// Counter for each side of the 2D - square : starting to count from a vertice, the position where I save the point in ret is (degree -1)*j , with j the j-esima face.

    int count0 = 4, count1 = 4 + degree - 1, count2 = 4 + 2 * (degree - 1), count3 = 4 + 3 * (degree - 1);

    int count_bis0 = 4 * degree; // counter initialisation (USELESS)
    int j_max = floor((degree - 1) / 2); // number of internal layour of points
//  std::cout<<"j max "<<j_max<<std::endl;
    int pos_right = 100; // initial point from the right from bottom -> up
    int pos_left = 100; // initial point from the left from left -> right
// size_t i_min = 0;
//   std::cout<<"inizia ciclo"<<std::endl;
    for (int j = 0; j <= j_max; j++) { // for each layout of point
// bool i_loop = FALSE;
        for (int i = std::max(0, j - 1);
             i < degree - 1 - j; i++) // I move from into the points over a side of each layout
        {

            if (i == std::max(0, j - 1) && j > 0) // vertices
            {
// different pos_left depending on the layout. Especially this rules the y starting point
                if (j == 0)
                    pos_left = 0;
                else if (j == 1)
                    pos_left = 2;
                else
                    pos_left = 2 + (j - 1);

//   std::cout<<"pos_left "<<pos_left<<std::endl;
                qp_x = qps[2 + i];
                qp_y = qps[pos_left]; //qps[0 + 2*j];
//   std::cout<<"qp_y "<<qp_y<<std::endl;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
// Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
//std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                ret[count_bis0] = (point_type(px, py)); // adding point bottom layout
//std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count0]<<std::endl;
                count_bis0++;

                if (j == 0)
                    pos_right = 1;
                else
                    pos_right = degree + 1 - j;
// size_t pos = (1 + j*(degree-1));
// if(pos>degree)
//     pos -= j*degree ;

                qp_x = qps[pos_right];
                qp_y = qps[2 + i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = (point_type(px, py)); // adding point right layout in count_bis0 pos.
//std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
//std::cout<<"count_bis0 is "<<count_bis0<<std::endl;
//std::cout<<ret[count_bis0]<<std::endl;
                count_bis0++;

                qp_x = qps[degree - i];
                qp_y = qps[pos_right];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = (point_type(px, py)); // adding point top layout in count_bis0 pos.
//std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
//std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;

                count_bis0++;
                qp_x = qps[pos_left];
                qp_y = qps[degree - i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = (point_type(px, py)); // adding point left layout in count_bis0 pos.
//std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
//std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                count_bis0++;

// Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                count0 = count_bis0;
                count1 = count0 + degree - 1.0 - 2.0 * j; //  count0 + (degree - 2); it was
                count2 = count1 + degree - 1.0 - 2.0 * j;
                count3 = count2 + degree - 1.0 - 2.0 * j;


            } else // NOT vertices -> node in the sides of each layout
            {

//   std::cout<<"i "<<i<<" j "<<j<<std::endl;
// vertical position where starting for each bottom side layout.
                if (j == 0)
                    pos_left = 0;
                else if (j == 1)
                    pos_left = 2;
                else
                    pos_left = 2 + (j - 1);

//   std::cout<<"pos_left "<<pos_left<<std::endl;
                qp_x = qps[2 + i];
                qp_y = qps[pos_left]; //qps[0 + 2*j];
//   std::cout<<"qp_y "<<qp_y<<std::endl;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count0] = (point_type(px, py)); // from left, node of each bottom side layout
//std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count0]<<std::endl;
                count0++;
// x-position where to start to increase to get points for each right side layout of points
                if (j == 0)
                    pos_right = 1;
                else
                    pos_right = degree + 1 - j;
// size_t pos = (1 + j*(degree-1));
// if(pos>degree)
//     pos -= j*degree ;

                qp_x = qps[pos_right];
                qp_y = qps[2 + i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count1] = (point_type(px, py)); // using count1 that allows correct enumeration
//std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
//std::cout<<ret[count1]<<std::endl;
                count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                qp_x = qps[degree - i];
                qp_y = qps[pos_right];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count2] = (point_type(px, py));
//std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;
                count2++; // count2 just enumerate top faces' layout

                qp_x = qps[pos_left];
                qp_y = qps[degree - i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count3] = (point_type(px, py));
//std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                count3++; // count3 just enumerate left faces' layout


            }
        }
// Updating for the next layout.
        count0 = count3;
        count1 = count0 + (degree - 2 * (j + 1)); //  count0 + (degree - 2); it was
        count2 = count1 + (degree - 2 * (j + 1));
        count3 = count2 + (degree - 2 * (j + 1));


//}
    }

/// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
    if (degree % 2 == 0) {
        qp_x = qps[degree - floor((degree - 1) / 2)];
        qp_y = qps[degree - floor((degree - 1) / 2)];
        xi = qp_x.x();
        eta = qp_y.x();
        px = P(xi, eta);
        py = Q(xi, eta);
        ret[count0] = (point_type(px, py));
//std::cout<<"counto MIDDLE is "<<count0<<" , pt3"<<point_type(px, py)<<std::endl;
    }
    return ret;
}


/// Lagrangian nodes saved in each cell of orginal mesh -> useful for connecting HHO velocity field and transport velocity field
template<typename Mesh, typename T = typename Mesh::coordinate_type>
void nodes_Lagrangian_cell_definition(Mesh &msh, size_t degree) {
//size_t counter = 0;
    for (auto &cl: msh.cells) {
        cl.user_data.Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);

    }
}


/// Useful to plot level set pre FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function>
void
output_mesh_info2_pre_FEM(const Mesh &msh, const Function &level_set_function) {
    using RealType = typename Mesh::coordinate_type;

/************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_meshinfo_preFEM_Stokes.silo");
    silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector <RealType> cut_cell_markers;
    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            cut_cell_markers.push_back(1.0);
        else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            cut_cell_markers.push_back(-1.0);
        else if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector <RealType> highlight_markers;
    for (auto &cl: msh.cells) {
        if (cl.user_data.highlight)
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(),
                      zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector <RealType> level_set_vals;
// for (auto& pt : msh.points)
//    level_set_vals.push_back( level_set_function(pt) );
    for (auto &n: msh.nodes)
        level_set_vals.push_back(level_set_function(n));

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector <RealType> node_pos;
    for (auto &n: msh.nodes)
        node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector <RealType> cell_set;
    for (auto &cl: msh.cells) {
        RealType r;

        switch (cl.user_data.agglo_set) {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back(r);
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

/*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector <RealType> int_pts_x;
    std::vector <RealType> int_pts_y;

    for (auto &fc: msh.faces) {
        if (fc.user_data.location != element_location::ON_INTERFACE) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file_pre_FEM("int_points_pre_FEM.3D", std::ios::out | std::ios::trunc);

    if (points_file_pre_FEM) {
// instructions
        points_file_pre_FEM << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_pts_x.size(); i++) {
            points_file_pre_FEM << int_pts_x[i] << "   " << int_pts_y[i]
                                << "   0.0     0.0" << std::endl;
        }

        points_file_pre_FEM.close();
    } else
        std::cerr << "points_file_pre_FEM has not been opened" << std::endl;


/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector <RealType> int_x;
    std::vector <RealType> int_y;

    for (auto &cl: msh.cells) {
        if (cl.user_data.location != element_location::ON_INTERFACE) continue;

        for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }
    std::ofstream interface_file_preFEM("interface_pre_FEM_Stokes.3D", std::ios::out | std::ios::trunc);

    if (interface_file_preFEM) {
// instructions
        interface_file_preFEM << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x.size(); i++) {
            interface_file_preFEM << int_x[i] << "   " << int_y[i]
                                  << "   0.0     0.0" << std::endl;
        }

        interface_file_preFEM.close();
    } else
        std::cerr << "interface_file_preFEM has not been opened" << std::endl;
}


template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time_fast_para(const Mesh &msh, const VEC &interface_gamma, const VEC &tangent_gamma,
                               const VEC &normal_gamma, const std::vector <T> &curvature_gamma) {

    std::string filename_stokes4 = "tangent_gamma_para.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
// << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file4 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << tangent_gamma[i](0) << "   " << tangent_gamma[i](1) << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;

    std::string filename_stokes0 = "normal_gamma_para.3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if (interface_file0) {
// instructions
        interface_file0 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
// << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file0 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << normal_gamma[i](0) << "   " << normal_gamma[i](1) << std::endl;

            i++;

        }

        interface_file0.close();
    } else
        std::cerr << "File 'normal_gamma' has not been opened" << std::endl;

    std::string filename_stokes1 = "curvature_gamma_para.3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

    if (interface_file1) {
// instructions
        interface_file1 << "X   Y   val0" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
//<< std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file1 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << curvature_gamma[i] << std::endl;

            i++;

        }

        interface_file1.close();
    } else
        std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}


template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time_fast_para_cont(const Mesh &msh, const VEC &interface_gamma, const VEC &tangent_gamma,
                                    const VEC &normal_gamma, const std::vector <T> &curvature_gamma) {

    std::string filename_stokes4 = "tangent_gamma_para_cont.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
// << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file4 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << tangent_gamma[i](0) << "   " << tangent_gamma[i](1) << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;

    std::string filename_stokes0 = "normal_gamma_para_cont.3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if (interface_file0) {
// instructions
        interface_file0 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
// << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file0 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << normal_gamma[i](0) << "   " << normal_gamma[i](1) << std::endl;

            i++;

        }

        interface_file0.close();
    } else
        std::cerr << "File 'normal_gamma' has not been opened" << std::endl;

    std::string filename_stokes1 = "curvature_gamma_para_cont.3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

    if (interface_file1) {
// instructions
        interface_file1 << "X   Y   val0" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;  << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file1 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << curvature_gamma[i] << std::endl;

            i++;

        }

        interface_file1.close();
    } else
        std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}


template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time_fast(const Mesh &msh, const VEC &interface_gamma, const VEC &tangent_gamma,
                          const VEC &normal_gamma, const std::vector <T> &curvature_gamma) {

    std::string filename_stokes4 = "tangent_gamma.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl; << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file4 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << tangent_gamma[i](0) << "   " << tangent_gamma[i](1) << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;

    std::string filename_stokes0 = "normal_gamma.3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if (interface_file0) {
// instructions
        interface_file0 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl; << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file0 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << normal_gamma[i](0) << "   " << normal_gamma[i](1) << std::endl;

            i++;

        }

        interface_file0.close();
    } else
        std::cerr << "File 'normal_gamma' has not been opened" << std::endl;

    std::string filename_stokes1 = "curvature_gamma.3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

    if (interface_file1) {
// instructions
        interface_file1 << "X   Y   val0" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_gamma.begin();
             interface_point < interface_gamma.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl; << std::setprecision(std::numeric_limits<long double>::digits10 + 1)
            interface_file1 << (*interface_point)(0) << "   " << (*interface_point)(1) << "   "
                            << curvature_gamma[i] << std::endl;

            i++;

        }

        interface_file1.close();
    } else
        std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}

template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time_fast(const Mesh &msh, const VEC &interface_points, const std::vector <T> &val_u_n,
                          const std::vector <std::pair<T, T>> &vec_n, size_t time_step, std::string &folder) {

    std::string filename_stokes4 = folder + "vec_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_n[i] * vec_n[i].first << "   " << val_u_n[i] * vec_n[i].second << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

    std::string filename_stokes7 = folder + "vec_normal_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file7(filename_stokes7, std::ios::out | std::ios::trunc);

    if (interface_file7) {
// instructions
        interface_file7 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file7 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << vec_n[i].first << "   " << vec_n[i].second << std::endl;

            i++;

        }

        interface_file7.close();
    } else
        std::cerr << "File 'vec_normal_' has not been opened" << std::endl;

}


template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time(const Mesh &msh, const VEC &interface_points, const std::vector <T> &val_u_n,
                     const std::vector <std::pair<T, T>> &vec_u_n, const std::vector <std::pair<T, T>> &velocity_field,
                     const std::vector <std::pair<T, T>> &points_vel_field, size_t time_step) {
/*
    std::string filename_stokes0 = "val_u_nx_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if(interface_file0)
    {
        // instructions
        interface_file0 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file0 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_nx[i] << "    0.0"<< std::endl;

            i++;

        }

        interface_file0.close();
    }
    else
        std::cerr << "File 'val_u_nx' has not been opened" << std::endl;

    std::string filename_stokes1 = "val_u_ny_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

       if(interface_file1)
       {
           // instructions
           interface_file1 << "X   Y   Z   val" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
           {
               //std::cout<<val_u_ny[i]<<std::endl;
               interface_file1 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
               << val_u_ny[i] << "    0.0"<< std::endl;
               i++;
           }

           interface_file1.close();
       }
       else
           std::cerr << "File 'val_u_ny' has not been opened" << std::endl;


    std::string filename_stokes2 = "val_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file2(filename_stokes2, std::ios::out | std::ios::trunc);

    if(interface_file2)
    {
        // instructions
        interface_file2 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_n[i]<<std::endl;
            interface_file2 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i] << "    0.0"<< std::endl;
            i++;
        }

        interface_file2.close();
    }
    else
        std::cerr << "File 'val_u_n' has not been opened" << std::endl;



    postprocess_output<double> postoutput_vec_u_n;
    std::string filename_stokes3 = "vec_u_n_" + std::to_string(time_step) + ".dat";
    auto test_vec_u_n = std::make_shared< gnuplot_output_object_vec<double> >(filename_stokes3);

    size_t i = 0;
    for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
    {
        test_vec_u_n->add_data(*interface_point,std::make_pair( val_u_n[i]*vec_u_n[i].first , val_u_n[i]*vec_u_n[i].second ) );
        i++;
    }

    postoutput_vec_u_n.add_object(test_vec_u_n);
    postoutput_vec_u_n.write();

   */
    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_n[i] * vec_u_n[i].first << "   " << val_u_n[i] * vec_u_n[i].second << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

/*
    std::string filename_stokes5 = "velocity_interface_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file5(filename_stokes5, std::ios::out | std::ios::trunc);

    if(interface_file5)
    {
        // instructions
        interface_file5 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file5 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << velocity_interface[i].first << "   " << velocity_interface[i].second<< std::endl;

            i++;

        }

        interface_file5.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

     */
//    std::string filename_stokes6 = "velocity_field_" + std::to_string(time_step) + ".3D";
    std::string filename_stokes6 = "velocity_field_.3D";
    std::ofstream interface_file6(filename_stokes6, std::ios::out | std::ios::trunc);

    if (interface_file6) {
// instructions
        interface_file6 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto point_vel = points_vel_field.begin(); point_vel < points_vel_field.end(); point_vel++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file6 << (*point_vel).first << "   " << (*point_vel).second << "   "
                            << velocity_field[i].first << "   " << velocity_field[i].second << std::endl;

            i++;

        }

        interface_file6.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;
/*
    std::string filename_stokes7 = "vec_normal_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file7(filename_stokes7, std::ios::out | std::ios::trunc);

    if(interface_file7)
    {
        // instructions
        interface_file7 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file7 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << vec_u_n[i].first << "   " << vec_u_n[i].second<< std::endl;

            i++;

        }

        interface_file7.close();
    }
    else
        std::cerr << "File 'vec_normal_' has not been opened" << std::endl;
    */
}


template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time(const Mesh &msh, T time, const VEC &interface_points, const std::vector <T> &val_u_nx,
                     const std::vector <T> &val_u_ny, const std::vector <T> &val_u_n,
                     const std::vector <std::pair<T, T>> &vec_u_n,
                     const std::vector <std::pair<T, T>> &velocity_interface,
                     const std::vector <std::pair<T, T>> &velocity_field,
                     const std::vector <std::pair<T, T>> &points_vel_field, size_t time_step) {
/*
    std::string filename_stokes0 = "val_u_nx_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if(interface_file0)
    {
        // instructions
        interface_file0 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file0 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_nx[i] << "    0.0"<< std::endl;

            i++;

        }

        interface_file0.close();
    }
    else
        std::cerr << "File 'val_u_nx' has not been opened" << std::endl;

    std::string filename_stokes1 = "val_u_ny_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

       if(interface_file1)
       {
           // instructions
           interface_file1 << "X   Y   Z   val" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
           {
               //std::cout<<val_u_ny[i]<<std::endl;
               interface_file1 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
               << val_u_ny[i] << "    0.0"<< std::endl;
               i++;
           }

           interface_file1.close();
       }
       else
           std::cerr << "File 'val_u_ny' has not been opened" << std::endl;


    std::string filename_stokes2 = "val_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file2(filename_stokes2, std::ios::out | std::ios::trunc);

    if(interface_file2)
    {
        // instructions
        interface_file2 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_n[i]<<std::endl;
            interface_file2 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i] << "    0.0"<< std::endl;
            i++;
        }

        interface_file2.close();
    }
    else
        std::cerr << "File 'val_u_n' has not been opened" << std::endl;



    postprocess_output<double> postoutput_vec_u_n;
    std::string filename_stokes3 = "vec_u_n_" + std::to_string(time_step) + ".dat";
    auto test_vec_u_n = std::make_shared< gnuplot_output_object_vec<double> >(filename_stokes3);

    size_t i = 0;
    for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
    {
        test_vec_u_n->add_data(*interface_point,std::make_pair( val_u_n[i]*vec_u_n[i].first , val_u_n[i]*vec_u_n[i].second ) );
        i++;
    }

    postoutput_vec_u_n.add_object(test_vec_u_n);
    postoutput_vec_u_n.write();

   */
    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_n[i] * vec_u_n[i].first << "   " << val_u_n[i] * vec_u_n[i].second << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

/*
    std::string filename_stokes5 = "velocity_interface_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file5(filename_stokes5, std::ios::out | std::ios::trunc);

    if(interface_file5)
    {
        // instructions
        interface_file5 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file5 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << velocity_interface[i].first << "   " << velocity_interface[i].second<< std::endl;

            i++;

        }

        interface_file5.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

     */
//    std::string filename_stokes6 = "velocity_field_" + std::to_string(time_step) + ".3D";
    std::string filename_stokes6 = "velocity_field_.3D";
    std::ofstream interface_file6(filename_stokes6, std::ios::out | std::ios::trunc);

    if (interface_file6) {
// instructions
        interface_file6 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto point_vel = points_vel_field.begin(); point_vel < points_vel_field.end(); point_vel++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file6 << (*point_vel).first << "   " << (*point_vel).second << "   "
                            << velocity_field[i].first << "   " << velocity_field[i].second << std::endl;

            i++;

        }

        interface_file6.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;
/*
    std::string filename_stokes7 = "vec_normal_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file7(filename_stokes7, std::ios::out | std::ios::trunc);

    if(interface_file7)
    {
        // instructions
        interface_file7 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file7 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << vec_u_n[i].first << "   " << vec_u_n[i].second<< std::endl;

            i++;

        }

        interface_file7.close();
    }
    else
        std::cerr << "File 'vec_normal_' has not been opened" << std::endl;
    */
}

template<typename Mesh, typename VEC, typename T>
void
goal_quantities_time(const Mesh &msh, T time, const VEC &interface_points, const std::vector <T> &val_u_nx,
                     const std::vector <T> &val_u_ny, const std::vector <T> &val_u_n,
                     const std::vector <std::pair<T, T>> &vec_u_n) {

    std::string filename_stokes0 = "val_u_nx_" + std::to_string(time) + ".3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if (interface_file0) {
// instructions
        interface_file0 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file0 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_nx[i] << "    0.0" << std::endl;

            i++;

        }

        interface_file0.close();
    } else
        std::cerr << "File 'val_u_nx' has not been opened" << std::endl;

    std::string filename_stokes1 = "val_u_ny_" + std::to_string(time) + ".3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

    if (interface_file1) {
// instructions
        interface_file1 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_ny[i]<<std::endl;
            interface_file1 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_ny[i] << "    0.0" << std::endl;
            i++;
        }

        interface_file1.close();
    } else
        std::cerr << "File 'val_u_ny' has not been opened" << std::endl;


    std::string filename_stokes2 = "val_u_n_" + std::to_string(time) + ".3D";
    std::ofstream interface_file2(filename_stokes2, std::ios::out | std::ios::trunc);

    if (interface_file2) {
// instructions
        interface_file2 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_n[i]<<std::endl;
            interface_file2 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_n[i] << "    0.0" << std::endl;
            i++;
        }

        interface_file2.close();
    } else
        std::cerr << "File 'val_u_n' has not been opened" << std::endl;


    postprocess_output<double> postoutput_vec_u_n;
    std::string filename_stokes3 = "vec_u_n_" + std::to_string(time) + ".dat";
    auto test_vec_u_n = std::make_shared < gnuplot_output_object_vec < double > > (filename_stokes3);

    size_t i = 0;
    for (auto interface_point = interface_points.begin(); interface_point < interface_points.end(); interface_point++) {
        test_vec_u_n->add_data(*interface_point,
                               std::make_pair(val_u_n[i] * vec_u_n[i].first, val_u_n[i] * vec_u_n[i].second));
        i++;
    }

    postoutput_vec_u_n.add_object(test_vec_u_n);
    postoutput_vec_u_n.write();


    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if (interface_file4) {
// instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for (auto interface_point = interface_points.begin();
             interface_point < interface_points.end(); interface_point++) {
//std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " << (*interface_point).y() << "   "
                            << val_u_n[i] * vec_u_n[i].first << "   " << val_u_n[i] * vec_u_n[i].second << std::endl;

            i++;

        }

        interface_file4.close();
    } else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;


}

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function, typename T>
void
output_mesh_info2_time(const Mesh &msh, const Function &level_set_function, T time, size_t time_step,
                       std::string &folder) {
    using RealType = typename Mesh::coordinate_type;

/************** OPEN SILO DATABASE **************/
    silo_database silo;
    std::string filename_silo = folder + "cuthho_meshinfo_Stokes_" + std::to_string(time_step) + ".silo";
    silo.create(filename_silo);
    silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector <RealType> cut_cell_markers;
    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            cut_cell_markers.push_back(1.0);
        else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            cut_cell_markers.push_back(-1.0);
        else if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector <RealType> highlight_markers;
    for (auto &cl: msh.cells) {
        if (cl.user_data.highlight)
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(),
                      zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector <RealType> level_set_vals;
// for (auto& pt : msh.points)
//    level_set_vals.push_back( level_set_function(pt) );
    for (auto &n: msh.nodes)
        level_set_vals.push_back(level_set_function(n));

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector <RealType> node_pos;
    for (auto &n: msh.nodes)
        node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector <RealType> cell_set;
    for (auto &cl: msh.cells) {
        RealType r;

        switch (cl.user_data.agglo_set) {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back(r);
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

/*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector <RealType> int_pts_x;
    std::vector <RealType> int_pts_y;

    for (auto &fc: msh.faces) {
        if (fc.user_data.location != element_location::ON_INTERFACE) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file(folder + "int_points.3D", std::ios::out | std::ios::trunc);

    if (points_file) {
// instructions
        points_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_pts_x.size(); i++) {
            points_file << int_pts_x[i] << "   " << int_pts_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        points_file.close();
    } else
        std::cerr << "Points_file has not been opened" << std::endl;


/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector <RealType> int_x;
    std::vector <RealType> int_y;

    for (auto &cl: msh.cells) {
        if (cl.user_data.location != element_location::ON_INTERFACE) continue;

        for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }

    std::string filename_interface_Stokes = folder + "interface_Stokes_" + std::to_string(time_step) + ".3D";

    std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x.size(); i++) {
            interface_file << int_x[i] << "   " << int_y[i]
                           << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;
}


/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function>
void
output_mesh_info_ls_l_n(const Mesh &msh, const Function &ls) {
// Plotting of parametric interface (l,n)
// l = degree
// n = # of cells
    using RealType = typename Mesh::coordinate_type;



/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector <RealType> int_x;
    std::vector <RealType> int_y;

    auto interface0 = ls.interface0;
    auto interface1 = ls.interface1;
    interface0.rows();
    auto nOfRow = interface0.rows();
    auto nOfCol = interface0.cols();
    for (auto i = 0; i < nOfRow; i++) {
        for (auto j = 0; j < nOfCol; j++) {
            RealType x = interface0(i, j);
            RealType y = interface1(i, j);

            int_x.push_back(x);
            int_y.push_back(y);

        }
    }


    std::string filename_interface_Stokes = "parametric_interface_Stokes.3D";

    std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x.size(); i++) {
            interface_file << int_x[i] << "   " << int_y[i]
                           << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    std::vector <RealType> int_x1;
    std::vector <RealType> int_y1;


    for (auto &cl: msh.cells) {


        if (cl.user_data.location == element_location::ON_INTERFACE) {

            auto global_cells_i = ls.get_global_cells_interface(msh, cl);
            auto integration_msh = cl.user_data.integration_msh;


            auto qps_un = edge_quadrature<RealType>(100);

            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++) {
                auto pts = points(integration_msh, integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell];

                for (auto &qp: qps_un) {
                    auto t = 0.5 * qp.first.x() + 0.5;

                    auto p = ls(t, global_cl_i);

                    int_x1.push_back(p(0));
                    int_y1.push_back(p(1));


                }
            }
        }
    }


    std::string filename_interface_Stokes1 = "parametric_interface_Stokes_multipts.3D";

    std::ofstream interface_file1(filename_interface_Stokes1, std::ios::out | std::ios::trunc);

    if (interface_file1) {
// instructions
        interface_file1 << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x1.size(); i++) {
            interface_file1 << int_x1[i] << "   " << int_y1[i]
                            << "   0.0     0.0" << std::endl;
        }

        interface_file1.close();
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


}

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function, typename T>
void
output_mesh_info2_time_fixed_mesh(const Mesh &msh, const Function &level_set_function, T time, size_t time_step) {
    using RealType = typename Mesh::coordinate_type;



/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector <RealType> int_x;
    std::vector <RealType> int_y;

    for (auto &cl: msh.cells) {
        if (cl.user_data.location != element_location::ON_INTERFACE) continue;

        for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }

    std::string filename_interface_Stokes = "interface_Stokes_" + std::to_string(time_step) + ".3D";

    std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x.size(); i++) {
            interface_file << int_x[i] << "   " << int_y[i]
                           << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;
}

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function>
void
output_mesh_info2(const Mesh &msh, const Function &level_set_function) {
    using RealType = typename Mesh::coordinate_type;

/************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_meshinfo_Stokes.silo");
    silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector <RealType> cut_cell_markers;
    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            cut_cell_markers.push_back(1.0);
        else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            cut_cell_markers.push_back(-1.0);
        else if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector <RealType> highlight_markers;
    for (auto &cl: msh.cells) {
        if (cl.user_data.highlight)
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(),
                      zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector <RealType> level_set_vals;
// for (auto& pt : msh.points)
//    level_set_vals.push_back( level_set_function(pt) );
    for (auto &n: msh.nodes)
        level_set_vals.push_back(level_set_function(n));

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector <RealType> node_pos;
    for (auto &n: msh.nodes)
        node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector <RealType> cell_set;
    for (auto &cl: msh.cells) {
        RealType r;

        switch (cl.user_data.agglo_set) {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back(r);
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

/*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector <RealType> int_pts_x;
    std::vector <RealType> int_pts_y;

    for (auto &fc: msh.faces) {
        if (fc.user_data.location != element_location::ON_INTERFACE) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file("int_points.3D", std::ios::out | std::ios::trunc);

    if (points_file) {
// instructions
        points_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_pts_x.size(); i++) {
            points_file << int_pts_x[i] << "   " << int_pts_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        points_file.close();
    } else
        std::cerr << "Points_file has not been opened" << std::endl;


/*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector <RealType> int_x;
    std::vector <RealType> int_y;

    for (auto &cl: msh.cells) {
        if (cl.user_data.location != element_location::ON_INTERFACE) continue;

        for (size_t i = 0; i < cl.user_data.interface.size(); i++) {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }
    std::ofstream interface_file("interface_Stokes.3D", std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for (size_t i = 0; i < int_x.size(); i++) {
            interface_file << int_x[i] << "   " << int_y[i]
                           << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_on_face(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                           const T &threshold, const Mesh &msh, const typename Mesh::face_type &fc) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa + pb) / 2.0;
    auto pm_prev = pm;

    T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50;

    do {
        auto la = level_set_function(pa, msh, fc);
        auto lb = level_set_function(pb, msh, fc);
        auto lm = level_set_function(pm, msh, fc);

        if ((lb >= 0 && lm >= 0) || (lb < 0 && lm < 0)) {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa + pb) / 2.0;
        } else {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa + pb) / 2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

    return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_on_face3(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                            const T &threshold, const Mesh &msh, const typename Mesh::face_type &fc) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa + pb) / 2.0;
    auto pm_prev = pm;
    T iso_val_interface = level_set_function.iso_val_interface;
    T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50;

    do {
//auto la = level_set_function(pa,msh,fc);
        auto lb = level_set_function(pb, msh, fc);
        auto lm = level_set_function(pm, msh, fc);

        if ((lb >= iso_val_interface && lm >= iso_val_interface) ||
            (lb < iso_val_interface && lm < iso_val_interface)) {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa + pb) / 2.0;
        } else {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa + pb) / 2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

    return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_in_cell(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                           const T &threshold, const Mesh &msh, const typename Mesh::cell_type &cl) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa + pb) / 2.0;
    auto pm_prev = pm;

    T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50; // ERA 50, METTO 100

    do {
        auto la = level_set_function(pa, msh, cl);
        auto lb = level_set_function(pb, msh, cl);
        auto lm = level_set_function(pm, msh, cl);

        if ((lb >= 0 && lm >= 0) || (lb < 0 && lm < 0)) {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa + pb) / 2.0;
        } else {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa + pb) / 2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

    return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_in_cell3(const point<T, 2> &p0, const point<T, 2> &p1, const Function &level_set_function,
                            const T &threshold, const Mesh &msh, const typename Mesh::cell_type &cl) {
/* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

// I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa + pb) / 2.0;
    auto pm_prev = pm;
    T iso_val_interface = level_set_function.iso_val_interface;
    T x_diff_sq, y_diff_sq;

/* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50; // ERA 50, METTO 100

    do {
//auto la = level_set_function(pa,msh,cl);
        auto lb = level_set_function(pb, msh, cl);
        auto lm = level_set_function(pm, msh, cl);

        if ((lb >= iso_val_interface && lm >= iso_val_interface) ||
            (lb < iso_val_interface && lm < iso_val_interface)) {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa + pb) / 2.0;
        } else {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa + pb) / 2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ((sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter--);

    return pm;

/* Affine zero crossing was like that: */
//auto t = l0/(l0-l1);
//auto ip = (pts[1] - pts[0]) * t + pts[0];
}


/// New version of detect_node_position for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_node_position2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
    for (auto &n: msh.nodes) {
//auto pt = points(msh, n); //deleted by Stefano
//if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);
        if (std::abs(value_node) < 1e-17) {
            std::cout << "In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!" << std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt);
        }


        if (value_node < 0) // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
        else
            n.user_data.location = element_location::IN_POSITIVE_SIDE;


    }
}


/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_node_position3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {

    timecounter tc;
    tc.tic();
    T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;

    for (auto &n: msh.nodes) {
//auto pt = points(msh, n); //deleted by Stefano
//if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);

        if (std::abs(value_node - iso_val_interface) < 1e-17) {
            std::cout << "In detect_node_position3 -> ATTENTION, INTERFACE ON A NODE!" << std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt);
        }


        if (value_node < iso_val_interface) { // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
//std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        } else {
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
//std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }
//std::cout<<"Value_node = "<< value_node<<std::endl;

    }

    tc.toc();
//std::cout << bold << yellow << "detect_node_position3, time resolution: " << tc << " seconds" << reset << std::endl;
}

/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
/*
template<typename T, size_t ET, typename Function>
void
detect_node_position3_parallel(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    timecounter tc ;
    tc.tic();
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;
#ifdef HAVE_INTEL_TBB
    size_t n_nodes = msh.nodes.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_nodes), size_t(1),
    [&msh,&level_set_function,&iso_val_interface] (size_t & cell_ind){
        auto& n = msh.nodes[cell_ind];
        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }



        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }

    }
    );

    tc.toc();
    //std::cout << "detect_node_position3_parallel, time resolution: " << tc << " seconds" << std::endl;
#else

    for (auto& n : msh.nodes)
    {
        //auto pt = points(msh, n); //deleted by Stefano
        //if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }


        //std::cout<<"value_node SEQUENTIAL = "<<level_set_function(n)<<std::endl;
        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }
        //std::cout<<"Value_node = "<< value_node<<std::endl;

    }


#endif

}
*/
/// New version of detect_cut_faces for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_faces2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
    for (auto &fc: msh.faces) {
        auto pts = points(msh, fc);
/*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
//auto l0 = level_set_function(pts[0]);      //deleted by Stefano
//auto l1 = level_set_function(pts[1]);       //deleted by Stefano

        auto l0 = level_set_function(pts[0], msh, fc);      // add by Stefano
        auto l1 = level_set_function(pts[1], msh, fc);       // add by Stefano

// In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
        if ((std::abs(l0) < 1e-17) && (std::abs(l1) < 1e-17))
            std::cout << "STOP --> CASE DOUBT: l0 = " << l0 << " and l1 = " << l1 << std::endl;

        else if (std::abs(l0) < 1e-17) {
            std::cout << "The node " << pts[0] << " is very close to the interface." << std::endl;
            l0 = level_set_function(pts[0]);
            std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
        } else if (std::abs(l1) < 1e-17) {
            std::cout << "The node " << pts[1] << " is very close to the interface." << std::endl;
            l1 = level_set_function(pts[1]);
            std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
        }
/*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
        if (l0 >= 0 && l1 >= 0) {
            fc.user_data.location = element_location::IN_POSITIVE_SIDE;
            continue;
        }

        if (l0 < 0 && l1 < 0) {
            fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
            continue;
        }


        auto threshold = diameter(msh, fc) / 1e20;
//auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
        auto pm = find_zero_crossing_on_face(pts[0], pts[1], level_set_function, threshold, msh, fc);

/* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
        fc.user_data.node_inside = (l0 < 0) ? 0 : 1;
        fc.user_data.location = element_location::ON_INTERFACE;
        fc.user_data.intersection_point = pm;
    }
}

/// New version of detect_cut_faces for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_faces3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
    T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"In 'detect_cut_face3'--> iso_val_interface = "<<iso_val_interface<<std::endl;
    for (auto &fc: msh.faces) {
        auto pts = points(msh, fc);
/*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
//auto l0 = level_set_function(pts[0]);      //deleted by Stefano
//auto l1 = level_set_function(pts[1]);       //deleted by Stefano

        auto l0 = level_set_function(pts[0], msh, fc);      // add by Stefano
        auto l1 = level_set_function(pts[1], msh, fc);       // add by Stefano
//        std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<<" vs l0 = "<<l0<<std::endl;
//        std::cout<<"level_set_function(pts[1]) = "<<level_set_function(pts[1])<<" vs l1 = "<<l1<<'\n'<<std::endl;

// In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
        if ((std::abs(l0 - iso_val_interface) < 1e-17) && (std::abs(l1 - iso_val_interface) < 1e-17))
            std::cout << "STOP --> CASE DOUBT: l0 = " << l0 << " and l1 = " << l1 << std::endl;

        else if (std::abs(l0 - iso_val_interface) < 1e-17) {
            std::cout << "The node " << pts[0] << " is very close to the interface." << std::endl;
            l0 = level_set_function(pts[0]);
            std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
        } else if (std::abs(l1 - iso_val_interface) < 1e-17) {
            std::cout << "The node " << pts[1] << " is very close to the interface." << std::endl;
            l1 = level_set_function(pts[1]);
            std::cout << "l0 = " << l0 << " ,l1 = " << l1 << '\n' << std::endl;
        }
/*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
        if (l0 >= iso_val_interface && l1 >= iso_val_interface) {
            fc.user_data.location = element_location::IN_POSITIVE_SIDE;
            continue;
        }

        if (l0 < iso_val_interface && l1 < iso_val_interface) {
            fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
            continue;
        }


        auto threshold = diameter(msh, fc) / 1e20;
//auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
        auto pm = find_zero_crossing_on_face3(pts[0], pts[1], level_set_function, threshold, msh, fc);
//std::cout<<"pm = "<<pm<< " and level_set_function = "<<level_set_function(pm,msh,fc)<<std::endl;
/* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
        fc.user_data.node_inside = (l0 < iso_val_interface) ? 0 : 1;
        fc.user_data.location = element_location::ON_INTERFACE;
        fc.user_data.intersection_point = pm;
    }
}

/// New version of detect_cut_cells for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_cells2(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
    std::cout << "I AM IN DETECT CUT CELL2!!!!" << std::endl;
//typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::cell_type cell_type;

    size_t cell_i = 0;
    for (auto &cl: msh.cells) {
        auto fcs = faces(msh, cl);
        std::array<std::pair<size_t, point_type>, 2> cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++) {
            if (is_cut(msh, fcs[i]))
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }

/* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

        if (k == 0) {

            auto is_positive = [&](const point_type &pt) -> bool {
                return level_set_function(pt) > 0;
            };


            auto pts = points(msh, cl);

            if (std::all_of(pts.begin(), pts.end(), is_positive))
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




/*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

        }
//MODIFICARE QUAAAA
        if (k == 2) {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T, 2>(-pt.y(), pt.x());
            auto pn_prova = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
//if(offset(msh,cl)== 119)
//    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
// PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
/*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
            if (offset(msh, cl) == 137 || offset(msh, cl) == 138 || offset(msh, cl) == 134 || offset(msh, cl) == 103) {
                std::cout << yellow << bold << "offset(msh,cl) = " << offset(msh, cl) << reset << std::endl;
                auto pn_bis = (p0 + p1) / 2.0 + point<T, 2>(-pt.y(), pt.x());
                std::cout << "pn_bis = " << pn_bis << " , level_set_function(pn_bis,msh,cl) ="
                          << level_set_function(pn_bis, msh, cl) << std::endl;
                auto pn_bis0 = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
                std::cout << "pn_bis0 = " << pn_bis0 << " , level_set_function(pn_bis0,msh,cl) ="
                          << level_set_function(pn_bis0, msh, cl) << std::endl;
                auto pn_bis1 = p0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
                std::cout << "pn_bis1 = " << pn_bis1 << " , level_set_function(pn_bis1,msh,cl) ="
                          << level_set_function(pn_bis1, msh, cl) << '\n' << std::endl;

                std::cout << "pn = " << pn << " , p0 = " << p0 << " , p1 = " << p1 << std::endl;
                std::cout << "level_set_function(pn,msh,cl) = " << level_set_function(pn, msh, cl)
                          << " , level_set_function(p0,msh,cl) = " << level_set_function(p0, msh, cl)
                          << " , level_set_function(pn,msh,cl) = " << level_set_function(p1, msh, cl) << std::endl;
                std::cout << "p0 - point<T,2>(-pt.y(), pt.x()) = " << p0 - point<T, 2>(-pt.y(), pt.x())
                          << " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "
                          << level_set_function(p0 - point<T, 2>(-pt.y(), pt.x()), msh, cl) << std::endl;
            }


            if (!(std::signbit(level_set_function(pn, msh, cl)) ==
                  std::signbit(level_set_function(pn_prova, msh, cl)))) {
                pn = pn_prova;
                std::cout << "pn = " << pn << " , pn_prova = " << pn_prova << " , level_set_function(pn,msh,cl) = "
                          << level_set_function(pn, msh, cl) << " , level_set_function(pn_prova,msh,cl) = "
                          << level_set_function(pn_prova, msh, cl) << std::endl;
            }

            if (level_set_function(pn, msh, cl) >= 0) {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            } else {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if (k != 0 && k != 2) {
            auto pts = points(msh, cl);
            std::cout << "Point[0] = " << pts[0] << " , point[1] = " << pts[1] << " , point[2] = " << pts[2]
                      << " , point[3] = " << pts[3] << std::endl;
            std::cout << "level_set_function(p0) = " << level_set_function(pts[0], msh, cl)
                      << " , level_set_function(p1) = " << level_set_function(pts[1], msh, cl)
                      << " , level_set_function(p2) = " << level_set_function(pts[2], msh, cl)
                      << " , level_set_function(p3) = " << level_set_function(pts[3], msh, cl) << std::endl;
            for (size_t i = 0; i < fcs.size(); i++) {
                if (is_cut(msh, fcs[i]))
                    std::cout << "fcs[i].user_data.intersection_point = " << fcs[i].user_data.intersection_point
                              << std::endl;
            }

            std::cout << "ERROR: in cut cell " << cell_i << " there are k = " << k << " cuts!!!!" << std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }
}

/// New version of detect_cut_cells for discret level functions -> USING INTERFACE = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_cells3(cuthho_mesh <T, ET> &msh, const Function &level_set_function) {
//std::cout<<"I AM IN DETECT CUT CELL3!!!!"<<std::endl;
    timecounter tc;
    tc.tic();
//typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
    T iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;
    size_t cell_i = 0;
    for (auto &cl: msh.cells) {
        auto fcs = faces(msh, cl);
        std::array<std::pair<size_t, point_type>, 2> cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++) {
            if (is_cut(msh, fcs[i]))
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }

/* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

        if (k == 0) {

            auto is_positive = [&](const point_type &pt) -> bool {
                return level_set_function(pt, msh, cl) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if (std::all_of(pts.begin(), pts.end(), is_positive))
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




/*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

        }
//MODIFICARE QUAAAA
        if (k == 2) {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T, 2>(-pt.y(), pt.x());
            auto pn_prova = (p0 + p1) / 2.0 + 0.5 * point<T, 2>(-pt.y(), pt.x());
//if(offset(msh,cl)== 119)
//    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
// PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
/*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
/*
            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){
                std::cout<<yellow<<bold<<"offset(msh,cl) = "<<offset(msh,cl)<<reset<<std::endl;
                auto pn_bis = (p0+p1)/2.0 + point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis = "<<pn_bis<< " , level_set_function(pn_bis,msh,cl) ="<<level_set_function(pn_bis,msh,cl) <<std::endl;
                auto pn_bis0 = (p0+p1)/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis0 = "<<pn_bis0<< " , level_set_function(pn_bis0,msh,cl) ="<<level_set_function(pn_bis0,msh,cl) <<std::endl;
                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis1 = "<<pn_bis1<< " , level_set_function(pn_bis1,msh,cl) ="<<level_set_function(pn_bis1,msh,cl)<<'\n' <<std::endl;

                std::cout<<"pn = "<<pn<< " , p0 = "<<p0<< " , p1 = "<<p1<<std::endl;
                std::cout<<"level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(p0,msh,cl) = "<<level_set_function(p0,msh,cl)<< " , level_set_function(pn,msh,cl) = "<<level_set_function(p1,msh,cl)<<std::endl;
                std::cout<<"p0 - point<T,2>(-pt.y(), pt.x()) = "<<p0 - point<T,2>(-pt.y(), pt.x())<< " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;
            }
            */

            if (!(std::signbit(level_set_function(pn, msh, cl) - iso_val_interface) ==
                  std::signbit(level_set_function(pn_prova, msh, cl) - iso_val_interface))) {
                std::cout << "p0 = " << p0 << " , p1 = " << p1 << std::endl;
                std::cout << "pn = " << pn << " , pn_prova = " << pn_prova << " , level_set_function(pn,msh,cl) = "
                          << level_set_function(pn, msh, cl) << " , level_set_function(pn_prova,msh,cl) = "
                          << level_set_function(pn_prova, msh, cl) << std::endl;
                pn = pn_prova;
            }

            if (level_set_function(pn, msh, cl) >= iso_val_interface) {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            } else {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if (k != 0 && k != 2) {
            auto pts = points(msh, cl);
            std::cout << "Point[0] = " << pts[0] << " , point[1] = " << pts[1] << " , point[2] = " << pts[2]
                      << " , point[3] = " << pts[3] << std::endl;
            std::cout << "level_set_function(p0) = " << level_set_function(pts[0], msh, cl)
                      << " , level_set_function(p1) = " << level_set_function(pts[1], msh, cl)
                      << " , level_set_function(p2) = " << level_set_function(pts[2], msh, cl)
                      << " , level_set_function(p3) = " << level_set_function(pts[3], msh, cl) << std::endl;
            for (size_t i = 0; i < fcs.size(); i++) {
                if (is_cut(msh, fcs[i]))
                    std::cout << "fcs[i].user_data.intersection_point = " << fcs[i].user_data.intersection_point
                              << std::endl;
            }

            std::cout << "ERROR: in cut cell " << cell_i << " there are k = " << k << " cuts!!!!" << std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }
    tc.toc();
//std::cout << bold << yellow << "detect_cut_cells3, time resolution: " << tc << " seconds" << reset << std::endl;
}

/*
template<typename T, size_t ET, typename Function>
void
detect_cut_cells3_parallelized(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    std::cout<<"I AM IN DETECT CUT CELL3 PARALLELELIZED !!!!"<<std::endl;
    timecounter tc;
    tc.tic();
    //typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;


#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&] (size_t & cell_ind){
        auto& cl = msh.cells[cell_ind];

        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }




        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;






        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!


            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                    std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_ind<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }


    });
    tc.toc();
    std::cout << bold << yellow << "detect_cut_cells3_parallelized, time resolution: " << tc << " seconds" << reset << std::endl;
#else

    size_t cell_i = 0;
    for (auto& cl : msh.cells)
    {
        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }



        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;





        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!

            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                  std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_i<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }

#endif
}
*/
/// New version of refine_interface for discret level functions

template<typename T, size_t ET, typename Function>
void
refine_interface2(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                  const Function &level_set_function, size_t min, size_t max) {
    if ((max - min) < 2)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;

    size_t mid = (max + min) / 2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0 + p1) / 2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;

    auto lm = level_set_function(pm, msh, cl);
    auto ls1 = level_set_function(ps1, msh, cl);
    auto ls2 = level_set_function(ps2, msh, cl);

    point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0))) {
        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold, msh, cl);
    } else if (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0))) {
        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold, msh, cl);
    } else
        throw std::logic_error("interface not found in search range");

    cl.user_data.interface.at(mid) = ip;

    refine_interface2(msh, cl, level_set_function, min, mid);
    refine_interface2(msh, cl, level_set_function, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface2(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
    if (levels == 0)
        return;

    size_t interface_points = iexp_pow(2, levels);

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;


        std::cout << yellow << bold << "--------------------> CELL = " << offset(msh, cl) << "<--------------------"
                  << reset << std::endl;
        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface2(msh, cl, level_set_function, 0, interface_points);

        std::cout << "LIMIT CELL " << offset(msh, cl) << " are:" << std::endl;
        std::cout << "pt[0] = " << points(msh, cl)[0] << " , pt[1] = " << points(msh, cl)[1] << " , pt[2] = "
                  << points(msh, cl)[2] << " , pt[3] = " << points(msh, cl)[3] << std::endl;

        for (size_t i_int = 0; i_int < interface_points + 1; i_int++)
            std::cout << "refined points are p = " << cl.user_data.interface.at(i_int) << std::endl;
        std::cout << "--------------------> CELL = " << offset(msh, cl) << "<--------------------" << std::endl;
    }
}


template<typename T, size_t ET, typename Function>
typename cuthho_mesh<T, ET>::point_type
search_boundary(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q, T lm, const Function &level_set) {
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    auto pts = points(msh, cl);

    point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
    point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
    point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
    point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());
/*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
    auto ls0 = level_set(pt_tmp0, msh, cl);
    auto ls1 = level_set(pt_tmp1, msh, cl);
    auto ls2 = level_set(pt_tmp2, msh, cl);
    auto ls3 = level_set(pt_tmp3, msh, cl);

    if (pt_in_cell(msh, pt_tmp0, cl) && (!((lm >= 0 && ls0 >= 0) || (lm < 0 && ls0 < 0))))
        return pt_tmp0;
    if (pt_in_cell(msh, pt_tmp1, cl) && (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0))))
        return pt_tmp1;
    if (pt_in_cell(msh, pt_tmp2, cl) && (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0))))
        return pt_tmp2;
    if (pt_in_cell(msh, pt_tmp3, cl) && (!((lm >= 0 && ls3 >= 0) || (lm < 0 && ls3 < 0))))
        return pt_tmp3;
    else {
        std::cout << "In cell = " << offset(msh, cl) << " points(msh,cl)[0] = " << points(msh, cl)[0]
                  << " points(msh,cl)[1] = " << points(msh, cl)[1] << " points(msh,cl)[2] = " << points(msh, cl)[2]
                  << " points(msh,cl)[3] = " << points(msh, cl)[3] << std::endl;
        std::cout << "m = " << m << " --> q = " << q << std::endl;
        std::cout << "p_init = " << p_init << " --> pt_tmp0 = " << pt_tmp0 << " , pt_tmp1 = " << pt_tmp1
                  << " , pt_tmp2 = " << pt_tmp2 << " , pt_tmp3 = " << pt_tmp3 << std::endl;
        std::cout << "ls0 = " << ls0 << " , ls1 = " << ls1 << " , ls2 = " << ls2 << " , ls3 = " << ls3 << " AND lm = "
                  << lm << std::endl;
        std::cout << "pt_in_cell( pt_tmp0 ) = " << pt_in_cell(msh, pt_tmp0, cl) << " , pt_in_cell( pt_tmp1 ) = "
                  << pt_in_cell(msh, pt_tmp1, cl) << " , pt_in_cell( pt_tmp2 ) = " << pt_in_cell(msh, pt_tmp2, cl)
                  << " , pt_in_cel( pt_tmp3 ) = " << pt_in_cell(msh, pt_tmp3, cl) << std::endl;
        T pp = pts[0].x();
        T dist = std::abs(pp - p_init.x()) / 10.0;
        std::cout << "DIST = " << dist << " and pp = " << pp << " and p_init.x() = " << p_init.x() << std::endl;
        point_type p0 = point_type(pp + dist, m * (pp - dist) + q);
        point_type p1 = point_type(pp + (dist * 2), m * (pp + (dist * 2)) + q);
        point_type p2 = point_type(pp + (dist * 3), m * (pp + (dist * 3)) + q);
        point_type p3 = point_type(pp + (dist * 4), m * (pp + (dist * 4)) + q);
        point_type p4 = point_type(pp + (dist * 5), m * (pp + (dist * 5)) + q);
        point_type p5 = point_type(pp + (dist * 6), m * (pp + (dist * 6)) + q);
        point_type p6 = point_type(pp + (dist * 7), m * (pp + (dist * 7)) + q);
        point_type p7 = point_type(pp + (dist * 8), m * (pp + (dist * 8)) + q);
        point_type p8 = point_type(pp + (dist * 9), m * (pp + (dist * 9)) + q);
        std::cout << "p0 = " << p0 << " , level_set = " << level_set(p0, msh, cl) << " , p1 = " << p1
                  << " , level_set = " << level_set(p1, msh, cl) << " , p2 = " << p2 << " , level_set = "
                  << level_set(p2, msh, cl) << " , p3 = " << p3 << " , level_set = " << level_set(p3, msh, cl)
                  << " ,p4 = " << p4 << " , level_set = " << level_set(p4, msh, cl) << " ,p5 = " << p5
                  << " , level_set = " << level_set(p5, msh, cl) << " , p6 = " << p6 << " , level_set = "
                  << level_set(p6, msh, cl) << ", p7 = " << p7 << " , level_set = " << level_set(p7, msh, cl)
                  << " , p8 = " << p8 << " , level_set = " << level_set(p8, msh, cl) << std::endl;

//throw std::logic_error("search_boundary not find -> Stefano");
//return p_init ;

        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, pt_tmp0, cl) && std::abs(ls0) < val_min) {
            val_min = std::abs(ls0);
            ret = pt_tmp0;

        }
        if (pt_in_cell(msh, pt_tmp1, cl) && std::abs(ls1) < val_min) {
            val_min = std::abs(ls1);
            ret = pt_tmp1;

        }
        if (pt_in_cell(msh, pt_tmp2, cl) && std::abs(ls2) < val_min) {
            val_min = std::abs(ls2);
            ret = pt_tmp2;

        }
        if (pt_in_cell(msh, pt_tmp3, cl) && std::abs(ls3) < val_min) {
            val_min = std::abs(ls3);
            ret = pt_tmp3;

        }
        return ret;

    }


}


template<typename T, size_t ET>
typename cuthho_mesh<T, ET>::point_type
search_boundary(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q) {
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    auto pts = points(msh, cl);

    point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
    point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
    point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
    point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());


    if (pt_in_cell(msh, pt_tmp0, cl) && !(p_init == pt_tmp0))
        return pt_tmp0;
    if (pt_in_cell(msh, pt_tmp1, cl) && !(p_init == pt_tmp1))
        return pt_tmp1;
    if (pt_in_cell(msh, pt_tmp2, cl) && !(p_init == pt_tmp2))
        return pt_tmp2;
    if (pt_in_cell(msh, pt_tmp3, cl) && !(p_init == pt_tmp3))
        return pt_tmp3;


}


template<typename T, size_t ET, typename Function>
void
refine_interface_pro(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                     const Function &level_set_function, size_t min, size_t max) {
    if ((max - min) < 2)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;

    size_t mid = (max + min) / 2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0 + p1) / 2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm, msh, cl);
    auto ls1 = level_set_function(ps1, msh, cl);
    auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
    T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
    T q = pm.y() - m_half * pm.x();
    if (offset(msh, cl) == 119) {
        std::cout << yellow << bold << "CELL 119" << reset << std::endl;
        std::cout << "p0 = " << p0 << " , p1 = " << p1 << std::endl;
        std::cout << "ps1.y() = " << ps1.y() << " , pm.y() = " << pm.y() << std::endl;
        std::cout << "ps1.x() = " << ps1.x() << " , pm.x() = " << pm.x() << std::endl;
        std::cout << "ps1.x() = " << ps1.x() << " , pm.x() = " << pm.x() << std::endl;
    }
/*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary(msh, cl, pm, m_half, q, lm, level_set_function);
    auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if (pt_in_cell(msh, ps1, cl) && (!((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
    } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
    } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= 0 && lm_bdry >= 0) || (lm < 0 && lm_bdry < 0)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
    } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
        std::cout << yellow << bold << "In cell " << offset(msh, cl)
                  << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, ps1, cl) && std::abs(ls1) < val_min) {
            val_min = std::abs(ls1);
            ret = ps1;
            std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

        }
        if (pt_in_cell(msh, ps2, cl) && std::abs(ls2) < val_min) {
            val_min = std::abs(ls2);
            ret = ps2;
            std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
        }
        if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry) < val_min) {
            val_min = std::abs(lm_bdry);
            ret = pt_bdry;
            std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
        }
        if (pt_in_cell(msh, pm, cl) && std::abs(lm) < val_min) {
            val_min = std::abs(lm);
            ret = pm;
            std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
        }
        std::cout << "ret = " << ret << std::endl;
        ip = ret;

    }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    cl.user_data.interface.at(mid) = ip;

    refine_interface_pro(msh, cl, level_set_function, min, mid);
    refine_interface_pro(msh, cl, level_set_function, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
    if (levels == 0)
        return;


    size_t interface_points = iexp_pow(2, levels);

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;

/*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface_pro(msh, cl, level_set_function, 0, interface_points);
/*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
    }
}

template<typename T, size_t ET, typename Function>
typename cuthho_mesh<T, ET>::point_type
search_boundary3(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                 typename cuthho_mesh<T, ET>::point_type &p_init, T m, T q, T lm, const Function &level_set,
                 T iso_val_interface) {
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    auto pts = points(msh, cl);

    point_type pt_tmp0 = point_type(pts[0].x(), m * pts[0].x() + q);
    point_type pt_tmp1 = point_type(pts[1].x(), m * pts[1].x() + q);
    point_type pt_tmp2 = point_type((pts[1].y() - q) / m, pts[1].y());
    point_type pt_tmp3 = point_type((pts[2].y() - q) / m, pts[2].y());
/*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
    auto ls0 = level_set(pt_tmp0, msh, cl);
    auto ls1 = level_set(pt_tmp1, msh, cl);
    auto ls2 = level_set(pt_tmp2, msh, cl);
    auto ls3 = level_set(pt_tmp3, msh, cl);

    if (pt_in_cell(msh, pt_tmp0, cl) && (!((lm >= iso_val_interface && ls0 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls0 < iso_val_interface))))
        return pt_tmp0;
    if (pt_in_cell(msh, pt_tmp1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls1 < iso_val_interface))))
        return pt_tmp1;
    if (pt_in_cell(msh, pt_tmp2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls2 < iso_val_interface))))
        return pt_tmp2;
    if (pt_in_cell(msh, pt_tmp3, cl) && (!((lm >= iso_val_interface && ls3 >= iso_val_interface) ||
                                           (lm < iso_val_interface && ls3 < iso_val_interface))))
        return pt_tmp3;
    else {
        std::cout << "In cell = " << offset(msh, cl) << " points(msh,cl)[0] = " << points(msh, cl)[0]
                  << " points(msh,cl)[1] = " << points(msh, cl)[1] << " points(msh,cl)[2] = " << points(msh, cl)[2]
                  << " points(msh,cl)[3] = " << points(msh, cl)[3] << std::endl;
        std::cout << "m = " << m << " --> q = " << q << std::endl;
        std::cout << "p_init = " << p_init << " --> pt_tmp0 = " << pt_tmp0 << " , pt_tmp1 = " << pt_tmp1
                  << " , pt_tmp2 = " << pt_tmp2 << " , pt_tmp3 = " << pt_tmp3 << std::endl;
        std::cout << "ls0 = " << ls0 << " , ls1 = " << ls1 << " , ls2 = " << ls2 << " , ls3 = " << ls3 << " AND lm = "
                  << lm << std::endl;
        std::cout << "pt_in_cell( pt_tmp0 ) = " << pt_in_cell(msh, pt_tmp0, cl) << " , pt_in_cell( pt_tmp1 ) = "
                  << pt_in_cell(msh, pt_tmp1, cl) << " , pt_in_cell( pt_tmp2 ) = " << pt_in_cell(msh, pt_tmp2, cl)
                  << " , pt_in_cel( pt_tmp3 ) = " << pt_in_cell(msh, pt_tmp3, cl) << std::endl;
        T pp = pts[0].x();
        T dist = std::abs(pp - p_init.x()) / 10.0;
        std::cout << "DIST = " << dist << " and pp = " << pp << " and p_init.x() = " << p_init.x() << std::endl;
        point_type p0 = point_type(pp + dist, m * (pp - dist) + q);
        point_type p1 = point_type(pp + (dist * 2), m * (pp + (dist * 2)) + q);
        point_type p2 = point_type(pp + (dist * 3), m * (pp + (dist * 3)) + q);
        point_type p3 = point_type(pp + (dist * 4), m * (pp + (dist * 4)) + q);
        point_type p4 = point_type(pp + (dist * 5), m * (pp + (dist * 5)) + q);
        point_type p5 = point_type(pp + (dist * 6), m * (pp + (dist * 6)) + q);
        point_type p6 = point_type(pp + (dist * 7), m * (pp + (dist * 7)) + q);
        point_type p7 = point_type(pp + (dist * 8), m * (pp + (dist * 8)) + q);
        point_type p8 = point_type(pp + (dist * 9), m * (pp + (dist * 9)) + q);
        std::cout << "p0 = " << p0 << " , level_set = " << level_set(p0, msh, cl) << " , p1 = " << p1
                  << " , level_set = " << level_set(p1, msh, cl) << " , p2 = " << p2 << " , level_set = "
                  << level_set(p2, msh, cl) << " , p3 = " << p3 << " , level_set = " << level_set(p3, msh, cl)
                  << " ,p4 = " << p4 << " , level_set = " << level_set(p4, msh, cl) << " ,p5 = " << p5
                  << " , level_set = " << level_set(p5, msh, cl) << " , p6 = " << p6 << " , level_set = "
                  << level_set(p6, msh, cl) << ", p7 = " << p7 << " , level_set = " << level_set(p7, msh, cl)
                  << " , p8 = " << p8 << " , level_set = " << level_set(p8, msh, cl) << std::endl;

//throw std::logic_error("search_boundary not find -> Stefano");
//return p_init ;

        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, pt_tmp0, cl) && std::abs(ls0 - iso_val_interface) < val_min) {
            val_min = std::abs(ls0);
            ret = pt_tmp0;

        }
        if (pt_in_cell(msh, pt_tmp1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
            val_min = std::abs(ls1);
            ret = pt_tmp1;

        }
        if (pt_in_cell(msh, pt_tmp2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
            val_min = std::abs(ls2);
            ret = pt_tmp2;

        }
        if (pt_in_cell(msh, pt_tmp3, cl) && std::abs(ls3 - iso_val_interface) < val_min) {
            val_min = std::abs(ls3);
            ret = pt_tmp3;

        }
        return ret;

    }


}


// USING INTERFACE = 1/2
template<typename T, size_t ET, typename Function>
void
refine_interface_pro3(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                      const Function &level_set_function, size_t min, size_t max) {
    if ((max - min) < 2)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    T iso_val_interface = level_set_function.iso_val_interface;
    size_t mid = (max + min) / 2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0 + p1) / 2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm, msh, cl);
    auto ls1 = level_set_function(ps1, msh, cl);
    auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
    T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
    T q = pm.y() - m_half * pm.x();
/*
    if( offset(msh,cl) == 119 )
    {
        std::cout<<yellow<<bold<<"CELL 119"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"ps1.y() = "<<ps1.y() << " , pm.y() = "<<pm.y()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
    }

    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
    auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                       (lm < iso_val_interface && ls1 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
    } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                              (lm < iso_val_interface && ls2 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
    } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                  (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
    } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
        std::cout << yellow << bold << "In cell " << offset(msh, cl)
                  << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
            val_min = std::abs(ls1);
            ret = ps1;
            std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

        }
        if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
            val_min = std::abs(ls2);
            ret = ps2;
            std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
        }
        if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
            val_min = std::abs(lm_bdry);
            ret = pt_bdry;
            std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
        }
        if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
            val_min = std::abs(lm);
            ret = pm;
            std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
        }
        std::cout << "ret = " << ret << std::endl;
        ip = ret;

    }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    cl.user_data.interface.at(mid) = ip;

    refine_interface_pro3(msh, cl, level_set_function, min, mid);
    refine_interface_pro3(msh, cl, level_set_function, mid, max);
}


template<typename T, size_t ET, typename Function>
void
refine_interface_pro3(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
    if (levels == 0)
        return;


    size_t interface_points = iexp_pow(2, levels);

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;

/*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
/*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
    }
}


template<typename T, size_t ET, typename Function, typename ITERATOR>
void
refine_interface_pro3_disp(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                           const Function &level_set_function, ITERATOR first_pt, ITERATOR second_pt, int &counter,
                           int counter_fin, int curve_degree, T &fraz) {

    if ((counter_fin - counter) == 1)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    T iso_val_interface = level_set_function.iso_val_interface;

    auto p0 = *first_pt;
    auto p1 = *second_pt;

    auto pm = p0 + fraz * (p1 - p0);

//std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<< " , pm = "<<pm<<" , fraz = "<<fraz<<std::endl;
    fraz += 1.0 / curve_degree;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm, msh, cl);
    auto ls1 = level_set_function(ps1, msh, cl);
    auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
    T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
    T q = pm.y() - m_half * pm.x();


    auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
    auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                       (lm < iso_val_interface && ls1 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
    } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                              (lm < iso_val_interface && ls2 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
    } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                  (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
    } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
        std::cout << yellow << bold << "In cell " << offset(msh, cl)
                  << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
            val_min = std::abs(ls1);
            ret = ps1;
            std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

        }
        if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
            val_min = std::abs(ls2);
            ret = ps2;
            std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
        }
        if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
            val_min = std::abs(lm_bdry);
            ret = pt_bdry;
            std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
        }
        if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
            val_min = std::abs(lm);
            ret = pm;
            std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
        }
        std::cout << "ret = " << ret << std::endl;
        ip = ret;

    }
    counter++;
    cl.user_data.interface.at(counter) = ip;

    refine_interface_pro3_disp(msh, cl, level_set_function, first_pt, second_pt, counter, counter_fin, curve_degree,
                               fraz);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro3_disp_subcell(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                                   const Function &level_set_function, std::vector <point<T, 2>> &interface_tmp,
                                   size_t min, size_t max) {
    if ((max - min) < 2)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    T iso_val_interface = level_set_function.iso_val_interface;
    size_t mid = (max + min) / 2;
    auto p0 = interface_tmp.at(min);
    auto p1 = interface_tmp.at(max);
    auto pm = (p0 + p1) / 2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm, msh, cl);
    auto ls1 = level_set_function(ps1, msh, cl);
    auto ls2 = level_set_function(ps2, msh, cl);

// CASE  MAX PT on the boudary
    T m_half = (ps1.y() - pm.y()) / (ps1.x() - pm.x());
    T q = pm.y() - m_half * pm.x();

/*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary3(msh, cl, pm, m_half, q, lm, level_set_function, iso_val_interface);
    auto lm_bdry = level_set_function(pt_bdry, msh, cl);
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
//std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
//std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
//std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
// std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if (pt_in_cell(msh, ps1, cl) && (!((lm >= iso_val_interface && ls1 >= iso_val_interface) ||
                                       (lm < iso_val_interface && ls1 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 1"<<std::endl;
    } else if (pt_in_cell(msh, ps2, cl) && (!((lm >= iso_val_interface && ls2 >= iso_val_interface) ||
                                              (lm < iso_val_interface && ls2 < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold, msh, cl);
//std::cout<<"OLD 2"<<std::endl;
    } else if (pt_in_cell(msh, pt_bdry, cl) && (!((lm >= iso_val_interface && lm_bdry >= iso_val_interface) ||
                                                  (lm < iso_val_interface && lm_bdry < iso_val_interface)))) {
        auto threshold = diameter(msh, cl) / 1e20;
//auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry, level_set_function, threshold, msh, cl);
//std::cout<<"BDRY NEW"<<std::endl;
    } else {
//throw std::logic_error("interface not found in search range");
//std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
//ip = pm;
        std::cout << yellow << bold << "In cell " << offset(msh, cl)
                  << " ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND." << reset << std::endl;
        point_type ret;
        T val_min = 1e10;
        if (pt_in_cell(msh, ps1, cl) && std::abs(ls1 - iso_val_interface) < val_min) {
            val_min = std::abs(ls1);
            ret = ps1;
            std::cout << "ps1 = " << ps1 << " , ls1 = " << ls1 << std::endl;

        }
        if (pt_in_cell(msh, ps2, cl) && std::abs(ls2 - iso_val_interface) < val_min) {
            val_min = std::abs(ls2);
            ret = ps2;
            std::cout << "ps2 = " << ps2 << " , ls2 = " << ls2 << std::endl;
        }
        if (pt_in_cell(msh, pt_bdry, cl) && std::abs(lm_bdry - iso_val_interface) < val_min) {
            val_min = std::abs(lm_bdry);
            ret = pt_bdry;
            std::cout << "ppt_bdrys1 = " << pt_bdry << " , lm_bdry = " << lm_bdry << std::endl;
        }
        if (pt_in_cell(msh, pm, cl) && std::abs(lm - iso_val_interface) < val_min) {
            val_min = std::abs(lm);
            ret = pm;
            std::cout << "pm = " << ps1 << " , lm = " << ls1 << std::endl;
        }
        std::cout << "ret = " << ret << std::endl;
        ip = ret;

    }
/*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    interface_tmp.at(mid) = ip;

    refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, min, mid);
    refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro3_curve_para(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels,
                                 size_t degree_curve) {

    size_t interface_points;

    if (levels == 0 && degree_curve == 1)
        return;

//if (levels == 0 && degree_curve % 2 == 0 )
//   interface_points = degree_curve+1 ;

    interface_points = iexp_pow(2, levels) * degree_curve;

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;


        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;
        if (degree_curve % 2 == 0)
            refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
        else {
//std::cout<<"--> Attention it works just for P3!!! "<<std::endl;
            size_t num_subcl = iexp_pow(2, levels);
            std::vector <point<T, 2>> interface_tmp(num_subcl + 1);
            interface_tmp.at(0) = cl.user_data.p0;
            interface_tmp.at(num_subcl) = cl.user_data.p1;
            if (levels > 0) {
                refine_interface_pro3_disp_subcell(msh, cl, level_set_function, interface_tmp, 0, num_subcl);
            }
            int counter = 0;
//std::cout<<"cl.user_data.p0 = "<<cl.user_data.p0<<" ,  cl.user_data.p1 = "<< cl.user_data.p1<<std::endl;
//std::cout<<"interface_tmp[0] = "<<interface_tmp[0]<<" , interface_tmp[1] = "<< interface_tmp[1]<<" , interface_tmp[2] = "<< interface_tmp[2]<<std::endl;
            for (auto first_pt = interface_tmp.begin(); first_pt < interface_tmp.end() - 1; first_pt++) {
                auto second_pt = first_pt + 1;
                int counter_fin = counter + degree_curve;
                T fraz = 1.0 / degree_curve;
//std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<<std::endl;
                refine_interface_pro3_disp(msh, cl, level_set_function, first_pt, second_pt, counter, counter_fin,
                                           degree_curve, fraz);

                counter++;
                if (counter < interface_points)
                    cl.user_data.interface.at(counter) = *second_pt;
            }
        }
    }
}


template<typename T, size_t ET, typename Function>
void
refine_interface_angle(cuthho_mesh <T, ET> &msh, typename cuthho_mesh<T, ET>::cell_type &cl,
                       const Function &level_set_function, size_t min, size_t max,
                       typename cuthho_mesh<T, ET>::point_type &p_init, T h, bool pos, int multiplicity, T angle0,
                       T angle1) {
    if ((max - min) < 2)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;


    T angle_half = (angle0 + angle1) / 2.0;
    T m_half = tan(angle_half);

    std::cout << bold << yellow << "CHECK ANGLE --------> " << reset << "angle0 = " << angle0 * 180 / M_PI
              << " , angle1 = " << angle1 * 180 / M_PI << " and angle_half = " << angle_half * 180 / M_PI << std::endl;

/*
    // In the case h is not long enough!
    T h_max = 0.0;
    if(multiplicity > 1  )
    {
        T cateto_min = 2*m_half/h ;
        h_max = std::max( h , sqrt( pow(cateto_min,2) + pow(h,2)/4.0 ) );
    }
    */

// CASE h:
    T val = sqrt(pow(h, 2) / (1 + pow(m_half, 2)));

    T x_new0 = p_init.x() + val;
    T y_new0 = p_init.y() + (x_new0 - p_init.x()) * m_half;
    point_type pt_half0 = point_type(x_new0, y_new0);

    auto lm0 = level_set_function(pt_half0, msh, cl);

    T x_new1 = p_init.x() - val;
    T y_new1 = p_init.y() + (x_new1 - p_init.x()) * m_half;
    point_type pt_half1 = point_type(x_new1, y_new1);

    auto lm1 = level_set_function(pt_half1, msh, cl);




// CASE h_max = h*sqrt(2)
    T h_max = h * sqrt(2.0);
    T val_max = sqrt(pow(h_max, 2) / (1 + pow(m_half, 2)));
    T x_new_max0 = p_init.x() + val_max;
    T y_new_max0 = p_init.y() + (x_new_max0 - p_init.x()) * m_half;
    T x_new_max1 = p_init.x() - val_max;
    T y_new_max1 = p_init.y() + (x_new_max1 - p_init.x()) * m_half;


    point_type pt_half_max0 = point_type(x_new_max0, y_new_max0);
    point_type pt_half_max1 = point_type(x_new_max1, y_new_max1);

    auto lm_max0 = level_set_function(pt_half_max0, msh, cl);
    auto lm_max1 = level_set_function(pt_half_max1, msh, cl);

// CASE h_min = h/2
    T h_min = h / 2.0;
    T val_min = sqrt(pow(h_min, 2) / (1 + pow(m_half, 2)));
    T x_new_min0 = p_init.x() + val_min;
    T y_new_min0 = p_init.y() + (x_new_min0 - p_init.x()) * m_half;
    T x_new_min1 = p_init.x() - val_min;
    T y_new_min1 = p_init.y() + (x_new_min1 - p_init.x()) * m_half;


    point_type pt_half_min0 = point_type(x_new_min0, y_new_min0);
    point_type pt_half_min1 = point_type(x_new_min1, y_new_min1);

    auto lm_min0 = level_set_function(pt_half_min0, msh, cl);
    auto lm_min1 = level_set_function(pt_half_min1, msh, cl);



// CASE PT on the boudary
    T q = p_init.y() - m_half * p_init.x();

    auto pt_bdry = search_boundary(msh, cl, p_init, m_half, q);
    auto lm_bdry = level_set_function(pt_bdry, msh, cl);


    size_t mid = (max + min) / 2;
    point_type ip;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0 + p1) / 2.0;
//std::cout<<"p_init = "<<p_init<< " level_set(p_init) = "<<level_set_function(p_init,msh,cl)<<std::endl;


    if (pt_in_cell(msh, pt_half0, cl) && !((lm0 >= 0 && pos == TRUE) || (lm0 < 0 && pos == FALSE))) {

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half0, level_set_function, threshold, msh, cl);
        std::cout << "NORMAL + --> pt_half0 = " << pt_half0 << " and lm0 = " << lm0 << " ------> ip = " << ip
                  << std::endl;
    } else if (pt_in_cell(msh, pt_half1, cl) && !((lm1 >= 0 && pos == TRUE) || (lm1 < 0 && pos == FALSE))) {

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half1, level_set_function, threshold, msh, cl);
        std::cout << "NORMAL - --> pt_half1 = " << pt_half1 << " and lm1 = " << lm1 << " ------> ip = " << ip
                  << std::endl;

    } else if (pt_in_cell(msh, pt_bdry, cl) && !((lm_bdry >= 0 && pos == TRUE) || (lm_bdry < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_bdry, level_set_function, threshold, msh, cl);
        std::cout << "BDRY - --> pt_bdry = " << pt_bdry << " and lm_bdry = " << lm_bdry << " --> ip = " << ip
                  << std::endl;

    } else if (pt_in_cell(msh, pt_half_max0, cl) && !((lm_max0 >= 0 && pos == TRUE) || (lm_max0 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MAX POINT (WITH +) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_max0, level_set_function, threshold, msh, cl);
        std::cout << "MAX + --> pt_max0 = " << pt_half_max0 << " and lm_max0 = " << lm_max0 << " --> ip = " << ip
                  << std::endl;

    } else if (pt_in_cell(msh, pt_half_max1, cl) && !((lm_max1 >= 0 && pos == TRUE) || (lm_max1 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MAX POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_max1, level_set_function, threshold, msh, cl);
        std::cout << "MAX - --> pt_max1 = " << pt_half_max1 << " and lm_max1 = " << lm_max1 << " --> ip = " << ip
                  << std::endl;

    } else if (pt_in_cell(msh, pt_half_min0, cl) && !((lm_min0 >= 0 && pos == TRUE) || (lm_min0 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH +) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_min0, level_set_function, threshold, msh, cl);
        std::cout << "MIN + --> pt_min0 = " << pt_half_min0 << " and lm_min0 = " << lm_min0 << " --> ip = " << ip
                  << std::endl;

    } else if (pt_in_cell(msh, pt_half_min1, cl) && !((lm_min1 >= 0 && pos == TRUE) || (lm_min1 < 0 && pos == FALSE))) {
//std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_min1, level_set_function, threshold, msh, cl);
        std::cout << "MIN - --> pt_min1 = " << pt_half_min1 << " and lm_min1 = " << lm_min1 << " --> ip = " << ip
                  << std::endl;

    } else {
// IN THE CASE I DON'T FIND THE POINT I CONSIDER IT LINEAR

        std::cout << "-----> ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED!"
                  << std::endl;
        std::cout << "p_init = " << p_init << " level_set(p_init) = " << level_set_function(p_init, msh, cl)
                  << std::endl;
        std::cout << "CASE + : pt_half0 = " << pt_half0 << " and lm0 = " << lm0 << std::endl;
        std::cout << "CASE - : pt_half1 = " << pt_half1 << " and lm1 = " << lm1 << std::endl;
        std::cout << "CASE MAX+: pt_half_max0 = " << pt_half_max0 << " and lm_max0 = " << lm_max0 << std::endl;
        std::cout << "CASE MAX-: pt_half_max1 = " << pt_half_max1 << " and lm_max1 = " << lm_max1 << std::endl;
        std::cout << "CASE MIN +: pt_half_min0 = " << pt_half_min0 << " and lm_min0 = " << lm_min0 << std::endl;
        std::cout << "CASE MIN -: pt_half_min1 = " << pt_half_min1 << " and lm_min1 = " << lm_min1 << std::endl;
        std::cout << "CASE BDRY: pt_bdry = " << pt_bdry << " and lm_bdry = " << lm_bdry << std::endl;
        std::cout << "--> ip = pm =  " << pm << std::endl;
        std::cout << "ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED! <-------"
                  << std::endl;
        ip = pm;
    }


    cl.user_data.interface.at(mid) = ip;

    refine_interface_angle(msh, cl, level_set_function, min, mid, p_init, h, pos, multiplicity, angle0, angle_half);
    refine_interface_angle(msh, cl, level_set_function, mid, max, p_init, h, pos, multiplicity, angle_half, angle1);
}


template<typename T, size_t ET, typename Function>
void
refine_interface_angle2(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
    if (levels == 0)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    size_t interface_points = iexp_pow(2, levels);

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;

        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

// ADDED BY STEFANO
        point_type pos0 = cl.user_data.p0;
        point_type pos1 = cl.user_data.p1;
        std::vector <point_type> pos_point;
        std::vector <point_type> neg_point;

        bool positive = TRUE;
        int multiplicity = 1;
        std::vector <size_t> position_neg, position_pos;
        T angle0, angle1;
        point_type pm;

        size_t counter = 0;
        for (auto &pt: points(msh, cl)) {
            if (level_set_function(pt, msh, cl) < 0) {
                neg_point.push_back(pt);
                position_neg.push_back(counter);
            } else {
                pos_point.push_back(pt);
                position_pos.push_back(counter);
            }
            counter++;
        }

/// FIND  EXTREME  ANGLES
        if (neg_point.size() == 1) {
            pm = neg_point[0];
            positive = FALSE;
            if (position_neg[0] == 0) {
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;
            } else if (position_neg[0] == 1) {
                angle0 = M_PI / 2.0;
                angle1 = M_PI;
            } else if (position_neg[0] == 2) {
                angle0 = M_PI;
                angle1 = 3.0 * M_PI / 2.0;
            } else if (position_neg[0] == 3) {
                angle0 = 3.0 * M_PI / 2.0;
                angle1 = 0.0 * M_PI;
            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        } else if (pos_point.size() == 1) {
            pm = pos_point[0];
            if (position_pos[0] == 0) {
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;
            } else if (position_pos[0] == 1) {
                angle0 = M_PI / 2.0;
                angle1 = M_PI;
            } else if (position_pos[0] == 2) {
                angle0 = M_PI;
                angle1 = 3.0 * M_PI / 2.0;
            } else if (position_pos[0] == 3) {
                angle0 = 3.0 * M_PI / 2.0;
                angle1 = 0.0 * M_PI;
            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }

        } else {
// MULTIPLICITY 2 -> #pos_point = #neg_point = 2
            if (position_pos[0] == 0 && position_pos[1] == 1) {
                pm = (pos_point[0] + pos_point[1]) / 2.0;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                if (angle0 < 0)
                    angle0 += M_PI;
                else
                    angle1 += M_PI;
            } else if (position_pos[0] == 1 && position_pos[1] == 2) {
                pm = (pos_point[0] + pos_point[1]) / 2.0;
                multiplicity = 2;
                angle0 = M_PI + atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = M_PI + atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

            } else if (position_pos[0] == 2 && position_pos[1] == 3) {

                pm = (pos_point[0] + pos_point[1]) / 2.0;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                if (angle0 > 0)
                    angle0 += M_PI;
                else
                    angle1 += M_PI;

            } else if (position_pos[0] == 0 && position_pos[1] == 3) {

                pm = (pos_point[0] + pos_point[1]) / 2.0;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

            } else if (position_pos[0] == 0 && position_pos[1] == 2) {
                positive = FALSE;
                pm = points(msh, cl)[1];
//multiplicity = 2 ;
                angle0 = M_PI / 2.0;
                angle1 = M_PI;

            } else if (position_pos[0] == 1 && position_pos[1] == 3) {
                positive = FALSE;
                pm = points(msh, cl)[0];
//multiplicity = 2 ;
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;

            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }


        if (angle0 > angle1) {
            T tmp = angle1;
            angle1 = angle0;
            angle0 = tmp;
        }
        std::cout << "angle0 = " << angle0 << " and angle1 = " << angle1 << std::endl;


        auto checK_sign = level_set_function(pm, msh, cl);


        if (!(std::signbit(checK_sign) && !positive) || !(!std::signbit(checK_sign) && positive)) {
            std::cout << "LEVEL SET(Pm) = " << checK_sign << " and sign used is = " << positive << std::endl;
            throw std::logic_error("HO FATTO ERRORE IN POSITIVE SIGN CHECKING");
        }


        T h = std::min(level_set_function.params.hx(), level_set_function.params.hy());


        refine_interface_angle(msh, cl, level_set_function, 0, interface_points, pm, h, positive, multiplicity, angle0,
                               angle1);
    }

}

template<typename T, size_t ET, typename Function>
void
refine_interface_angle(cuthho_mesh <T, ET> &msh, const Function &level_set_function, size_t levels) {
    if (levels == 0)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
//typedef typename cuthho_mesh<T, ET>::node_type node_type;
    size_t interface_points = iexp_pow(2, levels);

    for (auto &cl: msh.cells) {
        if (!is_cut(msh, cl))
            continue;

        cl.user_data.interface.resize(interface_points + 1);
        cl.user_data.interface.at(0) = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;
        std::cout << yellow << bold << "--------------------> CELL = " << offset(msh, cl) << " <--------------------"
                  << reset << std::endl;
// ADDED BY STEFANO
        point_type pos0 = cl.user_data.p0;
        point_type pos1 = cl.user_data.p1;

        bool positive = TRUE;
        int multiplicity = 1;
        std::vector <size_t> position_neg, position_pos;
        T angle0, angle1;
        point_type pm;

        size_t counter = 0;
        for (auto &nd: nodes(msh, cl)) {

            if (nd.user_data.location == element_location::IN_NEGATIVE_SIDE) {
                position_neg.push_back(counter);
            } else {

                position_pos.push_back(counter);
            }
            counter++;
//std::cout<<"nd = "<<nd.ptid<<std::endl;
        }

/// FIND  EXTREME  ANGLES
        if (position_neg.size() == 1) {

            pm = points(msh, cl)[position_neg[0]];
            std::cout << "POINT" << pm << " , position_neg = " << position_neg[0] << std::endl;
            positive = FALSE;
            if (position_neg[0] == 0) {
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;
            } else if (position_neg[0] == 1) {
                angle0 = M_PI / 2.0;
                angle1 = M_PI;
            } else if (position_neg[0] == 2) {
                angle0 = M_PI;
                angle1 = 3.0 * M_PI / 2.0;
            } else if (position_neg[0] == 3) {
                angle0 = 3.0 * M_PI / 2.0;
                angle1 = 2.0 * M_PI;
            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        } else if (position_pos.size() == 1) {
            std::cout << yellow << bold << "CASO POSITIVO MA TOGLIEREI E METTEREI SOLO CASI NEGATIVI!!!" << reset
                      << std::endl;
            pm = points(msh, cl)[position_pos[0]];
            std::cout << "POINT" << pm << " , position_pos = " << position_pos[0] << std::endl;
            if (position_pos[0] == 0) {
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;
            } else if (position_pos[0] == 1) {
                angle0 = M_PI / 2.0;
                angle1 = M_PI;
            } else if (position_pos[0] == 2) {
                angle0 = M_PI;
                angle1 = 3.0 * M_PI / 2.0;
            } else if (position_pos[0] == 3) {
                angle0 = 3.0 * M_PI / 2.0;
                angle1 = 2.0 * M_PI;
            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }

        } else {
//std::cout<<"sono qua 4 NEW"<<std::endl;
//if(plus_close(p0,))
// MULTIPLICITY 2 -> #pos_point = #neg_point = 2
            if (position_neg[0] == 0 && position_neg[1] == 1) {
                positive = FALSE;
                pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                if (angle0 < 0)
                    angle0 += M_PI;
                else
                    angle1 += M_PI;
            } else if (position_neg[0] == 1 && position_neg[1] == 2) {
                positive = FALSE;
                pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
                multiplicity = 2;
                angle0 = M_PI + atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = M_PI + atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

            } else if (position_neg[0] == 2 && position_neg[1] == 3) {
                positive = FALSE;
                pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));
                if (angle0 > 0)
                    angle0 += M_PI;
                else
                    angle1 += M_PI;

                if (angle0 < 0)
                    angle0 = 2.0 * M_PI + angle0;
                else
                    angle1 = 2.0 * M_PI + angle1;

            } else if (position_neg[0] == 0 && position_neg[1] == 3) {
                positive = FALSE;
                pm = (points(msh, cl)[position_neg[0]] + points(msh, cl)[position_neg[1]]) / 2.0;
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
                multiplicity = 2;
                angle0 = atan((pos0.y() - pm.y()) / (pos0.x() - pm.x()));
                angle1 = atan((pos1.y() - pm.y()) / (pos1.x() - pm.x()));

            } else if (position_neg[0] == 0 && position_neg[1] == 2) {
//positive = FALSE ;
                pm = points(msh, cl)[1];
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
//multiplicity = 2 ;
                angle0 = M_PI / 2.0;
                angle1 = M_PI;

            } else if (position_neg[0] == 1 && position_neg[1] == 3) {
//positive = FALSE ;
                pm = points(msh, cl)[0];
                std::cout << "POINT " << pm << " , position_neg[0][1] --> " << position_neg[0] << " , "
                          << position_neg[1] << std::endl;
//multiplicity = 2 ;
                angle0 = 0.0 * M_PI;
                angle1 = M_PI / 2.0;

            } else {
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }


        if (angle0 > angle1) {
            T tmp = angle1;
            angle1 = angle0;
            angle0 = tmp;
        }
//std::cout<<"CHECK ANGLE --------> angle0 = "<<angle0<< " and angle1 = "<<angle1<<std::endl;


        auto checK_sign = level_set_function(pm, msh, cl);

        if ((positive == FALSE && std::signbit(checK_sign) == 0) ||
            (positive == TRUE && std::signbit(checK_sign) == 1)) {
            std::cout << "LEVEL SET(Pm) = " << checK_sign << " and sign used is = " << positive << " and signbit is "
                      << std::signbit(checK_sign) << std::endl;
            throw std::logic_error("HO FATTO ERRORE IN POSITIVE SIGN CHECKING");
        }


        T h = std::min(level_set_function.params.hx(), level_set_function.params.hy());


        refine_interface_angle(msh, cl, level_set_function, 0, interface_points, pm, h, positive, multiplicity, angle0,
                               angle1);


        std::cout << "LIMIT CELL " << offset(msh, cl) << " are:" << std::endl;
        std::cout << "pt[0] = " << points(msh, cl)[0] << " , pt[1] = " << points(msh, cl)[1] << " , pt[2] = "
                  << points(msh, cl)[2] << " , pt[3] = " << points(msh, cl)[3] << std::endl;

        for (size_t i_int = 0; i_int < interface_points + 1; i_int++)
            std::cout << "refined points are p = " << cl.user_data.interface.at(i_int) << std::endl;
        std::cout << "--------------------> CELL = " << offset(msh, cl) << "<--------------------" << std::endl;
    }

}



/*****************************************************************************
 *   Test stuff ADDED by StePicca
 *****************************************************************************/

//template<typename T, typename Mesh>
//std::vector<size_t>
//subcell_finder<T,Mesh>(const Mesh& , const point<T,2>& , const typename Mesh::cell_type& , const mesh_init_params<T>&);

template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh &msh, const point<T, 2> &, const typename Mesh::cell_type &);

template<typename T, typename Mesh>
std::vector <point<T, 2>>
equidistriduted_nodes(const Mesh &, const typename Mesh::cell_type &, size_t);

template<typename T, typename Mesh>
std::vector <point<T, 2>>
equidistriduted_nodes_subcell(const Mesh &,
                              const typename Mesh::cell_type &,
                              size_t, const std::vector <size_t> &);


template<typename T>
std::vector <point<T, 1>>
        reference_nodes(size_t);

template<typename FonctionD, typename Mesh, typename FonctionA>
void
testing_level_set(const Mesh msh, const FonctionD &, const FonctionA &);

template<typename FonctionD, typename Mesh>
void
test_new_method(const Mesh, const FonctionD &, const typename Mesh::cell_type &);


// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh, typename FonctionA>
void
gradient_checking1(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                   const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;

    double derD1x, derD1y, derAx, derAy, derD2x, derD2y;
    Eigen::Matrix<double, 2, 1> derD1, derD2, derA;
    point<double, 2> node;


    auto pts = points(msh, cl);
    for (auto &node: pts) {
        derD1 = level_set_disc.gradient(node);
        derD2 = level_set_disc.gradient(node, msh, cl);
        derA = level_set_anal.gradient(node);

        derD1x = derD1(0);
        derD1y = derD1(1);
        derD2x = derD2(0);
        derD2y = derD2(1);
        derAx = derA(0);
        derAy = derA(1);


/*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */

        if ((derAx - derD2x) > 1e-2) {
            std::cout << "Differnce between analytic and NEW X-evaluation system " << (derAx - derD2x) << std::endl;
        }

        if ((derAx - derD1x) > 1e-2) {
            std::cout << "Differnce between analytic and OLD X-evaluation system " << (derAx - derD1x) << std::endl;
        }


/*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */


        if ((derAy - derD2y) > 1e-2) {
            std::cout << "Differnce between analytic and NEW Y-evaluation system " << (derAy - derD2y) << std::endl;
        }

        if ((derAy - derD1y) > 1e-2) {
            std::cout << "Differnce between analytic and OLD Y-evaluation system " << (derAy - derD1y) << std::endl;
        }


    }


}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh, typename FonctionA>
void
gradient_checking(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                  const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;

    double derD1x, derD1y, derAx, derAy; // , derD2x , derD2y ;
    Eigen::Matrix<double, 2, 1> derD1, derD2, derA;
    point<double, 2> node;

    auto pts = points(msh, cl);
    for (auto &node: pts) {
        derD1 = level_set_disc.gradient(node);
// derD2 = level_set_disc.gradient(node,msh,cl);
        derA = level_set_anal.gradient(node);

        derD1x = derD1(0);
        derD1y = derD1(1);
//   derD2x = derD2(0);
//   derD2y = derD2(1);
        derAx = derA(0);
        derAy = derA(1);


/*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */
/*
        if((derAx-derD2x)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW X-evaluation system "<<(derAx-derD2x)<<std::endl;
        }
        */
        if ((derAx - derD1x) > 1e-2) {
            std::cout << "Differnce between analytic and OLD X-evaluation system " << (derAx - derD1x) << std::endl;
        }


/*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */

/*
        if((derAy-derD2y)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW Y-evaluation system "<<(derAy-derD2y)<<std::endl;
        }
        */
        if ((derAy - derD1y) > 1e-2) {
            std::cout << "Differnce between analytic and OLD Y-evaluation system " << (derAy - derD1y) << std::endl;
        }


    }


}


template<typename FonctionD, typename Mesh, typename FonctionA>
void
testing_velocity(const Mesh &msh, const FonctionD &vel_disc, const FonctionA &vel_anal) {
//typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;

    Eigen::Matrix<double, 2, 1> valueA;
    point<double, 2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_discx = std::make_shared < gnuplot_output_object < double > > ("vel_discX.dat");
    auto test_analx = std::make_shared < gnuplot_output_object < double > > ("vel_analX.dat");
    auto test_discy = std::make_shared < gnuplot_output_object < double > > ("vel_discY.dat");
    auto test_analy = std::make_shared < gnuplot_output_object < double > > ("vel_analY.dat");

    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        for (auto &pt: pts) {
            auto valueD = vel_disc(pt, msh, cl);
            valueA = vel_anal(pt);

            test_discx->add_data(pt, valueD.first);
            test_discy->add_data(pt, valueD.second);
            test_analx->add_data(pt, valueA(0));
            test_analy->add_data(pt, valueA(1));


        }
    }

    postoutput1.add_object(test_discx);
    postoutput1.add_object(test_analx);
    postoutput1.add_object(test_discy);
    postoutput1.add_object(test_analy);


    postoutput1.write();

}


template<typename T>
void
plotting_in_time_complete(const std::vector <T> &time_vec, const std::vector <T> &area_time,
                          const std::vector <T> &l1_err_u_n_time, const std::vector <T> &linf_err_u_n_time,
                          const std::vector <T> &max_val_u_n_time, const std::vector <T> &l1_err_curvature_time,
                          const std::vector <T> &linf_err_curvature_time, T dt,
                          const std::vector <std::pair<T, T>> &min_max_vec, const std::vector <T> &flux_interface_time,
                          const std::vector <std::pair<T, T>> &rise_velocity_time,
                          const std::vector <std::pair<T, T>> &centre_mass_err_time,
                          const std::vector <T> &perimeter_time, const std::vector <T> &circularity_time,
                          T circularity_ref, T perimetre_ref, T area_ref, T radius) {
    std::cout << "IT does not work, I have some vector small without first iteration!!" << std::endl;
    postprocess_output <T> postoutput;

    auto testref0 = std::make_shared < gnuplot_output_object_time < T > > ("area_ref_time.dat");
    auto testref1 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_ref_time.dat");
    auto testref2 = std::make_shared < gnuplot_output_object_time < T > > ("circularity_ref_time.dat");

    T area_analytic = M_PI * radius * radius;
    T perimeter_analytic = 2.0 * M_PI * radius;
    auto testanal0 = std::make_shared < gnuplot_output_object_time < T > > ("area_anal_time.dat");
    auto testanal1 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_anal_time.dat");


    auto test0 = std::make_shared < gnuplot_output_object_time < T > > ("area_time.dat");
    auto test1 = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_u_n_time.dat");
    auto test2 = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_u_n_time.dat");
    auto test1_counter = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_u_n_time_counter.dat");
    auto test2_counter = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_u_n_time_counter.dat");

    auto test3 = std::make_shared < gnuplot_output_object_time < T > > ("max_val_u_n_time.dat");
    auto test4 = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_curvature_time.dat");
    auto test5 = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_curvature_time.dat");
    auto test4_counter = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_curvature_time_counter.dat");
    auto test5_counter = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_curvature_time_counter.dat");


    auto test0b = std::make_shared < gnuplot_output_object_time < T > > ("area_time_normalised.dat");

    auto test1b = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_u_n_time_normalised.dat");
    auto test2b = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_u_n_time_normalised.dat");
    auto test3b = std::make_shared < gnuplot_output_object_time < T > > ("max_val_u_n_time_normalised.dat");
    auto test4b = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_curvature_time_normalised.dat");
    auto test5b = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_curvature_time_normalised.dat");
//auto test4c  = std::make_shared< gnuplot_output_object_time<T> >("l1_l1_err_curvature_err_time.dat");

    auto test_dt = std::make_shared < gnuplot_output_object_time < T > > ("dt_M.dat");

    auto test0c = std::make_shared < gnuplot_output_object_time < T > > ("area_time_err.dat");
    auto test0c_counter = std::make_shared < gnuplot_output_object_time < T > > ("area_time_err_counter.dat");

    auto testm0 = std::make_shared < gnuplot_output_object_time < T > > ("min_time.dat");
    auto testm1 = std::make_shared < gnuplot_output_object_time < T > > ("min_normalised_time.dat");
    auto testM0 = std::make_shared < gnuplot_output_object_time < T > > ("max_time.dat");
    auto testM1 = std::make_shared < gnuplot_output_object_time < T > > ("max_normalised_time.dat");
    auto testflux = std::make_shared < gnuplot_output_object_time < T > > ("flux_interface_time.dat");
    auto testvelx = std::make_shared < gnuplot_output_object_time < T > > ("rise_velocity_err_x_time.dat");
    auto testvely = std::make_shared < gnuplot_output_object_time < T > > ("rise_velocity_err_y_time.dat");
    auto testvel = std::make_shared < gnuplot_output_object_time < T > > ("rise_velocity_err_time.dat");
    auto testvel_counter = std::make_shared < gnuplot_output_object_time < T > > ("rise_velocity_err_time_counter.dat");
    auto testcomx = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_x_time.dat");
    auto testcomy = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_y_time.dat");
    auto testcom = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_time.dat");


    auto testper0 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_time.dat");
    auto testper1 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_normalised_time.dat");
    auto testper2 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_err_time.dat");
    auto testper2_counter = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_err_time_counter.dat");

    auto testcirc = std::make_shared < gnuplot_output_object_time < T > > ("circularity_time.dat");
    auto testcirc1 = std::make_shared < gnuplot_output_object_time < T > > ("circularity_error_time.dat");
    auto testcirc1_counter =
            std::make_shared < gnuplot_output_object_time < T > > ("circularity_error_time_counter.dat");

    size_t tot = l1_err_u_n_time.size();

    testm0->add_data(time_vec[0], min_max_vec[0].first);
    testm1->add_data(time_vec[0], 1.0);
    testM0->add_data(time_vec[0], min_max_vec[0].second);
    testM1->add_data(time_vec[0], 1.0);

    testcomx->add_data(time_vec[0], 0.0);
    testcomy->add_data(time_vec[0], 0.0);
    testcom->add_data(time_vec[0], 0.0);


    testper0->add_data(time_vec[0], perimeter_time[0]);
    testper1->add_data(time_vec[0], 1.0);
    testper2->add_data(time_vec[0], std::abs(perimeter_time[0] - perimetre_ref) / perimetre_ref);
    testper2_counter->add_data(0, std::abs(perimeter_time[0] - perimetre_ref) / perimetre_ref);

    testcirc->add_data(time_vec[0], circularity_time[0]);
    testcirc1->add_data(time_vec[0], std::abs(circularity_time[0] - circularity_ref) / circularity_ref);
    testcirc1_counter->add_data(0, std::abs(circularity_time[0] - circularity_ref) / circularity_ref);

    test0c->add_data(time_vec[0], 0.0);
    test0c_counter->add_data(0, 0.0);
//test4c->add_data(time_vec[0] , 0.0 );


    test0->add_data(time_vec[0], area_time[0]);
// ADD 8/01/21
    test1->add_data(time_vec[0], l1_err_u_n_time[0]);
    test2->add_data(time_vec[0], linf_err_u_n_time[0]);
    test1_counter->add_data(0, l1_err_u_n_time[0]);
    test2_counter->add_data(0, linf_err_u_n_time[0]);
    test3->add_data(time_vec[0], max_val_u_n_time[0]);
// UP TO HERE
    test4->add_data(time_vec[0], l1_err_curvature_time[0]);
    test5->add_data(time_vec[0], linf_err_curvature_time[0]);
    test4_counter->add_data(0, l1_err_curvature_time[0]);
    test5_counter->add_data(0, linf_err_curvature_time[0]);

    test0b->add_data(time_vec[0], area_time[0] / area_time[0]);
// ADD 8/01/21
    test1b->add_data(time_vec[0], l1_err_u_n_time[0] / l1_err_u_n_time[0]);
    test2b->add_data(time_vec[0], linf_err_u_n_time[0] / linf_err_u_n_time[0]);
    test3b->add_data(time_vec[0], max_val_u_n_time[0] / max_val_u_n_time[0]);
// UP TO HERE
    test4b->add_data(time_vec[0], l1_err_curvature_time[0] / l1_err_curvature_time[0]);
    test5b->add_data(time_vec[0], linf_err_curvature_time[0] / linf_err_curvature_time[0]);

    testref0->add_data(time_vec[0], area_ref);
    testref1->add_data(time_vec[0], perimetre_ref);
    testref2->add_data(time_vec[0], circularity_ref);

    testanal0->add_data(time_vec[0], area_analytic);
    testanal1->add_data(time_vec[0], perimeter_analytic);


    testflux->add_data(time_vec[0], flux_interface_time[0]);
    testvelx->add_data(time_vec[0], std::abs(rise_velocity_time[0].first));
    testvely->add_data(time_vec[0], std::abs(rise_velocity_time[0].second));
    testvel->add_data(time_vec[0], std::abs(rise_velocity_time[0].first) + std::abs(rise_velocity_time[0].second));
    testvel_counter->add_data(0, std::abs(rise_velocity_time[0].first) + std::abs(rise_velocity_time[0].second));

    for (size_t i = 0; i < tot; i++) {
        test0->add_data(time_vec[i + 1], area_time[i + 1]);
        test1->add_data(time_vec[i + 1], l1_err_u_n_time[i + 1]);
        test2->add_data(time_vec[i + 1], linf_err_u_n_time[i + 1]);
        test1_counter->add_data(i + 1, l1_err_u_n_time[i + 1]);
        test2_counter->add_data(i + 1, linf_err_u_n_time[i + 1]);
        test3->add_data(time_vec[i + 1], max_val_u_n_time[i + 1]);
//        test1->add_data(time_vec[i+1] ,l1_err_u_n_time[i] );
//        test2->add_data(time_vec[i+1] ,linf_err_u_n_time[i] );
//        test1_counter->add_data(i+1 ,l1_err_u_n_time[i] );
//        test2_counter->add_data(i+1 ,linf_err_u_n_time[i] );
//        test3->add_data(time_vec[i+1] ,max_val_u_n_time[i] );
        test4->add_data(time_vec[i + 1], l1_err_curvature_time[i + 1]);
        test5->add_data(time_vec[i + 1], linf_err_curvature_time[i + 1]);
        test4_counter->add_data(i + 1, l1_err_curvature_time[i + 1]);
        test5_counter->add_data(i + 1, linf_err_curvature_time[i + 1]);

        test0b->add_data(time_vec[i + 1], area_time[i + 1] / area_time[0]);

        test1b->add_data(time_vec[i + 1], l1_err_u_n_time[i + 1] / l1_err_u_n_time[0]);
        test2b->add_data(time_vec[i + 1], linf_err_u_n_time[i + 1] / linf_err_u_n_time[0]);
        test3b->add_data(time_vec[i + 1], max_val_u_n_time[i + 1] / max_val_u_n_time[0]);
//        test1b->add_data(time_vec[i+1] ,l1_err_u_n_time[i]/l1_err_u_n_time[0] );
//        test2b->add_data(time_vec[i+1] ,linf_err_u_n_time[i]/linf_err_u_n_time[0] );
//        test3b->add_data(time_vec[i+1] ,max_val_u_n_time[i]/max_val_u_n_time[0]  );
        test4b->add_data(time_vec[i + 1], l1_err_curvature_time[i + 1] / l1_err_curvature_time[0]);
        test5b->add_data(time_vec[i + 1], linf_err_curvature_time[i + 1] / linf_err_curvature_time[0]);


        testcomx->add_data(time_vec[i + 1],
                           std::abs(centre_mass_err_time[i + 1].first - centre_mass_err_time[0].first) /
                           centre_mass_err_time[0].first);
        testcomy->add_data(time_vec[i + 1],
                           std::abs(centre_mass_err_time[i + 1].second - centre_mass_err_time[0].second) /
                           centre_mass_err_time[0].second);
        testcom->add_data(time_vec[i + 1], std::abs(centre_mass_err_time[i + 1].first - centre_mass_err_time[0].first) /
                                           centre_mass_err_time[0].first + std::abs(
                centre_mass_err_time[i + 1].second - centre_mass_err_time[0].second) / centre_mass_err_time[0].second);


        testm0->add_data(time_vec[i + 1], min_max_vec[i + 1].first);
        testm1->add_data(time_vec[i + 1], min_max_vec[i + 1].first / min_max_vec[0].first);
        testM0->add_data(time_vec[i + 1], min_max_vec[i + 1].second);
        testM1->add_data(time_vec[i + 1], min_max_vec[i + 1].second / min_max_vec[0].second);


        testper0->add_data(time_vec[i + 1], perimeter_time[i + 1]);
        testper1->add_data(time_vec[i + 1], perimeter_time[i + 1] / perimeter_time[0]);
        testper2->add_data(time_vec[i + 1], std::abs(perimeter_time[i + 1] - perimetre_ref) / perimetre_ref);
        testper2_counter->add_data(i + 1, std::abs(perimeter_time[i + 1] - perimetre_ref) / perimetre_ref);

        testcirc->add_data(time_vec[i + 1], circularity_time[i + 1]);
        testcirc1->add_data(time_vec[i + 1], std::abs(circularity_time[i + 1] - circularity_ref) / circularity_ref);
        testcirc1_counter->add_data(i + 1, std::abs(circularity_time[i + 1] - circularity_ref) / circularity_ref);

        test0c->add_data(time_vec[i + 1], std::abs(area_time[i + 1] - area_time[0]) / area_time[0]);
        test0c_counter->add_data(i + 1, std::abs(area_time[i + 1] - area_time[0]) / area_time[0]);
//test4c->add_data(time_vec[i+1] , std::abs(l1_err_curvature_time[i+1] - l1_err_curvature_time[0] )/l1_err_curvature_time[0]);

        testflux->add_data(time_vec[i + 1], flux_interface_time[i + 1]);
        testvelx->add_data(time_vec[i + 1], std::abs(rise_velocity_time[i + 1].first));
        testvely->add_data(time_vec[i + 1], std::abs(rise_velocity_time[i + 1].second));
        testvel->add_data(time_vec[i + 1],
                          std::abs(rise_velocity_time[i + 1].first) + std::abs(rise_velocity_time[i + 1].second));
        testvel_counter->add_data(i + 1, std::abs(rise_velocity_time[i + 1].first) +
                                         std::abs(rise_velocity_time[i + 1].second));

        testref0->add_data(time_vec[i + 1], area_ref);
        testref1->add_data(time_vec[i + 1], perimetre_ref);
        testref2->add_data(time_vec[i + 1], circularity_ref);

        testanal0->add_data(time_vec[i + 1], area_analytic);
        testanal1->add_data(time_vec[i + 1], perimeter_analytic);

//std::cout<<"time_vec[i] = "<<time_vec[i]<<", time_vec[i+1] = "<<time_vec[i+1]<<", dt = "<<dt<<", error = "<<std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt )<<std::endl;
        if (std::abs(std::abs(time_vec[i + 1] - time_vec[i]) - dt) > 1e-10) {
            test_dt->add_data(time_vec[i], 0.0);
            test_dt->add_data(time_vec[i + 1], 0.0);
        }
    }


    postoutput.add_object(test0);
    postoutput.add_object(test1);
    postoutput.add_object(test2);
    postoutput.add_object(test1_counter);
    postoutput.add_object(test2_counter);


    postoutput.add_object(test3);
    postoutput.add_object(test4);
    postoutput.add_object(test5);
    postoutput.add_object(test4_counter);
    postoutput.add_object(test5_counter);

    postoutput.add_object(test0b);
    postoutput.add_object(test1b);
    postoutput.add_object(test2b);
    postoutput.add_object(test3b);
    postoutput.add_object(test4b);
    postoutput.add_object(test5b);

    postoutput.add_object(testcomx);
    postoutput.add_object(testcomy);
    postoutput.add_object(testcom);

    postoutput.add_object(testm0);
    postoutput.add_object(testm1);
    postoutput.add_object(testM0);
    postoutput.add_object(testM1);

    postoutput.add_object(testper0);
    postoutput.add_object(testper1);
    postoutput.add_object(testper2);
    postoutput.add_object(testper2_counter);


    postoutput.add_object(testcirc);
    postoutput.add_object(testcirc1);
    postoutput.add_object(testcirc1_counter);

    postoutput.add_object(test0c);
    postoutput.add_object(test0c_counter);
//postoutput.add_object(test4c);

    postoutput.add_object(testflux);
    postoutput.add_object(testvelx);
    postoutput.add_object(testvely);
    postoutput.add_object(testvel);
    postoutput.add_object(testvel_counter);


    postoutput.add_object(testref0);
    postoutput.add_object(testref1);
    postoutput.add_object(testref2);

    postoutput.add_object(testanal0);
    postoutput.add_object(testanal1);


    postoutput.add_object(test_dt);

    postoutput.write();

}

template<typename T>
void
plotting_in_time_new(const std::vector <T> &time_vec, const std::vector <T> &area_time,
                     const std::vector <T> &l1_err_u_n_time, const std::vector <T> &linf_err_u_n_time,
                     const std::vector <T> &max_val_u_n_time, const std::vector <T> &l1_err_curvature_time,
                     const std::vector <T> &linf_err_curvature_time, T dt,
                     const std::vector <std::pair<T, T>> &min_max_vec, const std::vector <T> &flux_interface_time,
                     const std::vector <std::pair<T, T>> &rise_velocity_time,
                     const std::vector <std::pair<T, T>> &centre_mass_err_time, const std::vector <T> &perimeter_time,
                     const std::vector <T> &circularity_time, T circularity_ref, T perimetre_ref, T area_ref, T radius,
                     const std::vector <T> &L1_err_u_n_time, const std::vector <T> &l1_err_u_n_time_para,
                     const std::vector <T> &linf_err_u_n_time_para, const std::vector <T> &L1_err_u_n_time_para,
                     const std::vector <T> &max_val_u_n_time_para) {

    postprocess_output <T> postoutput;

//    auto testref0  = std::make_shared< gnuplot_output_object_time<T> >("area_ref_time.dat");
//    auto testref1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_ref_time.dat");
//    auto testref2  = std::make_shared< gnuplot_output_object_time<T> >("circularity_ref_time.dat");

    T area_analytic = M_PI * radius * radius;
    T perimeter_analytic = 2.0 * M_PI * radius;
//    auto testanal0  = std::make_shared< gnuplot_output_object_time<T> >("area_anal_time.dat");
//    auto testanal1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_anal_time.dat");


    auto test0 = std::make_shared < gnuplot_output_object_time < T > > ("area_time.dat");
    auto test1 = std::make_shared < gnuplot_output_object_time < T > > ("lpiccolo1_err_u_n_time.dat");
    auto test2 = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_u_n_time.dat");

    auto test_der_int = std::make_shared < gnuplot_output_object_time < T > > ("linf_der_interface_time.dat");

//    auto test1_counter  = std::make_shared< gnuplot_output_object_time<T> >("lpiccolo1_err_u_n_time_counter.dat");
//    auto test2_counter  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time_counter.dat");

//    auto test3  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time.dat");
    auto test4 = std::make_shared < gnuplot_output_object_time < T > > ("l1_err_curvature_time.dat");
    auto test5 = std::make_shared < gnuplot_output_object_time < T > > ("linf_err_curvature_time.dat");
//    auto test4_counter  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_curvature_time_counter.dat");
//    auto test5_counter  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_curvature_time_counter.dat");

    auto test_new0 = std::make_shared < gnuplot_output_object_time < T > > ("Lgrande1_err_u_n_time.dat");
//    auto test_new1  = std::make_shared< gnuplot_output_object_time<T> >("lpiccolo1_err_u_n_time_para.dat");
//    auto test_new2  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time_para.dat");
//    auto test_new3  = std::make_shared< gnuplot_output_object_time<T> >("Lgrande1_err_u_n_time_para.dat");
//    auto test_new4  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time_para.dat");

//    auto test_new0_counter  = std::make_shared< gnuplot_output_object_time<T> >("Lgrande1_err_u_n_time_counter.dat");
//    auto test_new1_counter  = std::make_shared< gnuplot_output_object_time<T> >("lpiccolo1_err_u_n_time_para_counter.dat");
//    auto test_new2_counter  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time_para_counter.dat");
//    auto test_new3_counter  = std::make_shared< gnuplot_output_object_time<T> >("Lgrande1_err_u_n_time_para_counter.dat");
//    auto test_new4_counter  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time_para_counter.dat");




//    auto test0b  = std::make_shared< gnuplot_output_object_time<T> >("area_time_normalised.dat");

//    auto test1b  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_u_n_time_normalised.dat");
//    auto test2b  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time_normalised.dat");
//    auto test3b  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time_normalised.dat");
//    auto test4b  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_curvature_time_normalised.dat");
//    auto test5b  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_curvature_time_normalised.dat");
// //auto test4c  = std::make_shared< gnuplot_output_object_time<T> >("l1_l1_err_curvature_err_time.dat");

    auto test_dt = std::make_shared < gnuplot_output_object_time < T > > ("dt_M.dat");
    auto test_e = std::make_shared < gnuplot_output_object_time < T > > ("eccentricity.dat");

    auto test0c = std::make_shared < gnuplot_output_object_time < T > > ("area_time_err.dat");
    auto test0c_counter = std::make_shared < gnuplot_output_object_time < T > > ("area_time_err_counter.dat");

//    auto testm0  = std::make_shared< gnuplot_output_object_time<T> >("min_time.dat");
//    auto testm1  = std::make_shared< gnuplot_output_object_time<T> >("min_normalised_time.dat");
//    auto testM0  = std::make_shared< gnuplot_output_object_time<T> >("max_time.dat");
//    auto testM1  = std::make_shared< gnuplot_output_object_time<T> >("max_normalised_time.dat");
    auto testflux = std::make_shared < gnuplot_output_object_time < T > > ("flux_interface_time.dat");
//    auto testvelx  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_x_time.dat");
//    auto testvely  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_y_time.dat");
    auto testvel = std::make_shared < gnuplot_output_object_time < T > > ("rise_velocity_err_time.dat");
//    auto testvel_counter  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_time_counter.dat");
    auto testcomx = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_x_time.dat");
    auto testcomy = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_y_time.dat");
    auto testcom = std::make_shared < gnuplot_output_object_time < T > > ("centre_mass_err_time.dat");


    auto testper0 = std::make_shared < gnuplot_output_object_time < T > > ("perimeter_time.dat");
//    auto testper1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_normalised_time.dat");
//    auto testper2  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_err_time.dat");
//    auto testper2_counter  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_err_time_counter.dat");

    auto testcirc = std::make_shared < gnuplot_output_object_time < T > > ("circularity_time.dat");
    auto testcirc1 = std::make_shared < gnuplot_output_object_time < T > > ("circularity_error_time.dat");
    auto testcirc1_counter =
            std::make_shared < gnuplot_output_object_time < T > > ("circularity_error_time_counter.dat");

    size_t tot = l1_err_u_n_time.size();

//    testm0->add_data(time_vec[0] ,min_max_vec[0].first );
//    testm1->add_data(time_vec[0] ,1.0 );
//    testM0->add_data(time_vec[0] ,min_max_vec[0].second );
//    testM1->add_data(time_vec[0] ,1.0 );

    testcomx->add_data(time_vec[0], 0.0);
    testcomy->add_data(time_vec[0], 0.0);
    testcom->add_data(time_vec[0], 0.0);


    testper0->add_data(time_vec[0], perimeter_time[0]);
//    testper1->add_data(time_vec[0] , 1.0 );
//    testper2->add_data(time_vec[0] , std::abs(perimeter_time[0] - perimetre_ref)/perimetre_ref );
//    testper2_counter->add_data(0 , std::abs(perimeter_time[0] - perimetre_ref)/perimetre_ref );

    testcirc->add_data(time_vec[0], circularity_time[0]);
    testcirc1->add_data(time_vec[0], std::abs(circularity_time[0] - circularity_ref) / circularity_ref);
    testcirc1_counter->add_data(0, std::abs(circularity_time[0] - circularity_ref) / circularity_ref);

    test0c->add_data(time_vec[0], 0.0);
    test0c_counter->add_data(0, 0.0);
//test4c->add_data(time_vec[0] , 0.0 );


    test0->add_data(time_vec[0], area_time[0]);
// ADD 8/01/21
    test1->add_data(time_vec[0], l1_err_u_n_time[0]);
    test2->add_data(time_vec[0], linf_err_u_n_time[0]);
//    test1_counter->add_data(0 ,l1_err_u_n_time[0] );
//    test2_counter->add_data(0 ,linf_err_u_n_time[0] );
//    test3->add_data(time_vec[0] ,max_val_u_n_time[0] );
// UP TO HERE
    test4->add_data(time_vec[0], l1_err_curvature_time[0]);
    test5->add_data(time_vec[0], linf_err_curvature_time[0]);
//    test4_counter->add_data(0 ,l1_err_curvature_time[0] );
//    test5_counter->add_data(0 ,linf_err_curvature_time[0] );

    test_new0->add_data(time_vec[0], L1_err_u_n_time[0]);
//    test_new1->add_data(time_vec[0] ,l1_err_u_n_time_para[0] );
//    test_new2->add_data(time_vec[0] ,linf_err_u_n_time_para[0] );
//    test_new3->add_data(time_vec[0] ,L1_err_u_n_time_para[0] );
//    test_new4->add_data(time_vec[0] ,max_val_u_n_time_para[0] );
//
//    test_new0_counter->add_data(0 ,L1_err_u_n_time[0] );
//    test_new1_counter->add_data(0 ,l1_err_u_n_time_para[0] );
//    test_new2_counter->add_data(0 ,linf_err_u_n_time_para[0] );
//    test_new3_counter->add_data(0,L1_err_u_n_time_para[0] );
//    test_new4_counter->add_data(0 ,max_val_u_n_time_para[0] );
//
//
//
//    test0b->add_data(time_vec[0] ,area_time[0]/area_time[0] );
// ADD 8/01/21
//    test1b->add_data(time_vec[0] ,l1_err_u_n_time[0]/l1_err_u_n_time[0] );
//    test2b->add_data(time_vec[0] ,linf_err_u_n_time[0]/linf_err_u_n_time[0] );
//    test3b->add_data(time_vec[0] ,max_val_u_n_time[0]/max_val_u_n_time[0]  );
// UP TO HERE
//    test4b->add_data(time_vec[0] ,l1_err_curvature_time[0]/l1_err_curvature_time[0]  );
//    test5b->add_data(time_vec[0] ,linf_err_curvature_time[0]/linf_err_curvature_time[0]  );
//
//    testref0->add_data(time_vec[0] , area_ref );
//    testref1->add_data(time_vec[0] , perimetre_ref );
//    testref2->add_data(time_vec[0] , circularity_ref );

//    testanal0->add_data(time_vec[0] , area_analytic );
//    testanal1->add_data(time_vec[0] , perimeter_analytic );


    testflux->add_data(time_vec[0], flux_interface_time[0]);
//    testvelx ->add_data(time_vec[0] , std::abs(rise_velocity_time[0].first) );
//    testvely ->add_data(time_vec[0] , std::abs(rise_velocity_time[0].second) );
    testvel->add_data(time_vec[0], std::abs(rise_velocity_time[0].first) + std::abs(rise_velocity_time[0].second));
//    testvel_counter->add_data(0, std::abs(rise_velocity_time[0].first) + std::abs(rise_velocity_time[0].second) );
    test_dt->add_data(time_vec[0], 0.0);
//test_e->add_data(time_vec[0] , eccentricity_vec[0] );
    test_der_int->add_data(time_vec[0], 0.0);
    for (size_t i = 0; i < tot - 1; i++) {
        test0->add_data(time_vec[i + 1], area_time[i + 1]);
        test1->add_data(time_vec[i + 1], l1_err_u_n_time[i + 1]);
        test2->add_data(time_vec[i + 1], linf_err_u_n_time[i + 1]);
//test_der_int->add_data(time_vec[i+1] ,linf_der_time_interface[i] );

//        test1_counter->add_data(i+1 ,l1_err_u_n_time[i+1] );
//        test2_counter->add_data(i+1 ,linf_err_u_n_time[i+1] );
//        test3->add_data(time_vec[i+1] ,max_val_u_n_time[i+1] );
////        test1->add_data(time_vec[i+1] ,l1_err_u_n_time[i] );
////        test2->add_data(time_vec[i+1] ,linf_err_u_n_time[i] );
////        test1_counter->add_data(i+1 ,l1_err_u_n_time[i] );
////        test2_counter->add_data(i+1 ,linf_err_u_n_time[i] );
////        test3->add_data(time_vec[i+1] ,max_val_u_n_time[i] );
        test4->add_data(time_vec[i + 1], l1_err_curvature_time[i + 1]);
        test5->add_data(time_vec[i + 1], linf_err_curvature_time[i + 1]);
//        test4_counter->add_data(i+1 ,l1_err_curvature_time[i+1] );
//        test5_counter->add_data(i+1 ,linf_err_curvature_time[i+1] );

//        test0b->add_data(time_vec[i+1] ,area_time[i+1]/area_time[0] );
//
//        test1b->add_data(time_vec[i+1] ,l1_err_u_n_time[i+1]/l1_err_u_n_time[0] );
//        test2b->add_data(time_vec[i+1] ,linf_err_u_n_time[i+1]/linf_err_u_n_time[0] );
//        test3b->add_data(time_vec[i+1] ,max_val_u_n_time[i+1]/max_val_u_n_time[0]  );
////        test1b->add_data(time_vec[i+1] ,l1_err_u_n_time[i]/l1_err_u_n_time[0] );
////        test2b->add_data(time_vec[i+1] ,linf_err_u_n_time[i]/linf_err_u_n_time[0] );
////        test3b->add_data(time_vec[i+1] ,max_val_u_n_time[i]/max_val_u_n_time[0]  );
//        test4b->add_data(time_vec[i+1] ,l1_err_curvature_time[i+1]/l1_err_curvature_time[0] );
//        test5b->add_data(time_vec[i+1] ,linf_err_curvature_time[i+1]/linf_err_curvature_time[0]  );

        test_new0->add_data(time_vec[i + 1], L1_err_u_n_time[i + 1]);
//        test_new1->add_data(time_vec[i+1] ,l1_err_u_n_time_para[i+1] );
//        test_new2->add_data(time_vec[i+1] ,linf_err_u_n_time_para[i+1] );
//        test_new3->add_data(time_vec[i+1] ,L1_err_u_n_time_para[i+1] );
//        test_new4->add_data(time_vec[i+1] ,max_val_u_n_time_para[i+1] );

//        test_new0_counter->add_data(i+1 ,L1_err_u_n_time[i+1] );
//        test_new1_counter->add_data(i+1 ,l1_err_u_n_time_para[i+1] );
//        test_new2_counter->add_data(i+1 ,linf_err_u_n_time_para[i+1] );
//        test_new3_counter->add_data(i+1,L1_err_u_n_time_para[i+1] );
//        test_new4_counter->add_data(i+1 ,max_val_u_n_time_para[i+1] );

        testcomx->add_data(time_vec[i + 1],
                           std::abs(centre_mass_err_time[i + 1].first - centre_mass_err_time[0].first) /
                           centre_mass_err_time[0].first);
        testcomy->add_data(time_vec[i + 1],
                           std::abs(centre_mass_err_time[i + 1].second - centre_mass_err_time[0].second) /
                           centre_mass_err_time[0].second);
        testcom->add_data(time_vec[i + 1], std::abs(centre_mass_err_time[i + 1].first - centre_mass_err_time[0].first) /
                                           centre_mass_err_time[0].first + std::abs(
                centre_mass_err_time[i + 1].second - centre_mass_err_time[0].second) / centre_mass_err_time[0].second);


//        testm0->add_data(time_vec[i+1] , min_max_vec[i+1].first );
//        testm1->add_data(time_vec[i+1] ,min_max_vec[i+1].first/min_max_vec[0].first );
//        testM0->add_data(time_vec[i+1] , min_max_vec[i+1].second );
//        testM1->add_data(time_vec[i+1] ,min_max_vec[i+1].second/min_max_vec[0].second );


        testper0->add_data(time_vec[i + 1], perimeter_time[i + 1]);
//        testper1->add_data(time_vec[i+1] , perimeter_time[i+1]/perimeter_time[0] );
//        testper2->add_data(time_vec[i+1] , std::abs( perimeter_time[i+1] - perimetre_ref) / perimetre_ref );
//        testper2_counter->add_data(i+1 , std::abs( perimeter_time[i+1] - perimetre_ref) / perimetre_ref );

        testcirc->add_data(time_vec[i + 1], circularity_time[i + 1]);
        testcirc1->add_data(time_vec[i + 1], std::abs(circularity_time[i + 1] - circularity_ref) / circularity_ref);
        testcirc1_counter->add_data(i + 1, std::abs(circularity_time[i + 1] - circularity_ref) / circularity_ref);

        test0c->add_data(time_vec[i + 1], std::abs(area_time[i + 1] - area_time[0]) / area_time[0]);
        test0c_counter->add_data(i + 1, std::abs(area_time[i + 1] - area_time[0]) / area_time[0]);
//test4c->add_data(time_vec[i+1] , std::abs(l1_err_curvature_time[i+1] - l1_err_curvature_time[0] )/l1_err_curvature_time[0]);

        testflux->add_data(time_vec[i + 1], flux_interface_time[i + 1]);
//        testvelx ->add_data(time_vec[i+1] , std::abs(rise_velocity_time[i+1].first) );
//        testvely ->add_data(time_vec[i+1] , std::abs(rise_velocity_time[i+1].second) );
        testvel->add_data(time_vec[i + 1],
                          std::abs(rise_velocity_time[i + 1].first) + std::abs(rise_velocity_time[i + 1].second));
//        testvel_counter->add_data(i+1 , std::abs(rise_velocity_time[i+1].first) + std::abs(rise_velocity_time[i+1].second) );

//        testref0->add_data(time_vec[i+1] , area_ref );
//        testref1->add_data(time_vec[i+1] , perimetre_ref );
//        testref2->add_data(time_vec[i+1] , circularity_ref );
//
//        testanal0->add_data(time_vec[i+1] , area_analytic );
//        testanal1->add_data(time_vec[i+1] , perimeter_analytic );

//std::cout<<"time_vec[i] = "<<time_vec[i]<<", time_vec[i+1] = "<<time_vec[i+1]<<", dt = "<<dt<<", error = "<<std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt )<<std::endl;
//        if( std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt ) > 1e-10 ){
//
//            test_dt->add_data(time_vec[i+1] , 0.0 );
//        }
        test_dt->add_data(time_vec[i + 1], time_vec[i + 1] - time_vec[i]);
//test_e->add_data(time_vec[i+1] , eccentricity_vec[i] );

    }


    postoutput.add_object(test0);
    postoutput.add_object(test1);
    postoutput.add_object(test2);
    postoutput.add_object(test_der_int);


//    postoutput.add_object(test1_counter);
//    postoutput.add_object(test2_counter);


//    postoutput.add_object(test3);
    postoutput.add_object(test4);
    postoutput.add_object(test5);
//    postoutput.add_object(test4_counter);
//    postoutput.add_object(test5_counter);

    postoutput.add_object(test_new0);
//    postoutput.add_object(test_new1);
//    postoutput.add_object(test_new2);
//    postoutput.add_object(test_new3);
//    postoutput.add_object(test_new4);
//
//    postoutput.add_object(test_new0_counter);
//    postoutput.add_object(test_new1_counter);
//    postoutput.add_object(test_new2_counter);
//    postoutput.add_object(test_new3_counter);
//    postoutput.add_object(test_new4_counter);
//
//
//
//
//    postoutput.add_object(test0b);
//    postoutput.add_object(test1b);
//    postoutput.add_object(test2b);
//    postoutput.add_object(test3b);
//    postoutput.add_object(test4b);
//    postoutput.add_object(test5b);

    postoutput.add_object(testcomx);
    postoutput.add_object(testcomy);
    postoutput.add_object(testcom);

//    postoutput.add_object(testm0);
//    postoutput.add_object(testm1);
//    postoutput.add_object(testM0);
//    postoutput.add_object(testM1);

    postoutput.add_object(testper0);
//    postoutput.add_object(testper1);
//    postoutput.add_object(testper2);
//    postoutput.add_object(testper2_counter);


    postoutput.add_object(testcirc);
    postoutput.add_object(testcirc1);
    postoutput.add_object(testcirc1_counter);

    postoutput.add_object(test0c);
    postoutput.add_object(test0c_counter);
//postoutput.add_object(test4c);

    postoutput.add_object(testflux);
//    postoutput.add_object(testvelx);
//    postoutput.add_object(testvely);
    postoutput.add_object(testvel);
//    postoutput.add_object(testvel_counter);


//    postoutput.add_object(testref0);
//    postoutput.add_object(testref1);
//    postoutput.add_object(testref2);

//    postoutput.add_object(testanal0);
//    postoutput.add_object(testanal1);


    postoutput.add_object(test_dt);
    postoutput.add_object(test_e);

    postoutput.write();

}


template<typename T>
void
plotting_in_time(const std::vector <T> &time_vec, const std::vector <T> &area_time,
                 const std::vector <T> &l1_err_u_n_time, const std::vector <T> &linf_err_u_n_time,
                 const std::vector <T> &max_val_u_n_time, const std::vector <T> &l1_err_curvature_time,
                 const std::vector <T> &linf_err_curvature_time, T dt) {

    postprocess_output <T> postoutput;

    auto test0 = std::make_shared < gnuplot_output_object_time < double > > ("area_time.dat");
    auto test1 = std::make_shared < gnuplot_output_object_time < double > > ("l1_err_u_n_time.dat");
    auto test2 = std::make_shared < gnuplot_output_object_time < double > > ("linf_err_u_n_time.dat");
    auto test3 = std::make_shared < gnuplot_output_object_time < double > > ("max_val_u_n_time.dat");
    auto test4 = std::make_shared < gnuplot_output_object_time < double > > ("l1_err_curvature_time.dat");
    auto test5 = std::make_shared < gnuplot_output_object_time < double > > ("linf_err_curvature_time.dat");

    auto test0b = std::make_shared < gnuplot_output_object_time < double > > ("area_time_normalised.dat");
    auto test1b = std::make_shared < gnuplot_output_object_time < double > > ("l1_err_u_n_time_normalised.dat");
    auto test2b = std::make_shared < gnuplot_output_object_time < double > > ("linf_err_u_n_time_normalised.dat");
    auto test3b = std::make_shared < gnuplot_output_object_time < double > > ("max_val_u_n_time_normalised.dat");
    auto test4b = std::make_shared < gnuplot_output_object_time < double > > ("l1_err_curvature_time_normalised.dat");
    auto test5b = std::make_shared < gnuplot_output_object_time < double > > ("linf_err_curvature_time_normalised.dat");

    auto test_dt = std::make_shared < gnuplot_output_object_time < double > > ("dt_M.dat");


    size_t tot = l1_err_u_n_time.size();
    test0->add_data(time_vec[0], area_time[0]);
    test4->add_data(time_vec[0], l1_err_curvature_time[0]);
    test5->add_data(time_vec[0], linf_err_curvature_time[0]);

    test0b->add_data(time_vec[0], area_time[0] / area_time[0]);
    test4b->add_data(time_vec[0], l1_err_curvature_time[0] / l1_err_curvature_time[0]);
    test5b->add_data(time_vec[0], linf_err_curvature_time[0] / linf_err_curvature_time[0]);

    for (size_t i = 0; i < tot; i++) {
        test0->add_data(time_vec[i + 1], area_time[i + 1]);
        test1->add_data(time_vec[i + 1], l1_err_u_n_time[i]);
        test2->add_data(time_vec[i + 1], linf_err_u_n_time[i]);
        test3->add_data(time_vec[i + 1], max_val_u_n_time[i]);
        test4->add_data(time_vec[i + 1], l1_err_curvature_time[i + 1]);
        test5->add_data(time_vec[i + 1], linf_err_curvature_time[i + 1]);

        test0b->add_data(time_vec[i + 1], area_time[i + 1] / area_time[0]);
        test1b->add_data(time_vec[i + 1], l1_err_u_n_time[i] / l1_err_u_n_time[0]);
        test2b->add_data(time_vec[i + 1], linf_err_u_n_time[i] / linf_err_u_n_time[0]);
        test3b->add_data(time_vec[i + 1], max_val_u_n_time[i] / max_val_u_n_time[0]);
        test4b->add_data(time_vec[i + 1], l1_err_curvature_time[i + 1] / l1_err_curvature_time[0]);
        test5b->add_data(time_vec[i + 1], linf_err_curvature_time[i + 1] / linf_err_curvature_time[0]);

//std::cout<<"time_vec[i] = "<<time_vec[i]<<", time_vec[i+1] = "<<time_vec[i+1]<<", dt = "<<dt<<", error = "<<std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt )<<std::endl;
        if (std::abs(std::abs(time_vec[i + 1] - time_vec[i]) - dt) > 1e-10) {
            test_dt->add_data(time_vec[i], 0.0);
            test_dt->add_data(time_vec[i + 1], 0.0);
        }
    }


    postoutput.add_object(test0);
    postoutput.add_object(test1);
    postoutput.add_object(test2);
    postoutput.add_object(test3);
    postoutput.add_object(test4);
    postoutput.add_object(test5);
    postoutput.add_object(test0b);
    postoutput.add_object(test1b);
    postoutput.add_object(test2b);
    postoutput.add_object(test3b);
    postoutput.add_object(test4b);
    postoutput.add_object(test5b);

    postoutput.add_object(test_dt);

    postoutput.write();

}

template<typename FonctionD, typename Mesh>
void
testing_level_set(const Mesh &msh, const FonctionD &level_set_disc, std::string &folder) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, derDx, derDy;
    Eigen::Matrix<double, 2, 1> derD;
    point<double, 2> node;
    size_t N, M;

    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc = std::make_shared < gnuplot_output_object < double > > (folder + "testing_interface_disc.dat");


    auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_discX.dat");

    auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_discY.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > (folder + "test_profile_disc.dat");

    auto test_profile_obliq_disc =
            std::make_shared < gnuplot_output_object < double > > (folder + "test_profile_obliq.dat");


    auto test_disc_grad = std::make_shared < gnuplot_output_object < double > > (folder + "testing_der_disc_fin.dat");

    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();
        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {

                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);
                valueD = level_set_disc(node, msh, cl);
                derD = level_set_disc.gradient(node, msh, cl);


                derDx = derD(0);
                derDy = derD(1);


                test_disc->add_data(node, valueD);

                test_disc_gradX->add_data(node, derDx);
                test_disc_gradY->add_data(node, derDy);
                test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));

            }


        }
    }

    for (size_t i = 0; i <= 100; i++) {
        double px = i * ((1.0) / 100.0);
        node = point_type(px, 0.5);
        valueD = level_set_disc(node);
        test_profile_disc->add_data(node, valueD);
    }

    for (size_t i = 0; i <= 100; i++) {
        double px = i * ((1.0) / 100.0);
        node = point_type(px, px);
        valueD = level_set_disc(node);
        test_profile_obliq_disc->add_data(node, valueD);
    }


    postoutput1.add_object(test_disc);

    postoutput1.add_object(test_disc_grad);
    postoutput1.add_object(test_disc_gradX);

    postoutput1.add_object(test_disc_gradY);

    postoutput1.add_object(test_profile_disc);

    postoutput1.add_object(test_profile_obliq_disc);


    postoutput1.write();

}

template<typename FonctionD, typename Mesh>
void
testing_level_set_mapped(const Mesh &msh, const FonctionD &level_set_disc) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, derDx, derDy;
    Eigen::Matrix<double, 2, 1> derD;
    point<double, 2> node;
    size_t N, M;

    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_mapped.dat");


    auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX_mapped.dat");

    auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY_mapped.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_mapped.dat");

    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();
        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {

                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);
                valueD = level_set_disc(node, msh, cl);
                derD = level_set_disc.gradient(node, msh, cl);


                derDx = derD(0);
                derDy = derD(1);


                test_disc->add_data(node, valueD);

                test_disc_gradX->add_data(node, derDx);
                test_disc_gradY->add_data(node, derDy);


            }


        }
    }

    for (size_t i = 0; i <= 100; i++) {
        double px = i * ((1.0) / 100.0);
        node = point_type(px, 0.5);
        valueD = level_set_disc(node);
        test_profile_disc->add_data(node, valueD);
    }

    postoutput1.add_object(test_disc);


    postoutput1.add_object(test_disc_gradX);

    postoutput1.add_object(test_disc_gradY);

    postoutput1.add_object(test_profile_disc);


    postoutput1.write();

}

template<typename FonctionD, typename Mesh>
void
testing_level_set_inverse_mapped(const Mesh &msh, const FonctionD &level_set_disc) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, derDx, derDy;
    Eigen::Matrix<double, 2, 1> derD;
    point<double, 2> node;
    size_t N, M;

    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc =
            std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_inverse_mapped.dat");


    auto test_disc_gradX =
            std::make_shared < gnuplot_output_object < double > > ("testing_der_discX_inverse_mapped.dat");

    auto test_disc_gradY =
            std::make_shared < gnuplot_output_object < double > > ("testing_der_discY_inverse_mapped.dat");

    auto test_profile_disc =
            std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_inverse_mapped.dat");

    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();
        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {

                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);
                valueD = level_set_disc(node, msh, cl);
                derD = level_set_disc.gradient(node, msh, cl);


                derDx = derD(0);
                derDy = derD(1);


                test_disc->add_data(node, valueD);

                test_disc_gradX->add_data(node, derDx);
                test_disc_gradY->add_data(node, derDy);


            }


        }
    }

    for (size_t i = 0; i <= 100; i++) {
        double px = i * ((1.0) / 100.0);
        node = point_type(px, 0.5);
        valueD = level_set_disc(node);
        test_profile_disc->add_data(node, valueD);
    }

    postoutput1.add_object(test_disc);


    postoutput1.add_object(test_disc_gradX);

    postoutput1.add_object(test_disc_gradY);

    postoutput1.add_object(test_profile_disc);


    postoutput1.write();

}

template<typename FonctionD, typename Mesh, typename FonctionA>
void
testing_level_set(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA, derDx, derDy, derAx, derAy, value_profile, value_profile_anal;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    std::cout << "In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_anal.dat");

    auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_analX.dat");

    auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_analY.dat");

    auto test_anal_grad = std::make_shared < gnuplot_output_object < double > > ("testing_der_anal.dat");
    auto test_disc_grad = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc.dat");
    auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_anal.dat");

    auto pt_c_x = level_set_anal.alpha;
    auto pt_c_y = level_set_anal.beta;
    auto pt_c = point_type(pt_c_x, pt_c_y);
    double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        if (pt_in_cell(msh, pt_c, cl)) {
            test_disc_gradX->add_data(node, derDx);
            test_anal_gradX->add_data(node, derAx);
            test_disc_gradY->add_data(node, derDy);
            test_anal_gradY->add_data(node, derAy);

            test_anal_grad->add_data(node, sqrt(derAx * derAx + derAy * derAy));
            test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));
        }

        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {
                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);

                valueA = level_set_anal(node);
                valueD = level_set_disc(node, msh, cl);


                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);


                derA = level_set_anal.gradient(node);
                derD = level_set_disc.gradient(node, msh, cl);
                derDx = derD(0);
                derDy = derD(1);
                derAx = derA(0);
                derAy = derA(1);

                test_disc_gradX->add_data(node, derDx);
                test_anal_gradX->add_data(node, derAx);
                test_disc_gradY->add_data(node, derDy);
                test_anal_gradY->add_data(node, derAy);

                test_anal_grad->add_data(node, sqrt(derAx * derAx + derAy * derAy));
                test_disc_grad->add_data(node, sqrt(derDx * derDx + derDy * derDy));

            }

            node = point_type(px, py);
            value_profile = level_set_disc(node, msh, cl);
            test_profile_disc->add_data(node, value_profile);
            value_profile_anal = level_set_anal(node);
            test_profile_anal->add_data(node, value_profile_anal);
        }

    }


    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);

    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);

    postoutput1.add_object(test_anal_grad);
    postoutput1.add_object(test_disc_grad);


    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);

    postoutput1.write();

}


template<typename FonctionD, typename Mesh, typename FonctionA>
void
testing_level_set_disc(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA, derDx, derDy, derAx, derAy, value_profile, value_profile_anal;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    std::cout << "In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_disc_tmp.dat");

    auto test_disc_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc_tmp_X.dat");

    auto test_disc_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared < gnuplot_output_object < double > > ("testing_der_disc_tmp_Y.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc.dat");
    auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_tmp.dat");


    double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {
                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);

                valueA = level_set_anal(node, msh, cl);
                valueD = level_set_disc(node, msh, cl);


                test_disc->add_data(node, valueD);
                test_anal->add_data(node, valueA);


                derA = level_set_anal.gradient(node, msh, cl);
                derD = level_set_disc.gradient(node, msh, cl);
                derDx = derD(0);
                derDy = derD(1);
                derAx = derA(0);
                derAy = derA(1);

                test_disc_gradX->add_data(node, derDx);
                test_anal_gradX->add_data(node, derAx);
                test_disc_gradY->add_data(node, derDy);
                test_anal_gradY->add_data(node, derAy);


            }

            node = point_type(px, py);
            value_profile = level_set_disc(node, msh, cl);
            test_profile_disc->add_data(node, value_profile);
            value_profile_anal = level_set_anal(node, msh, cl);
            test_profile_anal->add_data(node, value_profile_anal);
        }

    }


    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);

    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);

    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);

    postoutput1.write();

}


template<typename FonctionD, typename Mesh>
void
testing_level_set2_bis(const Mesh msh, const FonctionD &level_set_disc) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD; // , derDx , derDy ;
    Eigen::Matrix<double, 2, 1> derD;
    point<double, 2> node;
    size_t N, M;
    std::cout
            << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."
            << std::endl;
    N = 40; //80 points to see also the interface!!!
    M = 40; //80 points to see also the interface!!!
    double valueD_gamma;
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_bis.dat");

    auto test_gamma_disc = std::make_shared < gnuplot_output_object < double > > ("test_gamma_disc_bis.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin_bis.dat");

    double iso_val_interface = level_set_disc.iso_val_interface;

    for (size_t i = 0; i <= N; i++) {
        for (size_t j = 0; j <= M; j++) {
            double px = i * (1.0 / N);
            double py = j * (1.0 / M);
            node = point_type(px, py);

            if (std::abs(level_set_disc(node) - iso_val_interface) < 1 * 1e-3) {
                valueD_gamma = 1;
            } else
                valueD_gamma = 0;

            valueD = level_set_disc(node);


            if (py == 0.5) {
                test_profile_disc->add_data(node, valueD);

            }


            test_disc->add_data(node, valueD);

            test_gamma_disc->add_data(node, valueD_gamma);


        }

    }
    postoutput1.add_object(test_disc);

    postoutput1.add_object(test_gamma_disc);

    postoutput1.add_object(test_profile_disc);

    postoutput1.write();

}

template<typename FonctionD, typename Mesh>
void
testing_level_set2(const Mesh &msh, const FonctionD &level_set_disc) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, value_profile;
    point<double, 2> node;
    size_t N, M;
    std::cout
            << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."
            << std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!

    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc.dat");

//auto test_gamma_disc = std::make_shared< gnuplot_output_object<double> >("test_gamma_disc.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin.dat");

    double py = 0.5;
//double iso_val_interface = level_set_disc.iso_val_interface ;
    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for (size_t i = 0; i <= N; i++) {
            double px = pt0_x + i * ((pt1_x - pt0_x) / N);
            for (size_t j = 0; j <= M; j++) {
                double py = pt0_y + j * ((pt1_y - pt0_y) / M);
                node = point_type(px, py);

                valueD = level_set_disc(node, msh, cl);
                test_disc->add_data(node, valueD);


            }

            node = point_type(px, py);
            value_profile = level_set_disc(node, msh, cl);
            test_profile_disc->add_data(node, value_profile);
        }

    }
    postoutput1.add_object(test_disc);

    postoutput1.add_object(test_profile_disc);

    postoutput1.write();

}

template<typename FonctionD, typename Mesh>
void
testing_level_set2(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    std::cout << "In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster." << std::endl;
    N = 40; //80 points to see also the interface!!!
    M = 40; //80 points to see also the interface!!!
    double valueA_gamma, valueD_gamma;
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal.dat");
    auto test_gamma_disc = std::make_shared < gnuplot_output_object < double > > ("test_gamma_disc.dat");
    auto test_gamma_anal = std::make_shared < gnuplot_output_object < double > > ("test_gamma_anal.dat");

    auto test_profile_disc = std::make_shared < gnuplot_output_object < double > > ("test_profile_disc_fin.dat");
    auto test_profile_anal = std::make_shared < gnuplot_output_object < double > > ("test_profile_anal_fin.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for (size_t i = 0; i <= N; i++) {
        for (size_t j = 0; j <= M; j++) {
            double px = i * (1.0 / N);
            double py = j * (1.0 / M);
            node = point_type(px, py);

            if (std::abs(level_set_disc(node)) < 1 * 1e-3) {
                valueD_gamma = 1;
            } else
                valueD_gamma = 0;

            valueD = level_set_disc(node);

            if (std::abs(level_set_fin(node)) < 1 * 1e-3) {
                valueA_gamma = 1;
            } else
                valueA_gamma = 0;

            valueA = level_set_fin(node);


            if (py == 0.5) {
                test_profile_disc->add_data(node, valueD);
                test_profile_anal->add_data(node, valueA);
            }

/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node, valueD);
            test_anal->add_data(node, valueA);
            test_gamma_disc->add_data(node, valueD_gamma);
            test_gamma_anal->add_data(node, valueA_gamma);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
    postoutput1.add_object(test_gamma_disc);
    postoutput1.add_object(test_gamma_anal);
    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh>
void
testing_level_set_mesh2(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh2.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh2.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for (size_t i = 0; i <= N; i++) {
        for (size_t j = 0; j <= M; j++) {
            double px = i * (1.0 / N);
            double py = j * (1.0 / M);
            node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node, valueD);
            test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh>
void
testing_level_set_mesh1(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh1.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh1.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for (size_t i = 0; i <= N; i++) {
        for (size_t j = 0; j <= M; j++) {
            double px = i * (1.0 / N);
            double py = j * (1.0 / M);
            node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node, valueD);
            test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh>
void
testing_level_set_mesh0(const Mesh msh, const FonctionD &level_set_disc, const FonctionD &level_set_fin) {
    typedef typename Mesh::point_type point_type;
    postprocess_output<double> postoutput1;
    double valueD, valueA; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double, 2, 1> derD, derA;
    point<double, 2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_disc_mesh0.dat");
    auto test_anal = std::make_shared < gnuplot_output_object < double > > ("testing_interface_fin_anal_mesh0.dat");
/*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for (size_t i = 0; i <= N; i++) {
        for (size_t j = 0; j <= M; j++) {
            double px = i * (1.0 / N);
            double py = j * (1.0 / M);
            node = point_type(px, py);
/*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
/*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
/*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node, valueD);
            test_anal->add_data(node, valueA);
/*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
/*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh, typename FonctionA>
void
test_new_method(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
    double valueD1, valueD2, valueA;

    auto pts = points(msh, cl);


    timecounter tc1;
    tc1.tic();
    for (auto &pt: pts) {
        valueD1 = level_set_disc(pt, msh, cl);
// valueA = level_set_anal(pt);
// valueD2 = level_set_disc(pt);
// std::cout<<"Differnce between two evaluation system "<<(valueD1-valueD2)<<std::endl;
//  std::cout<<"Im in test_new_method";
    }


    tc1.toc();
    std::cout << bold << yellow << "Time for the new evaluation: " << tc1 << " seconds" << reset << std::endl;

    tc1.tic();
    for (auto &pt: pts) {
        valueD2 = level_set_disc(pt);
//  std::cout<<"Im in test_new_method";
    }
    tc1.toc();
    std::cout << bold << yellow << "Time for the old evaluation: " << tc1 << " seconds" << reset << std::endl;

    tc1.tic();
    for (auto &pt: pts) {
        valueA = level_set_anal(pt);
    }
    tc1.toc();
    std::cout << bold << yellow << "Time for the analytic evaluation: " << tc1 << " seconds" << reset << std::endl;


}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh>
void
time_NEWdiscrete_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
    double valueD1; //, valueD2 ,valueA ;

    auto pts = points(msh, cl);


    for (auto &pt: pts) {
        valueD1 = level_set_disc(pt, msh, cl);

    }


}

// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh>
void
time_OLDdiscrete_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
    double valueD1; //, valueA ; // valueD2 ,

    auto pts = points(msh, cl);


    for (auto &pt: pts) {
        valueD1 = level_set_disc(pt);

    }


}

template<typename FonctionA, typename Mesh>
void
time_analytic_testing(const Mesh msh, const FonctionA &level_set_anal, const typename Mesh::cell_type &cl) {
//typedef typename Mesh::point_type       point_type;
    double valueA; // valueD1 , valueD2 ,

    auto pts = points(msh, cl);


    for (auto &pt: pts) {
        valueA = level_set_anal(pt);

    }


}


template<typename FonctionD, typename Mesh>
void
time_face_testing(const Mesh msh, const FonctionD &level_set_disc, const typename Mesh::face_type &fc) {

//typedef typename Mesh::point_type       point_type;
    double valueD1;// , valueD2 ,valueA ;

    auto pts = points(msh, fc);


    for (auto &pt: pts) {
        valueD1 = level_set_disc(pt, msh, fc);

    }


}

template<typename FonctionA, typename Mesh>
void
time_faceANALITIC_testing(const Mesh msh, const FonctionA &level_set_anal, const typename Mesh::face_type &fc) {

//typedef typename Mesh::point_type       point_type;
    double valueA; // valueD1 , valueD2 ,

    auto pts = points(msh, fc);


    for (auto &pt: pts) {
        valueA = level_set_anal(pt);

    }


}


// Qualitative testing of the discrete level set function wrt the analytical one
template<typename FonctionD, typename Mesh, typename FonctionA>
void
test_new_method(const Mesh msh, const FonctionD &level_set_disc, const FonctionA &level_set_anal,
                const typename Mesh::cell_type &cl, const typename Mesh::face_type &fc) {
//typedef typename Mesh::point_type       point_type;
    double valueD1, valueA, valueD3; //, valueD2

    auto pts = points(msh, fc);


    timecounter tc1;
    tc1.tic();
    for (auto &pt: pts) {
        valueD1 = level_set_disc(pt, msh, fc);
        valueA = level_set_anal(pt);
//valueD2 = level_set_disc(pt,msh,cl);
        valueD3 = level_set_disc(pt);

        std::cout << "Differnce between FACE and OLD evaluation system " << (valueD1 - valueD3) << std::endl;
        std::cout << "Error between analytic and face evaluation " << (valueD1 - valueA) << std::endl;
    }


}


template<typename Mesh, typename T>
class cell_basis_Lagrangian_ordered {
    typedef typename Mesh::coordinate_type coordinate_type;
    typedef typename Mesh::point_type point_type;

    point_type cell_bar;
    coordinate_type cell_h;
    size_t basis_degree, basis_size;
    std::vector <point<T, 2>> nodes;
    std::vector <size_t> row_indeces, col_indeces;

public:
    cell_basis_Lagrangian_ordered(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);
// nodes           = equidistriduted_nodes_ordered<T,Mesh>(msh, cl, degree);
        nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        basis_degree = degree;
        basis_size = (basis_degree + 1) * (basis_degree + 1);
        set_col_row_indeces();

    }

    void set_col_row_indeces() {
//std::cout<<"SONO QUA NEL SET INDECES "<<row_indeces.size()<<" and "<<col_indeces.size()<<std::endl;
// It could be cool to just save once and not call each time. To do that or call the  variable Static(?) or give it just as external fx and initiliaze once.
        if (row_indeces.size() == 0 && col_indeces.size() == 0) {
            row_indeces.push_back(0);
            row_indeces.push_back(1);
            col_indeces.push_back(0);
            col_indeces.push_back(3);
            for (size_t i = 0; i < basis_degree - 1; i++) {
                row_indeces.push_back(4 + i);
                col_indeces.push_back(3 * basis_degree + 1);
            }

        }
    }


/*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type &pt) {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_degree + 1);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_degree + 1);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);


/*
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<row_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<col_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        */
// the indeces of first row and column are already saved. Just need a loop over them and then do the right tensor product maintaining the ordering of the nodes.
        size_t ct = 0;
        for (auto &k: row_indeces) {
            T bk = 1;
            for (auto &j: row_indeces) {
                if (j != k) {
                    bk *= ((pt.x() - (nodes.at(j)).x()) / ((nodes.at(k)).x() - (nodes.at(j)).x()));
                }
            }

            retx(ct) = bk;
            ct++;
        }

        ct = 0;
        for (auto &l: col_indeces) {
            T bl = 1;
            for (auto &j: col_indeces) {
                if (j != l) {
                    bl *= ((pt.y() - (nodes.at(j)).y()) / ((nodes.at(l)).y() - (nodes.at(j)).y()));
                }
            }
            rety(ct) = bl;
            ct++;
        }



// VERTICES FUNCTIONS:
        if (basis_degree == 0) {
            ret(0) = rety(0) * retx(0);
            return ret;
        }


        ret(0) = rety(0) * retx(0);
        ret(1) = rety(0) * retx(1);
        ret(2) = rety(1) * retx(1);
        ret(3) = rety(1) * retx(0);

        if (basis_degree == 1)
            return ret;

        int count0 = 4, count1 = 4 + basis_degree - 1, count2 = 4 + 2 * (basis_degree - 1), count3 =
                4 + 3 * (basis_degree - 1);
        int count_bis0 = 4 * basis_degree; // counter initialisation (USELESS)
        int j_max = floor((basis_degree - 1) / 2); // number of internal layour of points
        int pos_right = 100; // initial point from the right from bottom -> up
        int pos_left = 100; // initial point from the left from left -> right

        for (int j = 0; j <= j_max; j++) { // for each layout of point
// bool i_loop = FALSE;
            for (int i = std::max(0, j - 1);
                 i < basis_degree - 1 - j; i++) // I move from left into the points over a side of each layout
            {
                if (i == std::max(0, j - 1) && j > 0) // vertices
                {
// different pos_left depending on the layout. Especially this rules the y starting point
                    if (j == 0)
                        pos_left = 0;
                    else if (j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2 + (j - 1);

// Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                    count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
//std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                    ret(count_bis0) = (retx(2 + i) * rety(pos_left)); // adding point bottom layout
                    count_bis0++;
                    if (j == 0)
                        pos_right = 1;
                    else
                        pos_right = basis_degree + 1 - j;

                    ret(count_bis0) = (retx(pos_right) * rety(2 + i)); // adding point right layout in count_bis0 pos.
                    count_bis0++;

                    ret(count_bis0) = (retx(basis_degree - i) *
                                       rety(pos_right)); // adding point top layout in count_bis0 pos.

                    count_bis0++;

                    ret(count_bis0) = (retx(pos_left) * rety(basis_degree - i));

                    count_bis0++;

// Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                    count0 = count_bis0;
                    count1 = count0 + std::ceil((basis_degree - 2.0 * j) / 2.0); //  count0 + (degree - 2); it was
                    count2 = count1 + std::ceil((basis_degree - 2.0 * j) / 2.0);
                    count3 = count2 + std::ceil((basis_degree - 2.0 * j) / 2.0);

                } else // NOT vertices -> node in the sides of each layout
                {
//   std::cout<<"i "<<i<<" j "<<j<<std::endl;
// vertical position where starting for each bottom side layout.
                    if (j == 0)
                        pos_left = 0;
                    else if (j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2 + (j - 1);

                    ret(count0) = (retx(2 + i) * rety(pos_left));
                    count0++;
// x-position where to start to increase to get points for each right side layout of points
                    if (j == 0)
                        pos_right = 1;
                    else
                        pos_right = basis_degree + 1 - j;

                    ret(count1) = (retx(pos_right) * rety(2 + i));
                    count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                    ret(count2) = (retx(basis_degree - i) * rety(pos_right));
                    count2++; // count2 just enumerate top faces' layout

                    ret(count3) = (retx(pos_left) * rety(basis_degree - i));
                    count3++; // count3 just enumerate left faces' layout


                }
            }
// Updating for the next layout.
            count0 = count3;
            count1 = count0 + (basis_degree - 2 * (j + 1));
            count2 = count1 + (basis_degree - 2 * (j + 1));
            count3 = count2 + (basis_degree - 2 * (j + 1));

        }

/// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
        if (basis_degree % 2 == 0)
            ret(count0) = (retx(basis_degree - floor((basis_degree - 1) / 2)) *
                           rety(basis_degree - floor((basis_degree - 1) / 2)));

        return ret;


    }


    Matrix<T, Dynamic, 2>
    eval_gradients(const point_type &pt) {
// Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


// for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

        for (size_t l = 0; l < basis_size; l++) {
            size_t col = l % (basis_degree + 1);
            T bl = 1.0, bl_der = 1.0;
            T sumy = 0.0;
            for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                T sumyy = 1.0;
                if (tmpy != l) {

                    bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));

                    bl_der *= (1.0 / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                    for (size_t jy = col; jy <= col + (basis_degree + 1) * basis_degree; jy += (basis_degree + 1)) {
                        if (jy != tmpy && jy != l) {
                            sumyy *= (pt.y() - (nodes.at(jy)).y());
                        }
                    }
                    sumy += sumyy;
                }
            }
            rety(l) = bl;
            sy(l) = bl_der * sumy;
        }

// For the x-derivative of b_k(x), same procedure of b_l(y)'

        for (size_t k = 0; k < basis_size; k++) {
            size_t row = floor(k / (basis_degree + 1));
            T bk = 1.0, bk_der = 1.0;
            T sumx = 0.0;
            for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                T sumxx = 1.0;

                if (tmpx != k) {

                    bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                    bk_der *= (1.0 / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                    for (size_t jx = (basis_degree + 1) * row; jx <= (basis_degree + 1) * (row + 1) - 1; jx++) {
                        if (jx != tmpx && jx != k) {
                            sumxx *= (pt.x() - (nodes.at(jx)).x());
                        }
                    }
                    sumx += sumxx;

                }
            }
            retx(k) = bk;
            sx(k) = bk_der * sumx;
        }

        for (size_t i = 0; i < basis_size; i++) {
            ret(i, 0) = rety(i) * sx(i);
            ret(i, 1) = retx(i) * sy(i);

        }
        return ret;

    }

    size_t size() const {
        return basis_size;
    }

    size_t degree() const {
        return basis_degree;
    }

    static size_t size(size_t degree) {
        return (degree + 1) * (degree + 1);
    }
};


int binomial_coeff_fx(int n, int k) {

    int C[n + 1][k + 1];
    int i, j;

// Caculate value of Binomial Coefficient
// in bottom up manner
    for (i = 0; i <= n; i++) {
        for (j = 0; j <= std::min(i, k); j++) {
// Base Cases
            if (j == 0 || j == i)
                C[i][j] = 1;

// Calculate value using previously
// stored values
            else
                C[i][j] = C[i - 1][j - 1] +
                          C[i - 1][j];
        }
    }

    return C[n][k];
}


template<typename Mesh, typename VT>
class cell_basis_Bernstein {
    typedef typename Mesh::coordinate_type coordinate_type;
    typedef typename Mesh::point_type point_type;

    point_type cell_bar;
    coordinate_type cell_h;
    size_t basis_degree, basis_size;
    coordinate_type min_x, max_x, min_y, max_y;
    coordinate_type scaling_x, scaling_y;

#ifdef
    POWER_CACHE
            std::vector<coordinate_type>
    power_cache,
    power_cache_bis;
    std::vector <size_t> binomial_coeff, binomial_coeff_bis;
#endif

public:
    cell_basis_Bernstein(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
        basis_degree = degree;
        basis_size = (basis_degree + 1) * (basis_degree + 1);
        min_x = points(msh, cl)[0].x();
        max_x = points(msh, cl)[1].x();
        min_y = points(msh, cl)[0].y();
        max_y = points(msh, cl)[2].y();
        scaling_x = 1.0 / (pow((max_x - min_x), basis_degree));
        scaling_y = 1.0 / (pow((max_y - min_y), basis_degree));

    }

    Matrix<VT, Dynamic, 1>
    eval_basis(const point_type &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

// Creation of the exponential terms
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
//if(i == 0)
//   binomial_coeff[0] = 1.0 ;
//else if(i == basis_degree)
//    binomial_coeff[basis_degree+1] = 1.0 ;
// else

            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);


            power_cache[2 * i] = binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

        }

#endif
        size_t pos = 0;

// Case degree FEM = 0
        if (basis_degree == 0) {
            VT one = 1.0;
            ret(pos++) = one;
        }
// Case degree FEM = 1 -> i.e. just vertices
// Cell ordering:
// 3 -- 2
// 0 -- 1

        else if (basis_degree == 1) {
            for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                if (pow_y == 0) // ordering from sx to dx 0->1
                {
                    for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                  coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
                    }
                } else { // ordering from dx to sx 2->3
                    for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                  coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                        ret(pos++) = bv;
                    }
                }
            }
        } else {
// case degree FEM >= 2
            int N = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree +
                                 1; // counting the number of layout of internal nodes: initially there are basis_degree +1 nodes

            while (internal_bases > 1) // if there is a deeper layout of nodes
            {
// Vertices nodes of a quadrangular cell. For each loop of internal_bases I add the vertice of "inner quadrangualar nodes" ( it's not properly true speaking of nodes, being a modal approach; better say the picks of the shape functions).
                for (int pow_y = starter; pow_y <= N; pow_y += (N - starter)) {

                    if (pow_y == starter) // if bottom line -> from sx to dx
                    {
// if not external layout of nodes ( vertices level ) -> I don't take extremes since internal layout has 2 nodes less.
                        for (int pow_x = starter; pow_x <= N; pow_x += (N - starter)) {
#ifdef
                            POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                      coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                            ret(pos++) = bv;
// std::cout<<"pos vertices bottom is "<<pos<<std::endl;
                        }
                    } else { // if top line -> from dx to sx
                        for (int pow_x = N; pow_x >= starter; pow_x -= (N - starter)) {
#ifdef
                            POWER_CACHE
                            auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y *
                                      coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                            ret(pos++) = bv;
// std::cout<<"pos vertices upper is "<<pos<<std::endl;
                        }

                    }

                }


// After the vertices elements, step by faces bases.

//size_t pos = 4;
// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N - 1; pow_x++) {
                    size_t pow_y = starter;
#ifdef
                    POWER_CACHE
                    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto bv =
                            scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                            iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                    ret(pos++) = bv;
//  std::cout<<"pos face 0 is "<<pos<<std::endl;
                }

// face 1 (RIGHT)
                for (size_t pow_y = starter + 1; pow_y <= N - 1; pow_y++) {
                    size_t pow_x = N;
#ifdef
                    POWER_CACHE
                    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto bv =
                            scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                            iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                    ret(pos++) = bv;
//   std::cout<<"pos face 1 is "<<pos<<std::endl;
                }

// face 2 (TOP)
                for (size_t pow_x = N - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N;
#ifdef
                    POWER_CACHE
                    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto bv =
                            scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                            iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                    ret(pos++) = bv;
//   std::cout<<"pos face 2 is "<<pos<<std::endl;
                }


// face 3 (LEFT)

                for (size_t pow_y = N - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
#ifdef
                    POWER_CACHE
                    auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto bv =
                            scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                            iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                    ret(pos++) = bv;
//   std::cout<<"pos face 3 is "<<pos<<std::endl;
                }

                N--; // for each layout of "nodes", I have un unknown less from right
                starter++; // for each layout of "nodes", I have un unknown less from left
                internal_bases -= 2; // each layout I have 2 nodes less than the previous

            }
// for B_k, with k even, odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//   std::cout<<"N is "<<N<< " and starter is "<<starter<<std::endl;
                assert(N == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;
#ifdef
                POWER_CACHE
                auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;

                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y *
                          iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif
                ret(pos++) = bv;
//  std::cout<<"pos %2 is "<<pos<<std::endl;
            }
        }
// std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;
    }

// Same approach of eval
    Matrix<VT, Dynamic, 2>
    eval_gradients(const point_type &pt) {
        Matrix<VT, Dynamic, 2> ret = Matrix<VT, Dynamic, 2>::Zero(basis_size, 2);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
        auto N = basis_degree - 1;
        auto coeff_dx = basis_degree / (max_x - min_x); // n/(b-a)
        auto coeff_dy = basis_degree / (max_y - min_y);
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (power_cache_bis.size() != (N + 1) * 2)
            power_cache_bis.resize((N + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

        if (binomial_coeff_bis.size() != (N + 1))
            binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
            power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            if (i < basis_degree) {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                power_cache_bis[2 * i] =
                        scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                power_cache_bis[2 * i + 1] =
                        scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0) {
            VT zero = 0.0;
            ret(pos, 0) = zero;
            ret(pos, 1) = zero;
            pos++;
        }
// Case FEM degree = 1
        else if (basis_degree == 1) {
            VT coeffx = 1.0 / (max_x - min_x);
            VT coeffy = 1.0 / (max_y - min_y);
//std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
            auto px = 0.0, py = 0.0;
            int j = 1; // useful for the sign of the derivative in y
// Pick just vertices
            for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                if (pow_y == 0) // bottom
                {
                    int i = 1;  // useful for the sign of the derivative in x
                    for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif


                        ret(pos, 0) = py * coeffx * pow(-1, i);
                        ret(pos, 1) = px * coeffy * pow(-1, j);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i++;
                    }

                } else {
                    int i = 2;
                    for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif

                        ret(pos, 0) = py * coeffx * pow(-1, i);
                        ret(pos, 1) = px * coeffy * pow(-1, j);
//  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i--;
                    }
                }
                j++;
            }

        } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree + 1;

            while (internal_bases > 1) // for each layour of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                    if (pow_y == starter) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative

#ifdef
                            POWER_CACHE
                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                            else
                                auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                            if (pow_y == 0)
                                auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                            else
                                auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos, 0) = dx * py;
                            ret(pos, 1) = px * dy;
                            pos++;


                        }
                    } else { // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {
                            VT ix_bis = pow_x - 1;
                            VT iy_bis = pow_y - 1;

#ifdef
                            POWER_CACHE
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
                            if (pow_x == 0)
                                auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                            else
                                auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                            if (pow_y == 0)
                                auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                            else
                                auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif

                            ret(pos, 0) = dx * py;
                            ret(pos, 1) = px * dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                    size_t pow_y = starter;

                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"j_x Face0 "<<j_x<<std::endl;
//std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
//std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
//std::cout<<"bx0 Face0 "<<bx0<<std::endl;
//std::cout<<"bx1 Face0 "<<bx1<<std::endl;


// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }

#endif

                    ret(pos, 0) = dx * py;
                    ret(pos, 1) = px * dy;
                    pos++;

                }

// face 1 (RIGHT)
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos, 0) = dx * py;
                    ret(pos, 1) = px * dy;
                    pos++;
                }

// face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos, 0) = dx * py;
                    ret(pos, 1) = px * dy;
                    pos++;
                }


// face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos, 0) = dx * py;
                    ret(pos, 1) = px * dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert(N_partial == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;
                VT ix_bis = pow_x - 1;
                VT iy_bis = pow_y - 1;

#ifdef
                POWER_CACHE
                auto px = power_cache[2 * pow_x];
                auto py = power_cache[2 * pow_y + 1];
                if (pow_x == 0)
                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                else if (pow_x == basis_degree)
                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                else
                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                if (pow_y == 0)
                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                else if (pow_y == basis_degree)
                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                else
                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

                size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;

                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0, dy = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }

                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                } else {
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                }


#endif

                ret(pos, 0) = dx * py;
                ret(pos, 1) = px * dy;
                pos++;
            }
        }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }


// Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_derivative_xy(const point_type &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
        auto N = basis_degree - 1;
        auto coeff_dx = basis_degree / (max_x - min_x); // n/(b-a)
        auto coeff_dy = basis_degree / (max_y - min_y);
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (power_cache_bis.size() != (N + 1) * 2)
            power_cache_bis.resize((N + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

        if (binomial_coeff_bis.size() != (N + 1))
            binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
            power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            if (i < basis_degree) {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                power_cache_bis[2 * i] =
                        scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                power_cache_bis[2 * i + 1] =
                        scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0) {
            VT zero = 0.0;
            ret(pos) = zero;

            pos++;
        }
// Case FEM degree = 1
        else if (basis_degree == 1) {
            VT coeffx = 1.0 / (max_x - min_x);
            VT coeffy = 1.0 / (max_y - min_y);
//std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
            auto px = 0.0, py = 0.0;
            int j = 1; // useful for the sign of the derivative in y
// Pick just vertices
            for (int pow_y = 0; pow_y <= basis_degree; pow_y += basis_degree) {
                if (pow_y == 0) // bottom
                {
                    int i = 1;  // useful for the sign of the derivative in x
                    for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);

                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif


                        ret(pos) = coeffy * pow(-1, j) * coeffx * pow(-1, i);
//ret(pos,1) = px * coeffy * pow(-1,j);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i++;
                    }

                } else {
                    int i = 2;
                    for (int pow_x = basis_degree; pow_x >= 0; pow_x -= basis_degree) {
#ifdef
                        POWER_CACHE
                        auto bv = scaling_x * power_cache[2 * pow_x] * scaling_y * power_cache[2 * pow_y + 1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
#endif

                        ret(pos) = coeffy * pow(-1, j) * coeffx * pow(-1, i);

//  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i--;
                    }
                }
                j++;
            }

        } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree + 1;

            while (internal_bases > 1) // for each layour of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                    if (pow_y == starter) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative

#ifdef
                            POWER_CACHE
                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                            else
                                auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                            if (pow_y == 0)
                                auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                            else
                                auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                            pos++;


                        }
                    } else { // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {
                            VT ix_bis = pow_x - 1;
                            VT iy_bis = pow_y - 1;

#ifdef
                            POWER_CACHE
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
                            if (pow_x == 0)
                                auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                            else
                                auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                            if (pow_y == 0)
                                auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                            else
                                auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif

                            ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                    size_t pow_y = starter;

                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"j_x Face0 "<<j_x<<std::endl;
//std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
//std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
//std::cout<<"bx0 Face0 "<<bx0<<std::endl;
//std::cout<<"bx1 Face0 "<<bx1<<std::endl;


// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }

#endif

                    ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                    pos++;

                }

// face 1 (RIGHT)
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                    pos++;
                }

// face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                    pos++;
                }


// face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x - 1;
                    VT iy_bis = pow_y - 1;

#ifdef
                    POWER_CACHE
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
                    if (pow_x == 0)
                        auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                    else
                        auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                    if (pow_y == 0)
                        auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                    else
                        auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert(N_partial == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;
                VT ix_bis = pow_x - 1;
                VT iy_bis = pow_y - 1;

#ifdef
                POWER_CACHE
                auto px = power_cache[2 * pow_x];
                auto py = power_cache[2 * pow_y + 1];
                if (pow_x == 0)
                    auto dx = -coeff_dx * power_cache_bis[2 * pow_x];
                else if (pow_x == basis_degree)
                    auto dx = coeff_dx * power_cache_bis[2 * ix_bis];
                else
                    auto dx = coeff_dx * (power_cache_bis[2 * ix_bis] - power_cache_bis[2 * pow_x]);

                if (pow_y == 0)
                    auto dy = -coeff_dy * power_cache_bis[2 * pow_y + 1];
                else if (pow_y == basis_degree)
                    auto dy = coeff_dy * power_cache_bis[2 * iy_bis + 1];
                else
                    auto dy = coeff_dy * (power_cache_bis[2 * iy_bis + 1] - power_cache_bis[2 * pow_y + 1]);
#else

//size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;

//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0, dy = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }

                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = -coeff_dy * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                } else {
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * (py_bis1 - py_bis0);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                }


#endif

                ret(pos) = dx * dy;
//ret(pos,1) = px*dy;
                pos++;
            }
        }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }


// Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_divergence(const point_type &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
        size_t N;
        if (basis_degree > 1)
            N = basis_degree - 2;
        else
            return ret;
        auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
        auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (power_cache_bis.size() != (N + 1) * 2)
            power_cache_bis.resize((N + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

        if (binomial_coeff_bis.size() != (N + 1))
            binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
            power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            if (i < basis_degree - 1) {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                power_cache_bis[2 * i] =
                        scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                power_cache_bis[2 * i + 1] =
                        scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0 || basis_degree == 1) {
            VT zero = 0.0;
            while (pos < basis_size) {
                ret(pos) = zero;
                pos++;
            }
        } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree + 1;

            while (internal_bases > 1) // for each layout of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                    if (pow_y == starter) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE
                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);

                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = dx * py + px * dy;
                            pos++;


                        }
                    } else { // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE

                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);


                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }


                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                            }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = dx * py + px * dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                    size_t pow_y = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py + px * dy;
                    pos++;


                }

// face 1 (RIGHT) size_t pow_x = N_partial;
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative

                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py + px * dy;
                    pos++;
                }

// face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py + px * dy;
                    pos++;
                }


// face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py + px * dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert(N_partial == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;

                VT ix_bis = pow_x - 1; // element i-1 for derivative
                VT iy_bis = pow_y - 1; // element i-1 for derivative
                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                POWER_CACHE


                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                auto px = power_cache[2 * pow_x];
                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                if (pow_x == 0)
                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                else if (pow_x == basis_degree)
                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                else if (pow_x == 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                else if (pow_x == basis_degree - 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                else
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                           power_cache_bis[2 * ix2_bis]);

                if (pow_y == 0)
                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                else if (pow_y == basis_degree)
                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                else if (pow_y == 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else if (pow_y == basis_degree - 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                VT dx = 0.0, dy = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - ix_bis;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                } else {
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    size_t j_x_bis2 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }


                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - iy_bis;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    size_t j_y_bis2 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                ret(pos) = dx * py + px * dy;
                pos++;


            }
        }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }

// Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_double_derivative_x(const point_type &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
        size_t N;
        if (basis_degree > 1)
            N = basis_degree - 2;
        else
            return ret;

        auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
        auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (power_cache_bis.size() != (N + 1) * 2)
            power_cache_bis.resize((N + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

        if (binomial_coeff_bis.size() != (N + 1))
            binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
            power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            if (i < basis_degree - 1) {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                power_cache_bis[2 * i] =
                        scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                power_cache_bis[2 * i + 1] =
                        scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0 || basis_degree == 1) {
            VT zero = 0.0;
            while (pos < basis_size) {
                ret(pos) = zero;
                pos++;
            }
        } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree + 1;

            while (internal_bases > 1) // for each layout of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                    if (pow_y == starter) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE
                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);

                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = dx * py; //+ px*dy;
                            pos++;


                        }
                    } else { // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE

                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);


                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }


                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                            }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = dx * py; // + px*dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                    size_t pow_y = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py; // + px*dy;
                    pos++;


                }

// face 1 (RIGHT) size_t pow_x = N_partial;
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative

                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py; // + px*dy;
                    pos++;
                }

// face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py; // + px*dy;
                    pos++;
                }


// face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = dx * py; // + px*dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert(N_partial == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;

                VT ix_bis = pow_x - 1; // element i-1 for derivative
                VT iy_bis = pow_y - 1; // element i-1 for derivative
                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                POWER_CACHE


                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                auto px = power_cache[2 * pow_x];
                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                if (pow_x == 0)
                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                else if (pow_x == basis_degree)
                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                else if (pow_x == 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                else if (pow_x == basis_degree - 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                else
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                           power_cache_bis[2 * ix2_bis]);

                if (pow_y == 0)
                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                else if (pow_y == basis_degree)
                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                else if (pow_y == 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else if (pow_y == basis_degree - 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
//size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
//auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree, pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

//auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                auto py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                VT dx = 0.0, dy = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - ix_bis;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                } else {
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    size_t j_x_bis2 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }


                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - iy_bis;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    size_t j_y_bis2 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                ret(pos) = dx * py; // + px*dy;
                pos++;


            }
        }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }

// Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_double_derivative_y(const point_type &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

        auto bx0 = pt.x() - min_x;
        auto bx1 = max_x - pt.x();
        auto by0 = pt.y() - min_y;
        auto by1 = max_y - pt.y();
//The stuff below should be in the constructor, but gradient is used less times than eval.
        size_t N;
        if (basis_degree > 1)
            N = basis_degree - 2;
        else
            return ret;
        auto coeff_d2x = basis_degree * (basis_degree - 1) / ((max_x - min_x) * (max_x - min_x));
        auto coeff_d2y = basis_degree * (basis_degree - 1) / ((max_y - min_y) * (max_y - min_y));
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0 / (pow(max_y - min_y, N));
//std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef
        POWER_CACHE
        if (power_cache.size() != (basis_degree + 1) * 2)
            power_cache.resize((basis_degree + 1) * 2);

        if (power_cache_bis.size() != (N + 1) * 2)
            power_cache_bis.resize((N + 1) * 2);

        if (binomial_coeff.size() != (basis_degree + 1))
            binomial_coeff.resize(basis_degree + 1);

        if (binomial_coeff_bis.size() != (N + 1))
            binomial_coeff_bis.resize(N + 1);

// Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
        for (size_t i = 0; i <= basis_degree; i++) {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx(basis_degree, i);
            power_cache[2 * i] = scaling_x * binomial_coeff[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j);
            power_cache[2 * i + 1] = scaling_y * binomial_coeff[i] * iexp_pow(by0, i) * iexp_pow(by1, j);

            if (i < basis_degree - 1) {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx(N, i);
                power_cache_bis[2 * i] =
                        scaling_x_bis * binomial_coeff_bis[i] * iexp_pow(bx0, i) * iexp_pow(bx1, j_bis);
                power_cache_bis[2 * i + 1] =
                        scaling_y_bis * binomial_coeff_bis[i] * iexp_pow(by0, i) * iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0 || basis_degree == 1) {
            VT zero = 0.0;
            while (pos < basis_size) {
                ret(pos) = zero;
                pos++;
            }
        } else {
// if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;
            int internal_bases = basis_degree + 1;

            while (internal_bases > 1) // for each layout of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial; pow_y += (N_partial - starter)) {

                    if (pow_y == starter) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE
                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);

                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);
//auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = px * dy;
                            pos++;


                        }
                    } else { // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x -= (N_partial - starter)) {

                            VT ix_bis = pow_x - 1; // element i-1 for derivative
                            VT iy_bis = pow_y - 1; // element i-1 for derivative
                            VT ix2_bis = pow_x - 2; // element i-2 for derivative
                            VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                            POWER_CACHE

                            std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                            auto px = power_cache[2 * pow_x];
                            auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if (pow_x == 0)
                                auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                            else if (pow_x == basis_degree)
                                auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                            else if (pow_x == 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                            else if (pow_x == basis_degree - 1)
                                auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                            else
                                auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                                       power_cache_bis[2 * ix2_bis]);


                            if (pow_y == 0)
                                auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                            else if (pow_y == basis_degree)
                                auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                            else if (pow_y == 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else if (pow_y == basis_degree - 1)
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                            else
                                auto dy = coeff_d2y *
                                          (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0, dy = 0.0;

                            if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                                auto px_bis0 =
                                        scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) *
                                               iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) *
                                               iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }


                            if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            } else {
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                                auto py_bis0 =
                                        scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) *
                                               iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) *
                                               iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                            }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;
                            ret(pos) = px * dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


// face 0 (BOTTOM)
                for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {
                    size_t pow_y = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;

                    if (pow_x == 0) {

//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }


                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = px * dy;
                    pos++;


                }

// face 1 (RIGHT) size_t pow_x = N_partial;
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1; pow_y++) {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative

                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = px * dy;
                    pos++;
                }

// face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1; pow_x--) {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE

                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

//DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif

//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = px * dy;
                    pos++;
                }


// face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1; pow_y--) {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x - 1; // element i-1 for derivative
                    VT iy_bis = pow_y - 1; // element i-1 for derivative
                    VT ix2_bis = pow_x - 2; // element i-2 for derivative
                    VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                    POWER_CACHE


                    std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                    auto px = power_cache[2 * pow_x];
                    auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;
                    if (pow_x == 0)
                        auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                    else if (pow_x == basis_degree)
                        auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                    else if (pow_x == 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                    else if (pow_x == basis_degree - 1)
                        auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                    else
                        auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                               power_cache_bis[2 * ix2_bis]);


                    if (pow_y == 0)
                        auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                    else if (pow_y == basis_degree)
                        auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                    else if (pow_y == 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else if (pow_y == basis_degree - 1)
                        auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                    else
                        auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                               power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                    size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                    auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                    auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                    VT dx = 0.0, dy = 0.0;


                    if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_x == basis_degree - 1) {

//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - ix_bis;
                        size_t j_x_bis1 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 =
                                scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                    } else {
                        size_t j_x_bis0 = N - pow_x;
                        size_t j_x_bis1 = N - ix_bis;
                        size_t j_x_bis2 = N - ix2_bis;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                        auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        auto px_bis2 =
                                scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                        dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_y_bis0 = N - iy_bis;
                        size_t j_y_bis1 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 =
                                scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    } else {
                        size_t j_y_bis0 = N - pow_y;
                        size_t j_y_bis1 = N - iy_bis;
                        size_t j_y_bis2 = N - iy2_bis;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                        auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        auto py_bis2 =
                                scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                        dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                    }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                    ret(pos) = px * dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

// for B_k, with k even, I.E. odd number of bases: there is a central one.
            if (basis_degree % 2 == 0) {
//  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert(N_partial == starter);
                size_t pow_x = starter;
                size_t pow_y = starter;

                VT ix_bis = pow_x - 1; // element i-1 for derivative
                VT iy_bis = pow_y - 1; // element i-1 for derivative
                VT ix2_bis = pow_x - 2; // element i-2 for derivative
                VT iy2_bis = pow_y - 2; // element i-2 for derivative

#ifdef
                POWER_CACHE


                std::cout << "Bernstein Gradient, basis >=2: POWER_CACHE" << std::endl;
                auto px = power_cache[2 * pow_x];
                auto py = power_cache[2 * pow_y + 1];
//std::cout<<"px POWER_CACHE "<<px<<std::endl;

                if (pow_x == 0)
                    auto dx = coeff_d2x * power_cache_bis[2 * pow_x];
                else if (pow_x == basis_degree)
                    auto dx = coeff_d2x * power_cache_bis[2 * ix2_bis];
                else if (pow_x == 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis]);
                else if (pow_x == basis_degree - 1)
                    auto dx = coeff_d2x * (power_cache_bis[2 * ix2_bis] - 2 * power_cache_bis[2 * ix_bis]);
                else
                    auto dx = coeff_d2x * (power_cache_bis[2 * pow_x] - 2 * power_cache_bis[2 * ix_bis] +
                                           power_cache_bis[2 * ix2_bis]);

                if (pow_y == 0)
                    auto dy = coeff_d2y * power_cache_bis[2 * pow_y + 1];
                else if (pow_y == basis_degree)
                    auto dy = coeff_d2y * power_cache_bis[2 * iy2_bis + 1];
                else if (pow_y == 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else if (pow_y == basis_degree - 1)
                    auto dy = coeff_d2y * (power_cache_bis[2 * iy2_bis + 1] - 2 * power_cache_bis[2 * iy_bis + 1]);
                else
                    auto dy = coeff_d2y * (power_cache_bis[2 * pow_y + 1] - 2 * power_cache_bis[2 * iy_bis + 1] +
                                           power_cache_bis[2 * iy2_bis + 1]);
//std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else
//std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                size_t j_x = basis_degree - pow_x;
//size_t j_y = basis_degree - pow_y;
//std::cout<<"j_x PRE "<<j_x<<std::endl;
                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
//auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
//std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
//std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
//std::cout<<"pow_x PRE "<<pow_x<<std::endl;
//std::cout<<"bx0 PRE "<<bx0<<std::endl;
//std::cout<<"bx1 PRE "<<bx1<<std::endl;

                auto px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
//auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
//std::cout<<"px PRE "<<px<<std::endl;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                VT dx = 0.0, dy = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = coeff_d2x * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_x == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - ix_bis;
                    size_t j_x_bis1 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_d2x * (px_bis1 - 2 * px_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                } else {
                    size_t j_x_bis0 = N - pow_x;
                    size_t j_x_bis1 = N - ix_bis;
                    size_t j_x_bis2 = N - ix2_bis;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto coeff_n_x_bis2 = binomial_coeff_fx(N, ix2_bis);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                    dx = coeff_d2x * (px_bis0 - 2 * px_bis1 + px_bis2);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }


                if (pow_y == 0) {
//std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
// auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = coeff_d2y * py_bis0;
//auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                } else if (pow_y == basis_degree) {
//std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * py_bis1;
//auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                } else if (pow_y == 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else if (pow_y == basis_degree - 1) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_y_bis0 = N - iy_bis;
                    size_t j_y_bis1 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_d2y * (py_bis1 - 2 * py_bis0);
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_y_bis0 = N - pow_y;
                    size_t j_y_bis1 = N - iy_bis;
                    size_t j_y_bis2 = N - iy2_bis;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N, pow_y);
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N, iy_bis);
                    auto coeff_n_y_bis2 = binomial_coeff_fx(N, iy2_bis);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                    dy = coeff_d2y * (py_bis0 - 2 * py_bis1 + py_bis2);

                }

#endif
//std::cout<<"pos "<<pos<<std::endl;
//std::cout<<"dx "<<dx<<std::endl;
//std::cout<<"dy "<<dy<<std::endl;
//std::cout<<"px "<<px<<std::endl;
//std::cout<<"py "<<py<<std::endl;

                ret(pos) = px * dy;
                pos++;


            }
        }

//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }

    size_t size() const {
        return basis_size;
    }

    size_t degree() const {
        return basis_degree;
    }

    static size_t size(size_t degree) {
        return (degree + 1) * (degree + 1);
    }
};


template<typename Mesh, typename VT>
class cell_basis_Bernstein_1d_reference {
    typedef typename Mesh::coordinate_type coordinate_type;
    typedef typename Mesh::point_type point_type;
    typedef typename Mesh::cell_type cell_type;

//point_type          cell_bar;
//coordinate_type     cell_h;
    size_t basis_degree, basis_size;
    coordinate_type min_x, max_x, min_y, max_y;
    coordinate_type scaling_x;
    std::vector <point<VT, 2>> physical_pts;
    cell_type m_cl;
    Mesh msh_orig;
    Mesh msh_agglo;

public:
    cell_basis_Bernstein_1d_reference(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
        basis_degree = degree;
        basis_size = (basis_degree + 1);
        auto ref_nodes = reference_nodes_ordered<VT>(degree);
        physical_pts = cl.user_data.interface;

        min_x = 0.0; // points(msh,cl)[0].x();
        max_x = 1.0; //points(msh,cl)[1].x();
        scaling_x = 1.0 / (pow((max_x - min_x), basis_degree));

        m_cl = cl;

    }


    Matrix<VT, Dynamic, 1>
    eval_basis_1d(const VT &pt) {

        size_t pos = 0;
        auto bx0 = pt - min_x;
        auto bx1 = max_x - pt;

        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);
        if (basis_degree == 0) { // Case degree FEM = 0
            VT one = 1.0;
            ret(pos++) = one;

        } else if (basis_degree == 1) {
            for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
                size_t j_x = basis_degree - pow_x;
                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);

                ret(pos++) = bv;


            }
        } else {
            int N = basis_degree;
            int starter = 0;
            for (int pow_x = starter; pow_x <= N; pow_x += (N - starter)) {

                size_t j_x = basis_degree - pow_x;
                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);

                ret(pos++) = bv;
// std::cout<<"pos vertices bottom is "<<pos<<std::endl;
            }

// face 0 (BOTTOM)
            for (size_t pow_x = starter + 1; pow_x <= N - 1; pow_x++) {

                size_t j_x = basis_degree - pow_x;


                auto coeff_n_x = binomial_coeff_fx(basis_degree, pow_x);
                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x);
                ret(pos++) = bv;
//  std::cout<<"pos face 0 is "<<pos<<std::endl;
            }
        }
// std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;
    }

    Matrix<VT, 2, 1>
    eval_basis_curv(const VT &pt, int r = 0) {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_basis_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = size_pts / basis_size;


        if (size_cls == 1) {

            ret(0) += basis(0) * physical_pts[0].x();
            ret(0) += basis(1) * physical_pts[basis_degree].x();
            ret(1) += basis(0) * physical_pts[0].y();
            ret(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1].x();
                ret(1) += basis(i) * physical_pts[i - 1].y();
            }
            return ret;
        } else {
            ret(0) += basis(0) * physical_pts[0 + r * basis_size].x();
            ret(0) += basis(1) * physical_pts[basis_degree + r * basis_size].x();
            ret(1) += basis(0) * physical_pts[0 + r * basis_size].y();
            ret(1) += basis(1) * physical_pts[basis_degree + r * basis_size].y();

            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1 + r * basis_size].x();
                ret(1) += basis(i) * physical_pts[i - 1 + r * basis_size].y();
            }

            return ret;
        }



//ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
//ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
//return ret ;

    }


// ANCORA DA DEFINIRE
    Matrix<VT, Dynamic, 1>
    eval_gradients_1d(const VT &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);
        auto bx0 = pt - min_x;
        auto bx1 = max_x - pt;
        auto N = basis_degree - 1;

        auto coeff_dx = basis_degree / (max_x - min_x);
        auto scaling_x_bis = 1.0 / (pow(max_x - min_x, N)); // 1/(b-a)^(n-1)
//std::cout<<"check = "<< 1.0 - 1.0/(pow(max_x - min_x,N) ) <<std::endl;

        size_t pos = 0;
// Case FEM degree = 0
        if (basis_degree == 0) {
            VT zero = 0.0;
            ret(pos) = zero;
            pos++;
        }
// Case FEM degree = 1
        else if (basis_degree == 1) {// Pick just vertices
            int i = 1;  // useful for the sign of the derivative in x
            VT coeffx = 1.0 / (max_x - min_x);


            for (int pow_x = 0; pow_x <= basis_degree; pow_x += basis_degree) {
                ret(pos) = coeffx * pow(-1, i);
//std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                pos++;
                i++;
            }

        } else {   // if degree FEM >= 2
//std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree;
            int starter = 0;

            for (int pow_x = starter; pow_x <= N_partial; pow_x += (N_partial - starter)) {
                VT ix_bis = pow_x - 1; // element i-1 for derivative

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);

                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }
                ret(pos) = dx;
                pos++;
            }

// face 0 (BOTTOM)
            for (size_t pow_x = starter + 1; pow_x <= N_partial - 1; pow_x++) {

                VT ix_bis = pow_x - 1;

// DERIVATIVES
//std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
//auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0;

                if (pow_x == 0) {
//std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0;
//auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                } else if (pow_x == basis_degree) {
//std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1;
//auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                } else {
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N, pow_x);
                    auto px_bis0 = coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N, ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * (px_bis1 - px_bis0);
//auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }


                ret(pos, 0) = dx;
                pos++;

            }


        }


//  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }


    Matrix<VT, 2, 1>
    eval_gradients_curv(const VT &pt, int r = 0) {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_gradients_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = size_pts / basis_size;


        if (size_cls == 1) {

            ret(0) += basis(0) * physical_pts[0].x();
            ret(0) += basis(1) * physical_pts[basis_degree].x();
            ret(1) += basis(0) * physical_pts[0].y();
            ret(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1].x();
                ret(1) += basis(i) * physical_pts[i - 1].y();
            }
            return ret;
        } else {
            ret(0) += basis(0) * physical_pts[0 + r * basis_size].x();
            ret(0) += basis(1) * physical_pts[basis_degree + r * basis_size].x();
            ret(1) += basis(0) * physical_pts[0 + r * basis_size].y();
            ret(1) += basis(1) * physical_pts[basis_degree + r * basis_size].y();

            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1 + r * basis_size].x();
                ret(1) += basis(i) * physical_pts[i - 1 + r * basis_size].y();
            }

            return ret;
        }



//ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
//ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
//return ret ;

    }


    size_t size() const {
        return basis_size;
    }

    size_t degree() const {
        return basis_degree;
    }

    static size_t size(size_t degree) {
        return (degree + 1);
    }
};


template<typename Mesh, typename VT>
class cell_basis_Lagrange_1d_reference {
    typedef typename Mesh::coordinate_type coordinate_type;
    typedef typename Mesh::point_type point_type;
    typedef typename Mesh::cell_type cell_type;

//point_type          cell_bar;
//coordinate_type     cell_h;
    size_t basis_degree, basis_size;
    coordinate_type min_x, max_x, min_y, max_y;
    coordinate_type scaling_x;
    std::vector <point<VT, 2>> physical_pts;
    std::vector <point<VT, 1>> ref_nodes;
    cell_type m_cl;
    Mesh msh_orig;
    Mesh msh_agglo;

public:
    cell_basis_Lagrange_1d_reference(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
        basis_degree = degree;
        basis_size = (basis_degree + 1);

        ref_nodes = reference_nodes_ordered_01<VT>(degree); //[0,1]
//ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
        physical_pts = cl.user_data.interface;

//min_x = 0.0 ; // points(msh,cl)[0].x();
//max_x = 1.0 ; //points(msh,cl)[1].x();
//scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );

        m_cl = cl;

    }

    cell_basis_Lagrange_1d_reference(size_t degree) {
//cell_bar        = barycenter(msh, cl);
//cell_h          = diameter(msh, cl);
        basis_degree = degree;
        basis_size = (basis_degree + 1);

        ref_nodes = reference_nodes_ordered_01<VT>(degree); //[0,1]
//ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
//physical_pts = cl.user_data.interface ;

//min_x = 0.0 ; // points(msh,cl)[0].x();
//max_x = 1.0 ; //points(msh,cl)[1].x();
//scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );

//m_cl = cl ;

    }


    Matrix<VT, Dynamic, 1>
    eval_basis_1d(const VT &pt) {

        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);


        for (size_t k = 0; k < basis_size; k++) {
            VT bk = 1;
            for (size_t j = 0; j < basis_size; j++) {
                if (j != k) {
                    bk *= ((pt - ref_nodes.at(j).x()) / (ref_nodes.at(k).x() - ref_nodes.at(j).x()));
//std::cout<<"ref_nodes.at(j).x() = " << ref_nodes.at(j).x() << " , ref_nodes.at(k).x() = "<<ref_nodes.at(k).x()<<std::endl;
                }
            }

            ret(k) = bk;

        }


        return ret;
    }

/*
    Matrix<VT, 2, 1>
    eval_basis_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_basis_1d(pt) ;

        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;


        if (size_cls == 1){

            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();

            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }

        return ret;
        }



        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
    */

// ANCORA DA DEFINIRE
    Matrix<VT, Dynamic, 1>
    eval_gradients_1d(const VT &pt) {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);


        for (size_t k = 0; k < basis_size; k++) {
            VT bk_der = 1.0;
            VT sumx = 0.0;
            for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                VT sumxx = 1.0;

                if (tmpx != k) {


                    bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                    for (size_t jx = 0; jx < basis_size; jx++) {
                        if (jx != tmpx && jx != k) {
                            sumxx *= (pt - ref_nodes.at(jx).x());
                        }
                    }
                    sumx += sumxx;

                }
            }

            ret(k) = bk_der * sumx;
        }


        return ret;


    }


    Matrix<VT, Dynamic, 1>
    eval_double_derivative_1d(const VT &pt) {

        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

        if (basis_degree == 0)
            exit(9);
        if (basis_degree == 1)
            return ret;
        if (basis_degree == 2) {
            for (size_t k = 0; k < basis_size; k++) {
                VT bk_der = 1.0;
                for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                    if (tmpx != k)
                        bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));

                }

                ret(k) = bk_der * 2.0;
            }

            return ret;
        }
        if (basis_degree == 3) {
            for (size_t k = 0; k < basis_size; k++) {
                VT bk_der = 1.0;
                VT b_tot = 0.0;
                for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                    VT b = 1.0;

                    if (tmpx != k) {


                        bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                        size_t jx = tmpx;
                        bool inserted = false;
                        while (!inserted) {
                            if (jx != k) {
                                b *= (pt - ref_nodes.at(jx).x());
                                inserted = true;
                            }

                            jx++;

                        }
                        b_tot += 2.0 * b;

                    }

                }

                ret(k) = bk_der * b_tot;

            }
            return ret;
        }


        if (basis_degree ==
            4) { // In the generic case it doesn't work since amount is fine for just (x-xj)*(x-xl), with l>j, but iif I have more than two terms it need somehting more general

            for (size_t k = 0; k < basis_size; k++) // basis k
            {
                VT bk_der = 1.0;
                VT b_tot = 0.0;
                size_t pos = 0; // iter
                for (size_t amount = 0; amount < basis_degree - 1; amount++) {
                    if (pos == k)
                        pos++;

                    size_t jx = pos;
// starting from amount k = 0  num counts how many terms have (x-x1)*(), how many(x-x2)*() etc --> pos defines the term
// For k generic, it always starts from pos=0(at least that k=0) and just skip pos=k
                    for (size_t num = basis_degree - 1 - amount; num > 0; num--) {
                        VT b = (pt - ref_nodes.at(pos).x());
                        size_t m = 0;

                        while (m != basis_degree - 3) {
                            if (jx != k && jx != pos) {
                                b *= (pt - ref_nodes.at(jx).x());
                                m++;
                            }

                            jx++;
                        }
                        b_tot += 2.0 * b;
                    }
                    pos++;
                }

                for (size_t tmpx = 0; tmpx < basis_size; tmpx++) {
                    if (tmpx != k)
                        bk_der *= (1.0 / (ref_nodes.at(k).x() - ref_nodes.at(tmpx).x()));
                }


                ret(k) = bk_der * b_tot;

            }

            return ret;
        }
    }


/*
       Matrix<VT, 2, 1>
    eval_gradients_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_gradients_1d(pt) ;

        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;


        if (size_cls == 1){

            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();

            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }

            return ret;
        }



        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
     */

    size_t size() const {
        return basis_size;
    }

    size_t degree() const {
        return basis_degree;
    }

    static size_t size(size_t degree) {
        return (degree + 1);
    }
};


template<typename Mesh, typename T>
class cell_basis_Lagrangian {
    typedef typename Mesh::coordinate_type coordinate_type;
    typedef typename Mesh::point_type point_type;

    point_type cell_bar;
    coordinate_type cell_h;
    size_t basis_degree, basis_size;
    std::vector <point<T, 2>> nodes;
//std::vector<size_t>         indeces;

public:
    cell_basis_Lagrangian(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree) {
        nodes = equidistriduted_nodes<T, Mesh>(msh, cl, degree);
//nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);

        basis_degree = degree;
        basis_size = (basis_degree + 1) * (basis_degree + 1);
    }

/*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type &pt) {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);

// Per la y, trovo la colonna facendo col = l%(degree+1)
// scorro su tutta la colonna tmpy = [col:(degree+1): col+(degree+1)*degree]
// faccio base bl moltiplicando tutti tranne quando tmpy = l
        for (size_t l = 0; l < basis_size; l++) {
            size_t col = l % (basis_degree + 1);
            T bl = 1.0;
            for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                if (tmpy != l) {
                    bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                }
            }
            rety(l) = bl;
        }

// Per la x, trovo la riga facendo riga = floor(k/(degree+1))
//scorro su tutta la riga tmpx = [(degree+1)*riga: (degree+1)*(riga+1)-1]
// faccio base bk moltiplicando tutti tranne quando tmpx = k

        for (size_t k = 0; k < basis_size; k++) {
            T bk = 1.0;
            size_t row = floor(k / (basis_degree + 1));
            for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                if (tmpx != k) {
                    bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                }
            }
            retx(k) = bk;
        }

        for (size_t i = 0; i < basis_size; i++) {
            ret(i) = rety(i) * retx(i);
        }
        return ret;

    }

    Matrix<T, Dynamic, 2>
    eval_gradients(const point_type &pt) {
// Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


// for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

        for (size_t l = 0; l < basis_size; l++) {
            size_t col = l % (basis_degree + 1);
            T bl = 1.0, bl_der = 1.0;
            T sumy = 0.0;
            for (size_t tmpy = col; tmpy <= col + (basis_degree + 1) * basis_degree; tmpy += (basis_degree + 1)) {
                T sumyy = 1.0;
                if (tmpy != l) {

                    bl *= ((pt.y() - (nodes.at(tmpy)).y()) / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));

                    bl_der *= (1.0 / ((nodes.at(l)).y() - (nodes.at(tmpy)).y()));
                    for (size_t jy = col; jy <= col + (basis_degree + 1) * basis_degree; jy += (basis_degree + 1)) {
                        if (jy != tmpy && jy != l) {
                            sumyy *= (pt.y() - (nodes.at(jy)).y());
                        }
                    }
                    sumy += sumyy;
                }
            }
            rety(l) = bl;
            sy(l) = bl_der * sumy;
        }

// For the x-derivative of b_k(x), same procedure of b_l(y)'

        for (size_t k = 0; k < basis_size; k++) {
            size_t row = floor(k / (basis_degree + 1));
            T bk = 1.0, bk_der = 1.0;
            T sumx = 0.0;
            for (size_t tmpx = (basis_degree + 1) * row; tmpx <= (basis_degree + 1) * (row + 1) - 1; tmpx++) {
                T sumxx = 1.0;

                if (tmpx != k) {

                    bk *= ((pt.x() - (nodes.at(tmpx)).x()) / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                    bk_der *= (1.0 / ((nodes.at(k)).x() - (nodes.at(tmpx)).x()));
                    for (size_t jx = (basis_degree + 1) * row; jx <= (basis_degree + 1) * (row + 1) - 1; jx++) {
                        if (jx != tmpx && jx != k) {
                            sumxx *= (pt.x() - (nodes.at(jx)).x());
                        }
                    }
                    sumx += sumxx;

                }
            }
            retx(k) = bk;
            sx(k) = bk_der * sumx;
        }

        for (size_t i = 0; i < basis_size; i++) {
            ret(i, 0) = rety(i) * sx(i);
            ret(i, 1) = retx(i) * sy(i);

        }
        return ret;

    }

    size_t size() const {
        return basis_size;
    }

    size_t degree() const {
        return basis_degree;
    }

    static size_t size(size_t degree) {
        return (degree + 1) * (degree + 1);
    }
};

/*
template<typename Mesh, typename T >
class cell_basis_Raviart_Thomas
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;
    //std::vector<size_t>         indeces;
    Matrix<T, Dynamic, 1> P_k , P_km1_k , P_k_km1 ;
    std::vector<point<T,1> > nodes_1d ;

public:

    cell_basis_Raviart_Thomas(const Mesh& msh, size_t degree)
    {
        //nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);

        basis_degree    = degree;
        basis_size      = 2*(basis_degree+1)*(basis_degree+2);
        P_k             = Matrix<T, Dynamic, 1>::Ones(basis_degree+1);
        P_km1_k         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        P_k_km1         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        nodes_1d        = reference_nodes_ordered<T>(degree);

        for(size_t fc_i = 0 ; fc_i < 4 ; fc_i++) // for each face of a quadrangular square
        {
            for(size_t i = 1 ; i < nodes_1d.size() ; i++) // for each polynomial defined over a face
            {

                auto nd = nodes_1d[i]  ;

                P_k(i) = nd[i]*P_k(i-1); // non va bene devo fare una base cosi
                if(fc_i == 0) // the normal is (0,-1)
                {

                }

               if(fc_i == 1) // the normal is (1,0)
                {

                }

                if(fc_i == 2) // the normal is (0,1)
                {

                }

                if(fc_i == 3) // the normal is (-1,0)
                {

                }

            }

        }



    }

    cell_basis_Raviart_Thomas(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);

        basis_degree    = degree;
        basis_size      = 2*(basis_degree+1)*(basis_degree+2);
        P_k             = Matrix<T, Dynamic, 1>::Zero(basis_degree+1);
        P_km1_k         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        P_k_km1         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));

        for(auto&fc : faces(msh, cl))
        {
            for(size_t i = 0 ; i < basis_degree+1 ; i++)
            {

            }

        }



    }


    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);

        // Per la y, trovo la colonna facendo col = l%(degree+1)
        // scorro su tutta la colonna tmpy = [col:(degree+1): col+(degree+1)*degree]
        // faccio base bl moltiplicando tutti tranne quando tmpy = l
        for ( size_t l = 0; l < basis_size ; l++ )
        {
            size_t col = l%(basis_degree+1);
            T bl = 1.0;
            for (size_t tmpy = col; tmpy <= col+(basis_degree+1)*basis_degree; tmpy+=(basis_degree+1))
            {
                if (tmpy!=l)
                {
                    bl *= ( ( pt.y() - (nodes.at(tmpy)).y() )/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );
                }
            }
            rety(l) = bl;
        }

        // Per la x, trovo la riga facendo riga = floor(k/(degree+1))
        //scorro su tutta la riga tmpx = [(degree+1)*riga: (degree+1)*(riga+1)-1]
        // faccio base bk moltiplicando tutti tranne quando tmpx = k

        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            T bk = 1.0;
            size_t row=floor( k/(basis_degree+1) );
            for (size_t tmpx = (basis_degree+1)*row; tmpx <= (basis_degree+1)*(row+1)-1; tmpx++)
            {
                if (tmpx!=k) {
                    bk *= ( ( pt.x() - (nodes.at(tmpx)).x() )/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                }
            }
            retx(k) = bk;
        }

        for (size_t i = 0; i<basis_size; i++)
        {
            ret(i) = rety(i)*retx(i);
        }
        return ret;

    }



    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return 2*(degree+1)*(degree+2);
    }
};

template<typename Mesh, typename T >
class P_k_basis
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;



public:

    P_k_basis(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        // nodes I do not know it is useful!
        nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);
        basis_degree    = degree;
        basis_size      = (basis_degree+1);



    }

    Matrix<T, Dynamic, 2>
    eval_basis(const point_type& pt)
    {

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Ones(basis_size,2);

        // Column 0 is the x P^k basis ; column 1 is the y P^k basis
        for ( size_t i = 1; i < basis_size ; i++ )
        {
            // Before it should be moved into the correct cell
            ret(i,0) = pt.x()*ret(i-1);
            ret(i,1) = pt.y()*ret(i-1);


        }


        return ret;

    }

};

template<typename Mesh, typename T >
class P_k_l_basis
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree_x,basis_degree_y, basis_size;
    std::vector<point<T, 2> >          nodes_x , nodes_y ;


public:

    P_k_l_basis(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree_k ,size_t degree_l )
    {
        // nodes I do not know it is useful!
        nodes_x           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_k);
        nodes_y           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_l);
        basis_degree_x    = degree_k;
        basis_degree_y    = degree_l;
        basis_size      = (basis_degree_x+1)*(basis_degree_y+1);



    }

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {

        Matrix<T, Dynamic, 1> ret_x = Matrix<T, Dynamic, 1>::Ones(basis_degree_x);
        Matrix<T, Dynamic, 1> ret_y = Matrix<T, Dynamic, 1>::Ones(basis_degree_y);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Ones(basis_size);


        // Column 0 is the x P^k basis ; column 1 is the y P^k basis
        size_t count = 1; // ATTENCTION IF THE FIRST ELEMENT IS NOT 1 (cell mapping)
        for ( size_t i = 1; i < basis_degree_x ; i++ )
        {
            // Before it should be moved into the correct cell
            ret_x(i) = pt.x()*ret_x(i-1);
            for ( size_t j = 1; j< basis_degree_y ; j++ )
            {
                // Before it should be moved into the correct cell
                ret_y(j) = pt.y()*ret_y(j-1);
                ret(count) = ret_x(i)*ret_y(j) ;
                count++;
            }

        }


        // ALTERNATIVA: CHIAMARE DIRETTAMENTE LA CLASSE Pk
        //EX:
        //auto p_k =  P_k_basis(msh, cl,  degree_k) ;
        //auto p_l =  P_k_basis(msh, cl,  degree_l) ;

         //size_t count = 0;
         //for ( size_t i = 1; i < basis_degree_x ; i++ )
         //{
         //    for ( size_t j = 1; j< basis_degree_y ; j++ )
         //    {
          //       ret(count) = p_k(i)*p_l(j) ;
          //       count++;
          //   }

        // }
// }



        return ret;

    }

};

*/


template<typename T>
std::vector <point<T, 1>>
reference_nodes(size_t degree) {
    auto comp_degree = degree + 1;

    size_t reqd_nodes = comp_degree;

    std::vector <point<T, 1>> ret;
    ret.reserve(reqd_nodes);

    point<T, 1> qp;
    T a1, a2;
    T delta_x;
    switch (reqd_nodes) {
        case 1:
            qp = point<T, 1>({
                                     0.0
                             });
            ret.push_back(qp);
            return ret;

        case 2:
            qp = point<T, 1>({
                                     1.0
                             });
            ret.push_back(-qp);
            ret.push_back(qp);
            return ret;

        case 3:
            qp = point<T, 1>({
                                     1.0
                             });
            ret.push_back(-qp);
            ret.push_back(qp);
            qp = point<T, 1>({0.0});
            ret.push_back(qp);
            return ret;

        case 4:
            a1 = 1.0 / 3.0;
            qp = point<T, 1>({1.0});
            ret.push_back(-qp);
            ret.push_back(qp);
            qp = point<T, 1>({a1});
            ret.push_back(-qp);
            ret.push_back(qp);
            return ret;

        case 5:
// Be carefull in what order data is inserted in ret!
// In Gauss Legendre the first one was 0.0, now is the last one
            a2 = 0.5;
            a1 = 1.0;
            qp = point<T, 1>({a1});
            ret.push_back(-qp);
            ret.push_back(qp);

            qp = point<T, 1>({a2});
            ret.push_back(-qp);
            ret.push_back(qp);

            qp = point<T, 1>({0.0});
            ret.push_back(qp);

            return ret;

        default:

            delta_x = 1.0 / degree;
            a1 = 1.0;
            while (a1 > 0) {
                qp = point<T, 1>({
                                         a1
                                 });
                ret.push_back(-qp);
                ret.push_back(qp);
                a1 -= delta_x;

            }
            if (a1 == 0) {
                qp = point<T, 1>({
                                         0.0
                                 });
                ret.push_back(qp);
            }
            return ret;
    }

    return ret;
}

template<typename T, typename Mesh>
std::vector <point<T, 2>>
equidistriduted_nodes(const Mesh &msh,
                      const typename Mesh::cell_type &cl,
                      size_t degree) {
    typedef typename Mesh::point_type point_type;

    auto qps = reference_nodes<T>(degree);


    auto pts = points(msh, cl);

    auto v0 = pts[1] - pts[0];
    auto v1 = pts[2] - pts[1];
    auto v2 = pts[3] - pts[2];
    auto v3 = pts[3] - pts[0];

    std::vector <point<T, 2>> ret;

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].x() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].x() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].x() * (1 - xi) * (1 + eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].y() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].y() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].y() * (1 - xi) * (1 + eta);
    };

    for (auto jtor = qps.begin(); jtor != qps.end(); jtor++) {
        for (auto itor = qps.begin(); itor != qps.end(); itor++) {
            auto qp_x = *itor;
            auto qp_y = *jtor;

            auto xi = qp_x.x();
            auto eta = qp_y.x();

            auto px = P(xi, eta);
            auto py = Q(xi, eta);

            ret.push_back(point_type(px, py));
        }
    }

    return ret;
}


// Qualitative testing of the discrete level set function wrt the analytical one
template<typename Fonction, typename Mesh>
void
testing_velocity_field_L2projected(const Mesh msh, const Fonction &vel) {
//typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;

    auto test_discx = std::make_shared < gnuplot_output_object < double > > ("L2vel_HHOX.dat");
    auto test_discy = std::make_shared < gnuplot_output_object < double > > ("L2vel_HHOY.dat");


    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
        for (auto &pt: pts) {
            auto value = vel(pt, msh, cl);
            test_discx->add_data(pt, value.first);
            test_discy->add_data(pt, value.second);


        }
    }

    postoutput1.add_object(test_discx);
    postoutput1.add_object(test_discy);


    postoutput1.write();

}

template<typename Fonction, typename Mesh>
void
testing_velocity_field(const Mesh msh, const Fonction &vel) {

    std::string filename_interface_Stokes = "vel_lagrange_disc.3D";

    std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;


    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
        for (auto &pt: pts) {
            auto value = vel(pt, msh, cl);
            interface_file << pt.x() << "   " << pt.y() << "   " << value.first << "   " << value.second << std::endl;


        }
    }

    interface_file.close();

}


template<typename Fonction, typename Mesh>
void
testing_velocity_field(const Mesh &msh, const Fonction &vel, size_t time_step, std::string &folder) {

    std::string filename_stokes6 = folder + "velocity_field_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file(filename_stokes6, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;


    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<double, Mesh>(msh, cl, vel.degree_FEM);
        for (auto &pt: pts) {
            auto value = vel(pt, msh, cl);
            interface_file << pt.x() << "   " << pt.y() << "   " << value.first << "   " << value.second << std::endl;


        }
    }

    interface_file.close();

}

template<typename FonctionD, typename Mesh, typename T>
void
testing_level_set_time(Mesh &msh, const FonctionD &level_set_disc, T time, size_t time_step, std::string &folder) {
    typedef typename Mesh::point_type point_type;


    postprocess_output <T> postoutput0;
    std::string filename_FEM = folder + "sol_FEM_t=" + std::to_string(time_step) + ".dat";
    auto test_FEM = std::make_shared < gnuplot_output_object < double > > (filename_FEM);



// CHECK MAX AND MIN
    T ret0 = -10.0;
    T ret1 = 10.0;
    for (auto &cl: msh.cells) {
        auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, level_set_disc.degree_FEM);

        for (auto &nd: nodes) {
            auto new_ret = level_set_disc(nd, msh, cl);
            test_FEM->add_data(nd, new_ret);
            ret0 = std::max(new_ret, ret0);
            ret1 = std::min(new_ret, ret1);
        }


    }

    postoutput0.add_object(test_FEM);
    postoutput0.write();

    std::cout << "At initial time: min(phi) = " << level_set_disc.phi_min << ", max(phi) = " << level_set_disc.phi_max
              << std::endl;

    std::cout << "At time t = " << time << ": min(phi) = " << ret1 << ", max(phi) = " << ret0 << std::endl;

}

template<typename Mesh, typename Level_Set, typename Velocity, typename T = typename Mesh::coordinate_type>
void
plot_u_n_interface(Mesh &msh_i, Level_Set &ls_cell, Velocity &u_projected, size_t time_step, std::string &folder) {


    std::vector <T> val_u_n_fin; //val_u_nx_fin , val_u_ny_fin ;
    std::vector <point<T, 2>> interface_points_plot_fin;
    std::vector <std::pair<T, T>> vec_n; // , velocity_interface , velocity_field , points_vel_field;



    for (auto &cl: msh_i.cells) {


        if (cl.user_data.location == element_location::ON_INTERFACE) {

            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            for (auto interface_point = cl.user_data.interface.begin();
                 interface_point < cl.user_data.interface.end(); interface_point++) {
                Eigen::Matrix<T, 2, 1> normal_cont_grad = ls_cell.normal(*interface_point);
                std::pair <T, T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0), normal_cont_grad(1));

                vec_n.push_back(normal_vec_grad_cont);

                auto u_pt = u_projected(*(interface_point));
                auto ls_n_pt = ls_cell.normal(*(interface_point));

                T u_n_0 = u_pt.first * ls_n_pt(0);
                T u_n_1 = u_pt.second * ls_n_pt(1);

                interface_points_plot_fin.push_back(*(interface_point));

                val_u_n_fin.push_back(u_n_0 + u_n_1);


            }


        }


    }


    goal_quantities_time_fast(msh_i, interface_points_plot_fin, val_u_n_fin, vec_n, time_step, folder);


}


template<typename FonctionD, typename Mesh, typename T>
void
testing_level_set_max_min(const Mesh &msh, const FonctionD &level_set_disc, size_t time_step,
                          std::vector <std::pair<T, T>> &min_max_vec) {

// CHECK MAX AND MIN
    T ret0 = -10.0;
    T ret1 = 10.0;


    for (auto &cl: msh.cells) {

        auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, level_set_disc.degree_FEM);

        for (auto &nd: nodes) {
            auto new_ret = level_set_disc(nd, msh, cl);
            ret0 = std::max(new_ret, ret0);
            ret1 = std::min(new_ret, ret1);
        }


    }

    min_max_vec.push_back(std::make_pair(ret1, ret0));

//std::cout<<"Initial time: MIN(phi) = "<<level_set_disc.phi_min<<", MAX(phi) = "<<level_set_disc.phi_max<< std::endl;
//std::cout<<"At time t = "<<time<<": MIN(phi) = "<<ret1<<" , MAX(phi) = "<<ret0<< std::endl;

}


/*
template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes_subcell(const Mesh& msh,
          const typename Mesh::cell_type& cl,
          size_t degree, const std::vector<size_t>& indeces)
{
    typedef typename Mesh::point_type    point_type;

    auto qps = reference_nodes<T>(degree);

    std::vector<typename Mesh::point_type> pts;
    auto all_points = points(msh, cl);
    for (size_t i = 0 ; i < 4 ; i++) {
        pts.push_back( all_points[indeces[i]] );
    }

    auto v0 = pts[1] - pts[0];
    auto v1 = pts[2] - pts[1];
    auto v2 = pts[3] - pts[2];
    auto v3 = pts[3] - pts[0];

    std::vector< point<T,2> > ret;

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1-xi)*(1-eta) +
               0.25 * pts[1].x() * (1+xi)*(1-eta) +
               0.25 * pts[2].x() * (1+xi)*(1+eta) +
               0.25 * pts[3].x() * (1-xi)*(1+eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1-xi)*(1-eta) +
               0.25 * pts[1].y() * (1+xi)*(1-eta) +
               0.25 * pts[2].y() * (1+xi)*(1+eta) +
               0.25 * pts[3].y() * (1-xi)*(1+eta);
    };

    for (auto jtor = qps.begin(); jtor != qps.end(); jtor++)
    {
        for (auto itor = qps.begin(); itor != qps.end(); itor++)
        {
            auto qp_x = *itor;
            auto qp_y = *jtor;

            auto xi = qp_x.x();
            auto eta = qp_y.x();

            auto px = P(xi, eta);
            auto py = Q(xi, eta);

            ret.push_back( point_type(px, py) );
        }
    }

    return ret;
}

*/

/*

template<typename T , typename Mesh>
size_t
cells_counter(const Mesh& msh , const typename Mesh::cell_type& cl)
{

}
*/


/*
// OLD VERSION OF pt_in_cell
template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl)
{
    bool ret = 0;
    auto pts =points(msh,cl);
    for (size_t i = 0; i < pts.size(); i++)
    {
        if( pts[i].x()>=point_to_find.x() && pts[i].y()>=point_to_find.y() )
            ret = 1;
    }
    return ret;

}
*/
template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &cl) {
    auto pts = points(msh, cl);

//std::cout<<"Point to find "<<std::setprecision(15)<<point_to_find.x()<<", "<<point_to_find.y()<<std::endl;

// std::cout<<"Min x "<<std::setprecision(15)<<pts[0].x()<<", max x "<<pts[1].x()<<std::endl;

//std::cout<<"Min y "<<std::setprecision(15)<<pts[1].y()<<", max y "<<pts[2].y()<<std::endl;

    T epsilon = 1e-10;
    if ((pts[0].x() - epsilon) <= point_to_find.x() && (pts[1].x() + epsilon) >= point_to_find.x() &&
        (pts[1].y() - epsilon) <= point_to_find.y() && (pts[2].y() + epsilon) >= point_to_find.y())
        return TRUE;
    else
        return FALSE;

}

template<typename T, typename Mesh>
bool
pt_in_cell_approximated(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &cl) {
    auto pts = points(msh, cl);

//std::cout<<"Point to find "<<std::setprecision(15)<<point_to_find.x()<<", "<<point_to_find.y()<<std::endl;

// std::cout<<"Min x "<<std::setprecision(15)<<pts[0].x()<<", max x "<<pts[1].x()<<std::endl;

//std::cout<<"Min y "<<std::setprecision(15)<<pts[1].y()<<", max y "<<pts[2].y()<<std::endl;

    T epsilon = 1e-3;
    if ((pts[0].x() - epsilon) <= point_to_find.x() && (pts[1].x() + epsilon) >= point_to_find.x() &&
        (pts[1].y() - epsilon) <= point_to_find.y() && (pts[2].y() + epsilon) >= point_to_find.y())
        return TRUE;
    else
        return FALSE;

}

template<typename T, typename Mesh>
size_t
pt_in_subcell(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {

    for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if (pt_in_cell(msh, point_to_find, cl)) // pt_in_cell
            return offset_subcells;
    }

    for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if (pt_in_cell_approximated(msh, point_to_find, cl)) // pt_in_cell
            return offset_subcells;
    }
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
    std::cout << "the point did not find is " << point_to_find << std::endl;
    std::cout << "IT DIDN'T FIND THE POINT IN SUBCELL " << offset(msh, agglocl) << std::endl;
    std::cout << "CELL vertices:" << '\n';
    for (auto &pt: points(msh, agglocl))
        std::cout << " , pt = " << pt;
    std::cout << '\n' << std::endl;
    throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");

}

template<typename T, typename Mesh>
size_t
pt_in_subcell_APPROX(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {

    for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if (pt_in_cell_approximated(msh, point_to_find, cl))
            return offset_subcells;
    }
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
    std::cout << "the point did not find is " << point_to_find << std::endl;
    std::cout << "IT DIDN'T FIND THE POINT IN SUBCELL(sbagliata) " << offset(msh, agglocl) << std::endl;
    std::cout << "CELL vertices:" << '\n';
    for (auto &pt: points(msh, agglocl))
        std::cout << " , pt = " << pt;
    std::cout << '\n' << std::endl;
    throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");

}

template<typename T, typename Mesh>
std::vector <size_t>
pt_in_skeleton(const Mesh &msh, const point<T, 2> &point_to_find) {
    std::vector <size_t> cells_offset;
    for (auto &cl: msh.cells) {
        for (auto &offset_subcells: cl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if (pt_in_cell(msh, point_to_find, cl))
                cells_offset.push_back(offset_subcells);

        }
    }
    return cells_offset;
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

}


template<typename T, typename Mesh>
std::vector <size_t>
pt_in_subcell_skeleton(const Mesh &msh, const point<T, 2> &point_to_find, const typename Mesh::cell_type &agglocl) {
    std::vector <size_t> cells_offset;
    for (auto &offset_subcells: agglocl.user_data.offset_subcells) {
//std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if (pt_in_cell(msh, point_to_find, cl))
            cells_offset.push_back(offset_subcells);

    }
    return cells_offset;
// IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

}


// SOSPETTO SIA UNITILE
/*
template<typename T , typename Mesh>
std::vector<size_t>
subcell_finder(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl, const mesh_init_params<T>& params)
{
    std::vector<size_t> ret(4);
    auto pts = points(msh,cl);
    auto hx = params.hx();
    auto hy = params.hy();
    bool check_already_found_x = FALSE;
    for (size_t i = 0; i < pts.size()-1; i++)
    {
        if( !check_already_found_x && pts[i].x()!= pts[i+1].x() && pts[i].x()<=point_to_find.x() && pts[i+1].x()>=point_to_find.x() )
        {
            if ( (pts[i].y()+hy)>=point_to_find.y() )
            {
                // point in the first row of subcells
                ret[0]=i;
                ret[1]=i+1;
                check_already_found_x = TRUE;
                for (size_t ii = 0; ii < pts.size(); ii++)
                {
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i].x() == pts[ii].x() ){
                        ret[2] = ii;
                    }
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i+1].x() == pts[ii].x() ){
                        ret[3] = ii;
                    }
                }
            }
            else
            {
                // point in the second row of subcells
                check_already_found_x = TRUE;
                for (size_t ii = 0; ii < pts.size(); ii++) // loop to find lower pts
                {
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i].x() == pts[ii].x() )
                    {
                        ret[0] = ii; // now I look for 3rd point
                        for (size_t j = 0; j < pts.size(); j++) {
                            if( (pts[ii].y()+hy) == pts[j].y() && pts[ii].x() == pts[j].x() ){
                                ret[2] = j;
                            }
                        }

                    } // end of the research for 1st and 3rd points
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i+1].x() == pts[ii].x() )
                    {
                        ret[1] = ii; // now I look for 4th point
                        for (size_t j = 0; j < pts.size(); j++) {
                            if( (pts[ii].y()+hy) == pts[j].y() && pts[ii+1].x() == pts[j].x() ){
                                ret[3] = j;
                            }
                        }

                    }// end of the research for 2nd and 4th points

                } // END of loop to find lower pts
            }  // END of else "search in the second row of subcells"

        } // END of the initial if-> I dont enter if ALREADY CHECKED or consecutive points have: same x or doesn't include pt to find

    } // end of the initial loop over the point
    return ret;
}

*/


template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, 1>
make_bernstein_local_mass_matrix_lumped(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree,
                                        size_t di = 2) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, (degree) + 2); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi;
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }

/*
    Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps2 = integrate(msh, cl, (degree)+2); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi ;
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }

    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<'\n'<<ret-ret2<<'\n'<<std::endl;
    std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<std::endl;


    //ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3
    */
    return ret;
}


template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix <T, Dynamic, Dynamic>
make_bernstein_local_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
//ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

// CHECK INTEGRATION
/*
    auto qps2 = integrate(msh, cl, 2*(degree)); // integration of order 2k
    Matrix<T, Dynamic, Dynamic> ret2 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi * phi.transpose();
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<'\n'<<ret-ret2<<'\n'<<std::endl;
     std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<std::endl;
    */
    return ret;
}


template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
make_lagrangian_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {
    cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
        std::cout << "phi " << '\n' << phi << std::endl;
        auto phi_grad = cb.eval_gradients(qp.first);
        std::cout << "phi_grad " << '\n' << phi_grad << std::endl;
        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }


    return std::make_pair(ret0, ret1);
}

template<typename Mesh, typename Velocity, typename T = typename Mesh::coordinate_type>
std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
make_bernstein_local_cij_matrix_with_velocity(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree,
                                              Velocity &u, size_t di = 1) {
    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
//std::cout<< "phi "<<'\n'<<phi<<std::endl;
        auto phi_grad = cb.eval_gradients(qp.first);
        auto u_val = u(qp.first, msh, cl);
//std::cout<< "phi_grad "<<'\n'<<phi_grad<<std::endl;
        ret0 += qp.second * u_val.first * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * u_val.second * phi * ((phi_grad).col(1)).transpose();
    }


    return std::make_pair(ret0, ret1);
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
make_bernstein_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 1) {
    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

/*
    // CHECKING ORDER INTEGRATION
    Matrix<T, Dynamic, Dynamic> ret1_bis = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps2 = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret1_bis += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    std::cout<<"THE CHECKING FOR CIJ ORDER IS "<<'\n'<<ret1 - ret1_bis<<std::endl;
    */
    return std::make_pair(ret0, ret1);
}

template<typename Mesh, typename T = typename Mesh::coordinate_type, typename Fonction>
std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>>
make_bernstein_local_RHS_VEC(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, const Fonction &f,
                             size_t di = 0) {

    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> ret = std::make_pair(Matrix<T, Dynamic, 1>::Zero(cbs, 1),
                                                                                  Matrix<T, Dynamic, 1>::Zero(cbs, 1));

    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto b = cb.eval_basis(qp.first);
        auto value0 = f(qp.first, msh, cl).first;
        auto value1 = f(qp.first, msh, cl).second;
        ret.first += qp.second * value0 * b;
        ret.second += qp.second * value1 * b;
    }

    return ret;
}


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein_high_order_interpolation :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
    std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
    SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix <T> cij_norm, nij0, nij1;
    SparseMatrix <T> cji_norm, nji0, nji1;


    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

    Level_set_berstein_high_order_interpolation(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                                bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check) {
        if (!analytic_check) {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1> RHS;    // Known term
            std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation


            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


            cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


// std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    for (size_t j = 0; j < local_dim; j++) {
/*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                        triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                        triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                        triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
            Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
            triplets.clear();


// Finalisation global assembling
            Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
            triplets_c_term_y.clear();

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

            cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                        Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
            nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
            SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
            SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient(cji_norm);
            nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

//std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
//std::cout<<"local_dim size "<<local_dim<<std::endl;
//std::cout<<"n_cls "<<n_cls<<std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum

            timecounter tcbis;

// tcbis.tic();
            set_max_min();
// tcbis.toc();
//std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds"
                      << std::endl;

        } else {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

//std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
                }



// Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set(qps[i]);


                auto sol_tmp = cod.solve(RHS_vandermonde);
                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);
                }


            } // end of cl loop

            tc_level_set.toc();
            std::cout
                    << "INITIALISATION (projection of analytic solution - no matrix calculation - no min/max calculation) LEVEL SET: t = "
                    << tc_level_set << " seconds" << std::endl;

        }


    }


    Level_set_berstein_high_order_interpolation() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
//std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;

        ret = gradient(pt);
        return ret / ret.norm();
    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
        size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval = cb.eval_gradients(pt);
                ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot(grad_eval.col(1));

                return ret;
            }
            counter += 1;

        }
        std::cout << "Se compare questo problema in gradient()" << std::endl;
        ret(0) += 1e10;
        ret(1) += 1e10;
        return ret; //to check if doesn't enter in the loop

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        auto grad = this->gradient(pt, msh, cl);
        T grad_norm = grad.norm();
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

//std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  (pow(grad(0), 2.0) * (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                   pow(grad(1), 2.0) * (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                   2.0 * pow(grad(0), 2.0) * pow(grad(1), 2.0) *
                                   (values_cell.dot(cb.eval_derivative_xy(pt))));

//std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//auto grad_eval = cb.eval_gradients(pt) ;

//T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }


    void normal_continuous_setting() {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        timecounter tc;
        tc.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
        for (auto &cl: msh.cells) {
            timecounter tc2;
//tc2.tic();
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
            }

        }
        tc.toc();

        std::cout << "----> TIME: normal continuous creation, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting() {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1>
    normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }


    T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);

    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein_high_order_interpolation_fast :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping



    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

    Level_set_berstein_high_order_interpolation_fast(const FiniteSpace &fe_data, const Fonction &level_set,
                                                     const Mesh &msh, bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check) {

        timecounter tc_level_set;
        tc_level_set.tic();
        Matrix<T, Dynamic, 1> RHS;    // Known term

        last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx - 1;
        number_faces_one_row = 2 * Nx +
                               1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

        normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);



// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
        sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);


        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


// std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            if (cell_offset == 0) {
                auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                    local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                }

                cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
            }



// Costruction of the coefficients of the Bernstein basis
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
            for (size_t i = 0; i < local_dim; i++) {


                RHS_vandermonde(i) = level_set(qps[i]);
            }


            auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

            sol_HHO.col(cell_offset) = sol_tmp;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            size_t i_vertex = cell_offset + floor(cell_offset / Nx);
            vertices(i_vertex) = sol_HHO(0, cell_offset);
            vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


        } // end of cl loop



        set_max_min();

        tc_level_set.toc();
        std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds"
                  << std::endl;


    }


    Level_set_berstein_high_order_interpolation_fast() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
//std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;

        ret = gradient(pt);
        return ret / ret.norm();
    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
        size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval = cb.eval_gradients(pt);
                ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot(grad_eval.col(1));

                return ret;
            }
            counter += 1;

        }
        std::cout << "Se compare questo problema in gradient()" << std::endl;
        ret(0) += 1e10;
        ret(1) += 1e10;
        return ret; //to check if doesn't enter in the loop

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        auto grad = this->gradient(pt, msh, cl);
        T grad_norm = grad.norm();
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

//std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  (pow(grad(0), 2.0) * (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                   pow(grad(1), 2.0) * (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                   2.0 * pow(grad(0), 2.0) * pow(grad(1), 2.0) *
                                   (values_cell.dot(cb.eval_derivative_xy(pt))));

//std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//auto grad_eval = cb.eval_gradients(pt) ;

//T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }


    template<typename Transport_Method>
    void normal_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        timecounter tc;
        tc.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
        for (auto &cl: msh.cells) {
            timecounter tc2;
//tc2.tic();
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
            }

        }
        tc.toc();

        std::cout << "----> TIME: normal continuous creation, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }


    template<typename Transport_Method>
    void gradient_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1>
    normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }


    T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);

    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


};


template<typename Mesh, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Transport_problem_method {

    Mesh msh;
    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem


// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
    SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix <T> cij_norm, nij0, nij1;
    SparseMatrix <T> cji_norm, nji0, nji1;

    Transport_problem_method(const FiniteSpace &fe_data, const Mesh &msh)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {

        timecounter tc_level_set;
        tc_level_set.tic();

        std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
        std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
        std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation





        Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx


        Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
        Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

        Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


        cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
        cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
        nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
        nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
        nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
        nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);


        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            if (cell_offset == 0) {
                auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                    local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                }

                cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
            }


            auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);


// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
            auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

            auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                for (size_t j = 0; j < local_dim; j++) {

                    size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                    triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                    triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                    triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));


                }
                Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);

            }


        } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
        Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
        triplets.clear();


// Finalisation global assembling
        Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
        triplets_c_term_x.clear();
        Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
        triplets_c_term_y.clear();


// NORM of c_ij

        cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                    Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
        nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
        nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
        SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
        SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
        cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
        nji0 = cji_x.cwiseQuotient(cji_norm);
        nji1 = cji_y.cwiseQuotient(cji_norm);


        tc_level_set.toc();
        std::cout << "Construction of Transport Problem method : machine time t = " << tc_level_set << " seconds"
                  << std::endl;

    }


};

template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein_high_order_interpolation_grad_cont :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
    std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
    SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix <T> cij_norm, nij0, nij1;
    SparseMatrix <T> cji_norm, nji0, nji1;


    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

    Level_set_berstein_high_order_interpolation_grad_cont(const FiniteSpace &fe_data, const Fonction &level_set,
                                                          const Mesh &msh, bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check) {
        if (!analytic_check) {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1> RHS;    // Known term
            std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation


            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


            cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    for (size_t j = 0; j < local_dim; j++) {
/*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                        triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                        triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                        triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
// Finalisation global assembling
            Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
            triplets.clear();


// Finalisation global assembling
            Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
            triplets_c_term_y.clear();

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

            cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                        Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
            nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
            SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
            SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient(cji_norm);
            nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

//std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
//std::cout<<"local_dim size "<<local_dim<<std::endl;
//std::cout<<"n_cls "<<n_cls<<std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum

            timecounter tcbis;

//tcbis.tic();
            set_max_min();
//tcbis.toc();
//std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << "Initialisation level set (+ matrices transport pb) : machine time t = " << tc_level_set
                      << " seconds" << std::endl;

        } else {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

//std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
                }



// Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set(qps[i]);


                auto sol_tmp = cod.solve(RHS_vandermonde);
                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);
                }


            } // end of cl loop

            tc_level_set.toc();
            std::cout << bold << yellow << "Initialisation level set: t = " << tc_level_set << " seconds" << reset
                      << std::endl;

        }


    }


    Level_set_berstein_high_order_interpolation_grad_cont() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min << "." << std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient_disc(pt, msh, cl);
        return ret / ret.norm();

    }

    T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
        auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                (values_cell.dot(grad_eval.col(1))) *
                                                                (values_cell.dot(cb.eval_derivative_xy(pt)))
        );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }


    void normal_continuous_setting() {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        timecounter tc;
        tc.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
        for (auto &cl: msh.cells) {
//timecounter tc2 ;
//tc2.tic();
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
            }

        }
        tc.toc();

        std::cout << "----> TIME: normal continuous setting, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting() {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }


    T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->gradient(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);

    }


//    void curvature_avg_continuous_setting()
//    {
//
//        bool first_cut_cell_found = FALSE ;
//        T distance_pts = 0.0;
//        point<T,2> first_point ;
//        point<T,2> cell_end_point;
//
//        for(auto& cl : msh.cells)
//        {
//
//            if(cl.user_data.location == element_location::ON_INTERFACE)
//            {
//
//                if(!first_cut_cell_found)
//                {
//                        bool agglo_cl = cl.user_data.highlight ;
//                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                        std::vector< size_t > index_inner_cls ;
//                        if( agglo_cl ){
//                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                        }
//        //                if( agglo_cl && amount_sub_cls == 2 )
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                if( agglo_cl && amount_sub_cls == 3 ){
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                    index_inner_cls.push_back( 2.0*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                }
//                        size_t pos_index = 0;
//                        size_t pos_index_bis = 0;
//
//                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                        {
//                            T val0 = ls_cell.divergence( *interface_point );
//
//                            point<T,2> curv_var = point_type(distance_pts , 0.0);
//                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                test_curv_var_cell->add_data(curv_var, val0);
//
//
//                             if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                             {
//                                 auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                 assert(offset_cells.size() == 2);
//                                 auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                 auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                 T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                 T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                 test_inner_cell->add_data(curv_var, val_skeleton0);
//                                 test_inner_cell->add_data(curv_var, val_skeleton1);
//                                 if( pos_index_bis+1 < index_inner_cls.size() )
//                                     pos_index_bis++;
//                             }
//
//                            test_curv_var_divergence0->add_data(curv_var, val0);
//                            if(*interface_point == *(cl.user_data.interface.end() -1))
//                                distance_pts +=  0.0 ;
//                            else
//                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                            // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
//                            pos_index++;
//                        }
//                        first_cut_cell_found = TRUE;
//                        first_point = *cl.user_data.interface.begin() ;
//                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                    }
//                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
//                    {
//                        for(auto& cl : msh_i.cells)
//                        {
//                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
//                            {
//                                ls_cell.cell_assignment(cl);
//
//                                bool agglo_cl = cl.user_data.highlight ;
//                                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                                std::vector< size_t > index_inner_cls ;
//                                if( agglo_cl ){
//                                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                                }
//                                size_t pos_index = 0;
//                                size_t pos_index_bis = 0;
//
//                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                                {
//
//                                    T val0 = ls_cell.divergence( *interface_point );
//
//                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
//                                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                        test_curv_var_cell->add_data(curv_var, val0);
//
//                                    test_curv_var_divergence0->add_data(curv_var, val0);
//
//                                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                                    {
//                                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                        assert(offset_cells.size() == 2);
//                                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                        T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                        T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                        test_inner_cell->add_data(curv_var, val_skeleton0);
//                                        test_inner_cell->add_data(curv_var, val_skeleton1);
//                                        if( pos_index_bis+1 < index_inner_cls.size() )
//                                            pos_index_bis++;
//                                    }
//
//
//                                    if(*interface_point == *(cl.user_data.interface.end() -1))
//                                        distance_pts += 0.0 ;
//                                    else
//                                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                                     pos_index++;
//                                }
//                                cell_end_point = *(cl.user_data.interface.end() -1) ;
//                            }
//
//                        }
//
//                    }
//                    else
//                        break;
//
//                }
//
//
//            }
//
//
//    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }
            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM) {
        size_t counter_FEM = 0;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if (!file_FEM.is_open()) {
            exit(10);
        }

        while (!file_FEM.eof()) {
            if (counter_FEM < sol_FEM.size()) {
                T val;
                file_FEM >> val;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM.close();

// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
            }
        }


    }


};


template<typename Mesh>
struct Interface_parametrisation {
    typedef typename Mesh::cell_type cell_type;
    typedef typename Mesh::coordinate_type T;
    Mesh msh_orig;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh msh_agglo;
    size_t degree_det;
    size_t basis_degree, basis_size;


    Interface_parametrisation(const Mesh &msh, size_t degree) : msh_orig(msh), basis_degree(degree),
                                                                basis_size(degree + 1), degree_det(2 * degree) {
    }


    Matrix<T, 2, 1>
    operator()(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


        auto physical_pts = cl.user_data.interface;

        cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);

        auto basis = cb.eval_basis_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = (size_pts - 1) / basis_degree;


        if (size_cls == 1) {

            ret(0) += basis(0) * physical_pts[0].x();
            ret(0) += basis(1) * physical_pts[basis_degree].x();
            ret(1) += basis(0) * physical_pts[0].y();
            ret(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1].x();
                ret(1) += basis(i) * physical_pts[i - 1].y();
            }
            return ret;
        } else {
            ret(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
            ret(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
            ret(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
            ret(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                ret(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
            }

            return ret;

        }
    }

    Matrix<T, 2, 1>
    operator()(const T &pt, int r = 0) const {

        return this->operator()(pt, msh_agglo, agglo_LS_cl, r);

    }


    Matrix<T, 2, 1>
    derivative(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


        auto physical_pts = cl.user_data.interface;

        cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);

        auto basis = cb.eval_gradients_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = (size_pts - 1) / basis_degree;


        if (size_cls == 1) {

            ret(0) += basis(0) * physical_pts[0].x();
            ret(0) += basis(1) * physical_pts[basis_degree].x();
            ret(1) += basis(0) * physical_pts[0].y();
            ret(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1].x();
                ret(1) += basis(i) * physical_pts[i - 1].y();
            }
            return ret;
        } else {
            ret(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
            ret(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
            ret(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
            ret(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

            for (size_t i = 2; i < basis_size; i++) {
                ret(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                ret(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
            }

            return ret;

        }
    }


    T
    jacobian(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {
        return (this->derivative(pt, msh, cl, r)).norm();
    }


    Matrix<T, 2, 1>
    tangent(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {

        auto der = (this->derivative(pt, msh, cl, r));
        return der / der.norm();


    }

    Matrix<T, 2, 1>
    normal_old(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {


        auto physical_pts = cl.user_data.interface;

        cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
        auto basis = cb.eval_double_derivative_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = (size_pts - 1) / basis_degree;

        auto curv_der = (this->derivative(pt, msh, cl, r));
        auto curv_der_norm = curv_der.norm();

        if (size_cls == 1) {

            curv_double_der(0) += basis(0) * physical_pts[0].x();
            curv_double_der(0) += basis(1) * physical_pts[basis_degree].x();
            curv_double_der(1) += basis(0) * physical_pts[0].y();
            curv_double_der(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                curv_double_der(0) += basis(i) * physical_pts[i - 1].x();
                curv_double_der(1) += basis(i) * physical_pts[i - 1].y();
            }
//return ret;
        } else {
            curv_double_der(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
            curv_double_der(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
            curv_double_der(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
            curv_double_der(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

            for (size_t i = 2; i < basis_size; i++) {
                curv_double_der(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                curv_double_der(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
            }

//return ret;

        }
        T coeff = curv_der(0) * curv_double_der(0) + curv_der(1) * curv_double_der(1);
        ret(0) = curv_double_der(0) / curv_der_norm - curv_der(0) / pow(curv_der_norm, 3) * coeff;
        ret(1) = curv_double_der(1) / curv_der_norm - curv_der(1) / pow(curv_der_norm, 3) * coeff;


        return -ret / ret.norm();

    }

    Matrix<T, 2, 1>
    normal(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {

        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        auto tan_pt = (this->tangent(pt, msh, cl, r));
        ret(0) = tan_pt(1);
        ret(1) = -tan_pt(0);
        return ret;

    }

    T
    curvature(const T &pt, const Mesh &msh, cell_type &cl, int r = 0) const {
        auto physical_pts = cl.user_data.interface;

        cell_basis_Lagrange_1d_reference<Mesh, T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
        auto basis = cb.eval_double_derivative_1d(pt);

        auto size_pts = physical_pts.size();
        auto size_cls = (size_pts - 1) / basis_degree;

        auto curv_der = (this->derivative(pt, msh, cl, r));
        auto curv_der_norm = curv_der.norm();

        if (size_cls == 1) {

            curv_double_der(0) += basis(0) * physical_pts[0].x();
            curv_double_der(0) += basis(1) * physical_pts[basis_degree].x();
            curv_double_der(1) += basis(0) * physical_pts[0].y();
            curv_double_der(1) += basis(1) * physical_pts[basis_degree].y();
            for (size_t i = 2; i < basis_size; i++) {
                curv_double_der(0) += basis(i) * physical_pts[i - 1].x();
                curv_double_der(1) += basis(i) * physical_pts[i - 1].y();
            }
//return ret;
        } else {
            curv_double_der(0) += basis(0) * physical_pts[0 + r * basis_degree].x();
            curv_double_der(0) += basis(1) * physical_pts[basis_degree + r * basis_degree].x();
            curv_double_der(1) += basis(0) * physical_pts[0 + r * basis_degree].y();
            curv_double_der(1) += basis(1) * physical_pts[basis_degree + r * basis_degree].y();

            for (size_t i = 2; i < basis_size; i++) {
                curv_double_der(0) += basis(i) * physical_pts[i - 1 + r * basis_degree].x();
                curv_double_der(1) += basis(i) * physical_pts[i - 1 + r * basis_degree].y();
            }

//return ret;

        }
        T coeff = curv_der(0) * curv_double_der(0) + curv_der(1) * curv_double_der(1);
        ret(0) = curv_double_der(0) / curv_der_norm - curv_der(0) / pow(curv_der_norm, 3) * coeff;
        ret(1) = curv_double_der(1) / curv_der_norm - curv_der(1) / pow(curv_der_norm, 3) * coeff;
//return -ret/ret.norm() ;

//std::cout<<"curv = "<< ret.norm()/curv_der_norm<<std::endl ;

        return ret.norm() / curv_der_norm;

    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(msh_orig.cells[offset_subcells]);

            }
        }

    }

    void mesh_assignment(const Mesh &msh) {
        msh_agglo = msh;

    }
};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;




//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1;


    Eigen::Matrix <T, Dynamic, Dynamic> divergence_c_HHO;
    Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM;
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix_grad;
    size_t ndof_FE_grad, local_dim_grad;
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix_div;
    size_t ndof_FE_div, local_dim_div;
    size_t degree_grad, degree_div;

    Level_set_berstein(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                       const FiniteSpace &fe_data_gradient, const FiniteSpace &fe_data_divergence,
                       bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check), ndof_FE_grad(fe_data_gradient.ndof_FE),
              local_dim_grad(fe_data_gradient.local_ndof),
              connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE),
              local_dim_div(fe_data_divergence.local_ndof),
              connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order),
              degree_div(fe_data_divergence.order) {

        timecounter tc_level_set;
        tc_level_set.tic();


        last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx - 1;
        number_faces_one_row = 2 * Nx +
                               1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

//normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

//gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

        gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
        gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
        gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
        gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

        divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_div, n_cls);
        divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
        sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            if (cell_offset == 0) {
                auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                    local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                }

                cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
            }





// Costruction of the coefficients of the Bernstein basis
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
            for (size_t i = 0; i < local_dim; i++) {

                RHS_vandermonde(i) = level_set(qps[i]);
            }


            auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

            sol_HHO.col(cell_offset) = sol_tmp;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            size_t i_vertex = cell_offset + floor(cell_offset / Nx);
            vertices(i_vertex) = sol_HHO(0, cell_offset);
            vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


        } // end of cl loop




        set_max_min();

        tc_level_set.toc();
//            std::cout << "Level set : t = " << tc_level_set << " seconds" << std::endl;



    }


    Level_set_berstein() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

//        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
//                if( std::abs(phi_max) >= std::abs(phi_min))
//                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
//                else
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
//                if( std::abs(phi_max) >= std::abs(phi_min))
//                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
//                else
                RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
//        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient_disc(pt, msh, cl);
        return ret / ret.norm();

    }

    T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
        auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                (values_cell.dot(grad_eval.col(1))) *
                                                                (values_cell.dot(cb.eval_derivative_xy(pt))));
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

//        return ( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );
// tolto il meno!!!!
    }

/*
    template< typename Transport_Method >
    void normal_continuous_setting(const Transport_Method& method )
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            //timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous setting, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    template<typename Transport_Method >
    void gradient_continuous_setting_k( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }
    */

    template<typename Transport_Method>
    void gradient_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_grad) + 1); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_grad; i++) {

                size_t asm_map = connectivity_matrix_grad[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim_grad; i++) {
                size_t asm_map = connectivity_matrix_grad[counter_bis][i].first;
                gradient_c_HHO_low_0(i, counter_bis) = gradient_c_FEM_low_0(asm_map);
                gradient_c_HHO_low_1(i, counter_bis) = gradient_c_FEM_low_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

/*
    Eigen::Matrix<T,2,1> gradient_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }
    */

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1>
    gradient_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }

/*
    Eigen::Matrix<T,2,1> normal_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }
    */
    Eigen::Matrix<T, 2, 1>
    normal_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }

/*
    T divergence_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient_cont_k( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }
    */
    T divergence_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->gradient_cont(pt, msh, cl)).norm();


        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);
//        return ( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction ); // tolto il meno

    }

    template<typename Transport_Method>
    void divergence_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"check integration order"<<std::endl;
        for (auto &cl: msh.cells) {
//std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);


            auto qps = integrate(msh, cl, 2 * (degree_div) + 1); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_grad_cont(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc += qp.second * disc_divergence * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
/*
            auto qps_prova = integrate(msh, cl, 2*(degree_FEM)+2); // integration of order 2k
            Matrix<T, Dynamic, 1> ret_loc_prova = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc_prova += qp.second * disc_divergence * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            std::cout<<ret_loc-ret_loc_prova<<std::endl;

*/            //std::cout<<ret_loc_prova<<std::endl;

//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_div; i++) {

                size_t asm_map = connectivity_matrix_div[cell_offset][i].first;

                ret(asm_map) += ret_loc(i);


            }


        }
//std::cout<<"FINE integration order"<<std::endl;
        divergence_c_FEM = solver_global_mass.solve(ret);

//std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim_div; i++) {
                size_t asm_map = connectivity_matrix_div[counter_bis][i].first;
//std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
//auto values_cell = divergence_c_HHO.col(counter);
        return (divergence_c_HHO.col(counter)).dot(cb.eval_basis(pt));
    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }
            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM) {
        size_t counter_FEM = 0;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if (!file_FEM.is_open()) {
            exit(10);
        }

        while (!file_FEM.eof()) {
            if (counter_FEM < sol_FEM.size()) {
                T val;
                file_FEM >> val;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM.close();

// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
            }
        }


    }


};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein_curvature2 :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;




//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
//Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
//Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_low_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1;


    Eigen::Matrix <T, Dynamic, Dynamic> divergence_c_HHO;
    Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM;
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix_grad;
    size_t ndof_FE_grad, local_dim_grad;
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix_div;
    size_t ndof_FE_div, local_dim_div;
    size_t degree_grad, degree_div;

    Level_set_berstein_curvature2(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                  const FiniteSpace &fe_data_gradient, const FiniteSpace &fe_data_divergence,
                                  bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check), ndof_FE_grad(fe_data_gradient.ndof_FE),
              local_dim_grad(fe_data_gradient.local_ndof),
              connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE),
              local_dim_div(fe_data_divergence.local_ndof),
              connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order),
              degree_div(fe_data_divergence.order) {

        timecounter tc_level_set;
        tc_level_set.tic();


        last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx - 1;
        number_faces_one_row = 2 * Nx +
                               1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

//normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
//normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

//gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
//gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
//gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

        gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
        gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_grad, n_cls);
        gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
        gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

        divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim_div, n_cls);
        divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
        sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            if (cell_offset == 0) {
                auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                    local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                }

                cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
            }





// Costruction of the coefficients of the Bernstein basis
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
            for (size_t i = 0; i < local_dim; i++) {

                RHS_vandermonde(i) = level_set(qps[i]);
            }


            auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

            sol_HHO.col(cell_offset) = sol_tmp;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            size_t i_vertex = cell_offset + floor(cell_offset / Nx);
            vertices(i_vertex) = sol_HHO(0, cell_offset);
            vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


        } // end of cl loop




        set_max_min();

        tc_level_set.toc();
        std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;


    }


    Level_set_berstein_curvature2() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                  << " (SI PUO TOGLIERE)." << std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient_disc(pt, msh, cl);
        return ret / ret.norm();

    }

    T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
        auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                (values_cell.dot(grad_eval.col(1))) *
                                                                (values_cell.dot(cb.eval_derivative_xy(pt)))
        );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }


    template<typename Transport_Method>
    void gradient_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_grad) + 1); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_grad; i++) {

                size_t asm_map = connectivity_matrix_grad[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim_grad; i++) {
                size_t asm_map = connectivity_matrix_grad[counter_bis][i].first;
                gradient_c_HHO_low_0(i, counter_bis) = gradient_c_FEM_low_0(asm_map);
                gradient_c_HHO_low_1(i, counter_bis) = gradient_c_FEM_low_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    gradient_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1>
    normal_grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_grad);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }


    template<typename Transport_Method>
    void divergence_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"check integration order"<<std::endl;
        for (auto &cl: msh.cells) {
//std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);


            auto qps = integrate(msh, cl, 2 * (degree_div) + 1); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc += qp.second * disc_divergence * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }

//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_div; i++) {

                size_t asm_map = connectivity_matrix_div[cell_offset][i].first;

                ret(asm_map) += ret_loc(i);


            }


        }
//std::cout<<"FINE integration order"<<std::endl;
        divergence_c_FEM = solver_global_mass.solve(ret);

//std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim_div; i++) {
                size_t asm_map = connectivity_matrix_div[counter_bis][i].first;
//std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }


    void divergence_continuous_setting_avg() {


        Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE_div);
        Array<T, Dynamic, 1> sum = Array<T, Dynamic, 1>::Zero(ndof_FE_div);


        size_t counter_cl = 0;
        for (auto &cl: msh.cells) {
            size_t i = 0;
            auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, degree_div);
            for (auto &qp: qps) {
                size_t asm_map = connectivity_matrix_div[counter_cl][i].first;
                sum(asm_map) += (this->divergence_disc(qp, msh, cl));
                counting_avg(asm_map)++;
            }
        }

        divergence_c_FEM = (sum.array()).cwiseQuotient(counting_avg);


        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                divergence_c_HHO(i, counter_bis) = divergence_c_FEM(asm_map);
            }

        }

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_div);
//auto values_cell = divergence_c_HHO.col(counter);
        return (divergence_c_HHO.col(counter)).dot(cb.eval_basis(pt));
    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }
            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM) {
        size_t counter_FEM = 0;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if (!file_FEM.is_open()) {
            exit(10);
        }

        while (!file_FEM.eof()) {
            if (counter_FEM < sol_FEM.size()) {
                T val;
                file_FEM >> val;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM.close();

// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
            }
        }


    }


};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct Level_set_berstein_high_order_interpolation_grad_cont_fast :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

    Level_set_berstein_high_order_interpolation_grad_cont_fast(const FiniteSpace &fe_data, const Fonction &level_set,
                                                               const Mesh &msh, bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check) {

        timecounter tc_level_set;
        tc_level_set.tic();


        last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx - 1;
        number_faces_one_row = 2 * Nx +
                               1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

        normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);




// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
        sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


//std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            if (cell_offset == 0) {
                auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                    local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                }

                cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
            }





// Costruction of the coefficients of the Bernstein basis
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
            for (size_t i = 0; i < local_dim; i++) {

                RHS_vandermonde(i) = level_set(qps[i]);
            }


            auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

            sol_HHO.col(cell_offset) = sol_tmp;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            size_t i_vertex = cell_offset + floor(cell_offset / Nx);
            vertices(i_vertex) = sol_HHO(0, cell_offset);
            vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


        } // end of cl loop




        set_max_min();

        tc_level_set.toc();
        std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;


    }


    Level_set_berstein_high_order_interpolation_grad_cont_fast() = default;


    void
    coefficients_mapping() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_mapping_MAX_MAX() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

//std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
//std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 0;
// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }
//        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                  << " (SI PUO TOGLIERE)." << std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    gradient_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1>
    normal_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient_disc(pt, msh, cl);
        return ret / ret.norm();

    }

    T divergence_disc(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        T grad_norm = (this->gradient_disc(pt, msh, cl)).norm();
        auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                (values_cell.dot(grad_eval.col(1))) *
                                                                (values_cell.dot(cb.eval_derivative_xy(pt)))
        );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }

    template<typename Transport_Method>
    void normal_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        timecounter tc;
        tc.tic();

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//tc.toc();
//std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
//std::cout<<"sono qua 0"<<std::endl;

//tc.tic();
        for (auto &cl: msh.cells) {
//timecounter tc2 ;
//tc2.tic();
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k
//tc2.toc();
//std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
//tc2.tic();
            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose());
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose());
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//tc2.toc();
//std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
//std::cout<<"sono qua 1"<<std::endl;
//tc2.tic();
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;
//tc2.toc();
//std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
//tc.toc();
//std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
//tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
//tc.toc();
//std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
//tc.tic();
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
            }

        }
        tc.toc();

        std::cout << "----> TIME: normal continuous setting, time = " << tc << std::endl;
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    template<typename Transport_Method>
    void gradient_continuous_setting(const Transport_Method &method) {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
            }

        }
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
//std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
//std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret / ret.norm();

    }


    T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->gradient(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);

    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }
            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i);
            }

            if (!analytic_check) {
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM) {
        size_t counter_FEM = 0;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if (!file_FEM.is_open()) {
            exit(10);
        }

        while (!file_FEM.eof()) {
            if (counter_FEM < sol_FEM.size()) {
                T val;
                file_FEM >> val;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM.close();

// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO(i, counter_HHO) = sol_FEM(asm_map);
            }
        }


    }


};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct L2projected_level_set_high_order_parallelize :
        public level_set<T> {

    bool analytic_check = FALSE;

    T phi_max, phi_min;
    size_t last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton

// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
    std::vector <std::set<size_t>> S_i;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

// Local Vandermonde Matrix for interpolation
    Matrix <T, Dynamic, Dynamic> local_vandermonde;


// Assembling into global matrix
    SparseMatrix <T> Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix <T> Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1> Global_Mass_Lumped; // Global mass, saved for FEM problem
//SparseMatrix<T>                 Global_Mass_Lumped_sparse;

    SparseMatrix <T> cij_norm, nij0, nij1;
    SparseMatrix <T> cji_norm, nji0, nji1;


    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> normal_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1;

    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_0;
    Eigen::Matrix <T, Dynamic, Dynamic> gradient_c_HHO_1;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1;

    L2projected_level_set_high_order_parallelize(const FiniteSpace &fe_data, const Fonction &level_set, const Mesh &msh,
                                                 bool analytic_check = FALSE)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE),
              analytic_check(analytic_check) {
        if (!analytic_check) {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1> RHS;    // Known term



            last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx - 1;
            number_faces_one_row = 2 * Nx +
                                   1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero(ndof_FE); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>(ndof_FE, ndof_FE); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
//Global_Mass_Lumped_sparse = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
//Global_Mass_Lumped_sparse.reserve(ndof_FE);

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);


            cij_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            cji_norm = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nij1 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji0 = SparseMatrix<T>(ndof_FE, ndof_FE);
            nji1 = SparseMatrix<T>(ndof_FE, ndof_FE);
/*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);

//Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;
//FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            std::cout
                    << "----> In 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis."
                    << std::endl;

//std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            timecounter tc_prova;
/*
#ifdef HAVE_INTEL_TBB
            //tc_prova.tic();
            //tbb::task_scheduler_init init(1);
            tbb::task_scheduler_init init(tbb::task_scheduler_init::default_num_threads());
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            for (size_t ind = 0; ind < local_dim; ind++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //               [ & ] (size_t & ind){
                local_vandermonde.block(ind,0,1,local_dim) = (cb.eval_basis(pts[ind])).transpose() ;


            }
              //  );

            cod.compute(local_vandermonde);
            //tc_prova.toc();
            //std::cout << bold << yellow << "--> local_vandermonde: t = " << tc_prova << " seconds" << reset << std::endl;

            tc_prova.tic();

            std::vector< Triplet<T> >       triplets_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y_loc; // Position elements: Sparse Matrix Notation
            //std::vector< Triplet<T> >       triplets_lumped_loc; // Position elements: Sparse Matrix Notation
            Matrix<T, Dynamic, 1> RHS_vandermonde_loc = Matrix<T, Dynamic, 1>::Zero(local_dim);

            size_t n_cells = msh.cells.size();
            //std::cout<<" I m in parallel zone"<<std::endl;
            timecounter tc_prova2;
            //for( const auto& cl : msh.cells )
            //{
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                //tc_prova2.tic();
                //size_t cell_ind = offset(msh, cl) ;
                //std::cout<<"----> Pos 0"<<std::endl;
                auto &cl = msh.cells[cell_ind];
                //std::cout<<"---> CELL = "<<cell_ind<<std::endl;
                //std::cout<<"----> Pos 1"<<std::endl;
                //size_t cell_offset = offset(msh, cl) ;
                //std::cout<<"----> Pos 2"<<std::endl;
                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );
                //std::cout<<"----> Pos 3"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);
                //std::cout<<"----> Pos 4"<<std::endl;
                //tc_prova2.toc();

                //std::cout << "----> TIME --> local_cij : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;
                //std::cout<<"----> Pos 5"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_lumped_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                //std::cout<<"-----> Pos 7"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> qps points : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                for (size_t i = 0; i < local_dim; i++)
                {

                    //std::cout<<"----> Pos 6"<<std::endl;
                    size_t asm_map_i = connectivity_matrix[cell_ind][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {
                        size_t asm_map_j = connectivity_matrix[cell_ind][j].first ;
                        //std::cout<<"i = "<<i <<" , j = "<< j <<std::endl;
                        //std::cout<<"asm_map_i = "<<asm_map_i <<" , asm_map_j = "<< asm_map_j <<std::endl;
                        //std::cout<<"-----> Pos 8.0"<<std::endl;
                        //Global_Mass.coeffRef( asm_map_i, asm_map_j ) += local_mass(i,j) ;
                        //std::cout<<"-----> Pos 8.1"<<std::endl;
                        //Global_c_term_x.coeffRef( asm_map_i, asm_map_j ) += local_cij.first(i,j);
                        //std::cout<<"-----> Pos 8.2"<<std::endl;
                        //Global_c_term_y.coeffRef( asm_map_i, asm_map_j ) += local_cij.second(i,j)  ;
                        //std::cout<<"-----> Pos 8.3"<<std::endl;

                      triplets_loc.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                      triplets_c_term_x_loc.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                      triplets_c_term_y_loc.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                    }

                    //std::cout<<"---------> Pos 8.4"<<std::endl;
                    //triplets_lumped_loc.push_back( Triplet<T>( asm_map_i , asm_map_i , local_mass_lumped(i) ) );

                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    RHS_vandermonde_loc(i) = level_set( qps[i]) ;
                    //std::cout<<"----> Pos 8"<<std::endl;
                }
                //tc_prova2.toc();
                //std::cout << "----> TIME --> Double loop : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                //std::cout<<"-----> Pos 9"<<std::endl;
                auto sol_tmp = cod.solve(RHS_vandermonde_loc) ;

                sol_HHO.col(cell_ind) = sol_tmp ;
                for (size_t ind2 = 0; ind2 < local_dim; ind2++)
                {
                    size_t asm_map =  connectivity_matrix[cell_ind][ind2].first ;
                    sol_FEM( asm_map ) = sol_HHO(ind2,cell_ind) ;

                }


                size_t i_vertex = cell_ind+floor(cell_ind/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_ind) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

                //tc_prova2.toc();
                //std::cout << "----> TIME --> RESOLUTION : t = " << tc_prova2 << " seconds" << std::endl;
            }
            );
            //std::cout<<"----------------------> Pos 10"<<std::endl;
            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets_loc.begin(), triplets_loc.end() );
            triplets_loc.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x_loc.begin(), triplets_c_term_x_loc.end() );
            triplets_c_term_x_loc.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y_loc.begin(), triplets_c_term_y_loc.end() );
            triplets_c_term_y_loc.clear();
            //Global_Mass_Lumped_sparse.setFromTriplets( triplets_lumped_loc.begin(), triplets_lumped_loc.end() );
            //triplets_lumped_loc.clear();

            tc_prova.toc();
            std::cout << bold << yellow << "--> COSTRUCTION PROJECTION : t = " << tc_prova << " seconds" << reset << std::endl;

#else
     */
            std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector <Triplet<T>> triplets_c_term_y; // Position elements: Sparse Matrix Notation

            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
//cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix(msh, cl, degree_FEM);

//auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
// Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped(msh, cl, degree_FEM);


// Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);


// Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++) {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                    for (size_t j = 0; j < local_dim; j++) {

                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first;

                        triplets.push_back(Triplet<T>(asm_map_i, asm_map_j, local_mass(i, j)));
                        triplets_c_term_x.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i, j)));
                        triplets_c_term_y.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i, j)));

/*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
//Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
//RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set(qps[i]);
                }


                auto sol_tmp = cod.solve(RHS_vandermonde);

//auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp;
                for (size_t i = 0; i < local_dim; i++) {

                    size_t asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_HHO(i, cell_offset);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);


            } // end of cl loop

// Finalisation global assembling
            Global_Mass.setFromTriplets(triplets.begin(), triplets.end());
            triplets.clear();


// Finalisation global assembling
            Global_c_term_x.setFromTriplets(triplets_c_term_x.begin(), triplets_c_term_x.end());
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets(triplets_c_term_y.begin(), triplets_c_term_y.end());
            triplets_c_term_y.clear();



//#endif

//std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;

/*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

// NORM of c_ij

            cij_norm = (Global_c_term_x.cwiseProduct(Global_c_term_x) +
                        Global_c_term_y.cwiseProduct(Global_c_term_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient(cij_norm);
            nij1 = Global_c_term_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
            SparseMatrix <T> cji_x = Global_c_term_x.adjoint();
            SparseMatrix <T> cji_y = Global_c_term_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient(cji_norm);
            nji1 = cji_y.cwiseQuotient(cji_norm);




//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


// CALCULATION OF THE SIZE + PLOTTING
/*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




//Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

            std::cout << "sol_FEM size " << sol_FEM.size() << std::endl;
            std::cout << "local_dim size " << local_dim << std::endl;
            std::cout << "n_cls " << n_cls << std::endl;

// Global solution saved as discontinuous HHO approach
// Also saved min & max coefficients + position in HHO notation

/*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

/*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


//sol_FEM = sol_FEM_vandermonde ;
//sol_HHO = sol_HHO_vandermonde ;
//std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
// Set of maximum and minimum
            timecounter tcbis;
            tcbis.tic();
            set_max_min();
            tcbis.toc();
            std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


/*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset
                      << std::endl;

        } else {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, local_dim);


// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

            CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod;

            std::cout
                    << "----> FOR ANALYTIC CHECK 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis. JUST HHO FORMULATION IMPLEMENTED"
                    << std::endl;


/*

            // I TOOK AWAY BECAUSE I DO NOT HAVE TBB
#ifdef HAVE_INTEL_TBB
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                                      [&] (size_t & i){
                           local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;


                           }
                           );

            cod.compute(local_vandermonde);


            size_t n_cells = msh.cells.size();
            std::cout<<" I m in parallel zone"<<std::endl;
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                auto& cl = msh.cells[cell_ind];
                size_t cell_offset = offset(msh, cl) ;
                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                        [&] (size_t & i){
                        RHS_vandermonde(i) = level_set( qps[i]) ;
                    }
                    );

                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;


            }
            );

#else
            */
            for (const auto &cl: msh.cells) {
                size_t cell_offset = offset(msh, cl);

                if (cell_offset == 0) {
                    auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++) {
// Local vandermonde matrix
                        local_vandermonde.block(i, 0, 1, local_dim) = (cb.eval_basis(pts[i])).transpose();
                    }

                    cod.compute(local_vandermonde);
                }



// Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set(qps[i]);


                auto sol_tmp = cod.solve(RHS_vandermonde);
                sol_HHO.col(cell_offset) = sol_tmp;


            } // end of cl loop

//#endif
            tc_level_set.toc();
            std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset
                      << std::endl;

        }


    }


    L2projected_level_set_high_order_parallelize() = default;


    void
    coefficients_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );

                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );
#else
*/

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (phi_max - phi_min);
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop


        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

        std::cout << "IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "
                  << (0.0 - phi_min) / (phi_max - phi_min) << std::endl;

        std::cout << "It should be close to 1/2, error = " << 1. / 2. - (0.0 - phi_min) / (phi_max - phi_min)
                  << std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

//#endif

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;


    }


    void
    coefficients_inverse_mapping() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

        }
        );

#else */
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }


//#endif
        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );


#else */

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) + phi_max) / (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = ((*this)(pt, msh, cl) - phi_min) / (-2.0 * phi_min);

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;

        std::cout << "IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "
                  << (0.0 + phi_max) / (2.0 * phi_max) << std::endl;
        std::cout << "It should be close to 1/2, error = " << 1. / 2. - (0.0 + phi_max) / (2.0 * phi_max) << std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }


//#endif

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;


    }

    void
    coefficients_inverse_mapping_MAX_MAX() {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(i) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );



#else */
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                if (std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt, msh, cl) * (2.0 * phi_max);
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt, msh, cl) * (2.0 * phi_min);

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }


//#endif
        std::cout << "LEVEL_SET: CHECK VALUES AFTER INVERSE_MAPPING_MAX_MAX: MAX = " << ret0 << " , MIN = " << ret1
                  << std::endl;

    }


    void
    coefficients_sfasamento() {

        std::cout << "---> coefficients_sfasamento is not parallelize for the moment." << std::endl;
        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = (*this)(pt, msh, cl) + 0.5;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
//std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void
    coefficients_mapping_quadratic() {
        std::cout << "---> coefficients_mapping_quadratic is not parallelize for the moment." << std::endl;

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        T a1 = (-1.0 / 2.0 - phi_min / (phi_max - phi_min)) / (pow(phi_min, 2));
        T b = 1.0 / (phi_max - phi_min);
        T c = 1.0 / 2.0;
        T a2 = (1.0 / 2.0 - phi_max / (phi_max - phi_min)) / (pow(phi_max, 2));

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                auto val = (*this)(pt, msh, cl);
                if (val <= 0)
                    RHS_vandermonde(ct) = a1 * val * val + b * val + c;
                else
                    RHS_vandermonde(ct) = a2 * val * val + b * val + c;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }

        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);
        iso_val_interface = 1.0 / 2.0;
        std::cout << "Isovalue of the interface = " << iso_val_interface << std::endl;
//std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

//std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic() {
        std::cout << "---> coefficients_mapping_quadratic is not parallelize for the moment." << std::endl;
        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            size_t ct = 0;
            for (auto &pt: nodes) {
                RHS_vandermonde(ct) = phi_min + (*this)(pt, msh, cl) * (phi_max - phi_min);
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++) {
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i);
            }


        } // end of cl loop

        sol_FEM = mapped_phi;
        converting_into_HHO_formulation(sol_FEM);

// CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        std::cout << "LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = " << ret0 << " , MIN = " << ret1 << std::endl;

    }


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        sol_HHO = values_new;
        std::cout << " --> set_discrete_points: check that sol_FEM already uploaded!" << std::endl;

    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
// SAVE BOTH SOL_HHO AND VERTICES
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_HHO(i,cell_ind) = values_new( asm_map );
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = sol_HHO(0,cell_ind) ;
            vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

        }
        );

#else */
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);

            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);

        }
//#endif

        std::cout << " --> converting_into_HHO_formulation. TO BE CHECKED that sol_FEM already uploaded!" << std::endl;

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_FEM( asm_map ) = values_new(i,cell_ind) ;
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = values_new(0,cell_ind) ;
            vertices(i_vertex+1) = values_new(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = values_new(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = values_new(3,cell_ind) ;
        }
        );

#else */
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = values_new(0, counter_bis);
            vertices(i_vertex + 1) = values_new(1, counter_bis);
            vertices(i_vertex + Nx + 2) = values_new(2, counter_bis);
            vertices(i_vertex + Nx + 1) = values_new(3, counter_bis);

        }

//#endif
        std::cout << " --> converting_into_FE_formulation. TO BE CHECKED that sol_HHO already uploaded!" << std::endl;

    }


    void set_max_min() {

        T ret0 = -10.0;
        T ret1 = 10.0;
/*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];

            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            for(auto& nd : nodes ){
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
            //    auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
           // );
        }
        );
        phi_max = ret0;
        phi_min = ret1;

#else */
        size_t counter_ret0 = 0;
        for (auto &cl: msh.cells) {
            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);

            for (auto &nd: nodes) {
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0, counter_ret0, local_dim, 1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp);
                ret0 = std::max(new_ret, ret0);
                ret1 = std::min(new_ret, ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
//#endif
        std::cout << " --> set_max_min: LEVEL_SET: MAX IS " << phi_max << " , MIN IS " << phi_min
                  << " . SI PUO TOGLIERE." << std::endl;
    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
// It should work also for Bernstein Basis
    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T, 2> &pt) const {
/*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );
            }
        }
        );

        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator() PARALLEL!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop

#else
        */
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

                return values_cell.dot(cb.eval_basis(pt));

            }
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop

//#endif

    }


// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));

        return tmp;

    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter_cell, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;

        ret = gradient(pt);
        return ret / ret.norm();
    }


// IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
/*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
           if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(cell_ind);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
        }
        );
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;

        return ret; //to check if doesn't enter in the loop


#else
        */
        size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        for (const auto &cl: msh.cells) {
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
                cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval = cb.eval_gradients(pt);
                ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot(grad_eval.col(1));

                return ret;
            }
            counter += 1;

        }
        std::cout << "Se compare questo problema in gradient()" << std::endl;
        ret(0) += 1e10;
        ret(1) += 1e10;
        return ret; //to check if doesn't enter in the loop
//#endif

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }

/*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);

        T grad_norm = (this->gradient(pt, msh, cl)).norm();
        auto grad_eval = cb.eval_gradients(pt);
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) * ((pow((values_cell.dot(grad_eval.col(0))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_x(pt))) +
                                                                (pow((values_cell.dot(grad_eval.col(1))), 2)) *
                                                                (values_cell.dot(cb.eval_double_derivative_y(pt))) +
                                                                2.0 * (values_cell.dot(grad_eval.col(0))) *
                                                                (values_cell.dot(grad_eval.col(1))) *
                                                                (values_cell.dot(cb.eval_derivative_xy(pt)))
        );
//std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
//T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell.dot(cb.eval_divergence(pt))) / (grad_norm) + divergence_correction);

    }


    void normal_continuous_setting() {


        timecounter tc;
        tc.tic();
        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);


        tc.toc();
        std::cout << "----> TIME: In normal_continuous_setting PARALLEL INVERSIONE MATRIX, time = " << tc << std::endl;
/*
#ifdef HAVE_INTEL_TBB
        tbb::task_scheduler_init init(1);
        size_t n_cells = msh.cells.size();

        tc.tic();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            //timecounter tc2 ;
            //tc2.tic();
            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            for (auto& qp : qps)
            {
            //size_t qps_size = qps.size();
            //tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            //    [&] (size_t & j){
            //    auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                ret1_loc += qp.second * disc_normal(1) * phi.transpose();

            }
           // );
            //tc2.toc();
            //std::cout<<"----> TIME: PARALLEL QPS = "<<tc2<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            //);
        }
        );
        tc.toc();

        std::cout<<"----> TIME: PARALLEL FEM CONSTRUCTION, time = "<<tc<<std::endl;
        tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        tc.toc();

        std::cout<<"----> TIME: FEM SOLVER, time = "<<tc<<std::endl;

        tc.tic();
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
        //    tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
        //    [&] (size_t & i){
             for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                normal_c_HHO_0(i,cell_ind) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,cell_ind) = normal_c_FEM_1( asm_map ) ;
            }
         //   );

        }
        );

        tc.toc();

        std::cout<<"----> TIME: PARALLEL HHO, time = "<<tc<<std::endl;

#else */


//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                ret1_loc += qp.second * disc_normal(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                normal_c_HHO_0(i, counter_bis) = normal_c_FEM_0(asm_map);
                normal_c_HHO_1(i, counter_bis) = normal_c_FEM_1(asm_map);
            }

        }

//#endif
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1>
    normal_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
//T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
//std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)));
//  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting() {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1);

        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(Global_Mass);




/*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            size_t qps_size = qps.size();
            tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            [&] (size_t & j){

                auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
            }
            );


            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            );
        }
        );


        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                gradient_c_HHO_0(i,cell_ind) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,cell_ind) = gradient_c_FEM_1( asm_map ) ;
            }
            );

        }
        );


#else  */

//std::cout<<"sono qua 0"<<std::endl;
        for (auto &cl: msh.cells) {

            cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh, cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

            auto qps = integrate(msh, cl, 2 * (degree_FEM + 1)); // integration of order 2k

            for (auto &qp: qps) {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient(qp.first, msh, cl));
//auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
//std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++) {

                size_t asm_map = connectivity_matrix[cell_offset][i].first;
//std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0(asm_map) += ret0_loc(i);
                ret1(asm_map) += ret1_loc(i);

//if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
//    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
//std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                gradient_c_HHO_0(i, counter_bis) = gradient_c_FEM_0(asm_map);
                gradient_c_HHO_1(i, counter_bis) = gradient_c_FEM_1(asm_map);
            }

        }

//#endif
//std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T, 2, 1> grad_cont(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
//std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
//std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
//std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T, 2, 1>
    normal_cont_normalised(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
// Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);


        auto basis_eval = cb.eval_basis(pt);
        ret(0) = values_cell0.dot(basis_eval);
        ret(1) = values_cell1.dot(basis_eval);
        std::cout << "gradient_c_HHO" << '\n' << ret / ret.norm() << std::endl;

        return ret / ret.norm();

    }


    T divergence_cont_grad(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt);
        auto b_eval = cb.eval_basis(pt);
        T grad_norm = (this->grad_cont(pt, msh, cl)).norm();

//std::cout<<"grad norm is "<<grad_norm<<std::endl;
//std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
//std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
//std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0 / (pow(grad_norm, 3)) *
                                  ((pow((values_cell0.dot(b_eval)), 2)) * (values_cell0.dot(grad_eval.col(0))) +
                                   (values_cell0.dot(b_eval)) * (values_cell1.dot(b_eval)) *
                                   (values_cell1.dot(grad_eval.col(0))) +
                                   (values_cell1.dot(b_eval)) * (values_cell0.dot(b_eval)) *
                                   (values_cell0.dot(grad_eval.col(1))) +
                                   (pow((values_cell1.dot(b_eval)), 2)) * (values_cell1.dot(grad_eval.col(1))));


//std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
//std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -((values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1))) / (grad_norm) +
                 divergence_correction);

    }


    void smooth_cut_off(T C, T r0, T delta, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


/*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde

            if (!analytic_check) {
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


/*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off(T C, T x_centre, T y_centre, T radius, T radius_a, T radius_b) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
//Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max(radius_a, radius_b);
        T h = std::max(hx, hy);
        T r0 = r_max + 2 * h * sqrt(2.0);
        C = r0 * r0 * radius_b * radius_b - radius_a * radius_a * radius_b * radius_b;
//T dist = pos_r0 - radius + 2.0*0.0625;
//T dist = pos_r0 - radius + 2.0*0.07;
//T r0 = radius + dist/2.0;

        T delta = r0 / 8.0; // FIRST CHOICE
//T delta = r0/20.0;





        std::cout << "r_max = " << r_max << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;

// Lambda function to define smooth function
        auto alfa = [=](const point<T, 2> &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };


        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;
                local_RHS(i) = (1.0 - alfa(pt)) * C + alfa(pt) * (*this)(pt, msh, cl);
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde

            if (!analytic_check) {
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }
                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }

        } // end of cl loop



//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();

    }


    void cut_off(T d) {

        Matrix<T, Dynamic, 1> local_RHS = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);
        Matrix<T, Dynamic, 1> sol_loc = Matrix<T, Dynamic, 1>::Zero(local_dim, 1);

        CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> vandermonde_interpolant(local_vandermonde);


// Known term (f,b_i)_i , b_i Bernstein basis fx
        for (const auto &cl: msh.cells) {
            size_t cell_offset = offset(msh, cl);

            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            for (size_t i = 0; i < local_dim; i++) {
                auto pt = qps[i];
                auto asm_map = connectivity_matrix[cell_offset][i].first;

                if ((*this)(pt, msh, cl) >= d)
                    local_RHS(i) = d;
                else if ((*this)(pt, msh, cl) <= -d)
                    local_RHS(i) = -d;
                else
                    local_RHS(i) = (*this)(pt, msh, cl);

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc; // SAVE Vandermonde
            if (!analytic_check) {
                for (size_t i = 0; i < local_dim; i++) {
                    auto asm_map = connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i);
                }

                size_t i_vertex = cell_offset + floor(cell_offset / Nx);
                vertices(i_vertex) = sol_HHO(0, cell_offset);
                vertices(i_vertex + 1) = sol_HHO(1, cell_offset);
                vertices(i_vertex + Nx + 2) = sol_HHO(2, cell_offset);
                vertices(i_vertex + Nx + 1) = sol_HHO(3, cell_offset);
            }
        } // end of cl loop




//converting_into_HHO_formulation(sol_FEM);
        if (!analytic_check)
            set_max_min();


    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_Bernstein_high_order :
        public Level_set_berstein_high_order_interpolation<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_Bernstein_high_order(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_Bernstein_high_order() = default;


    LS_cell_Bernstein_high_order(const LS_cell_Bernstein_high_order &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }


    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> normal_cont_normalised(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont_normalised(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont_normalised(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient(pt, level_set.msh, subcl);
        }

    }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence(pt, level_set.msh, subcl);
        }
    }

    T divergence_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }

    T divergence_cont_grad(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont_grad(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont_grad(pt, level_set.msh, subcl);
        }
    }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
        return normal(pt);
    }

    T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()(pt);
    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_cont :
        public Level_set_berstein_high_order_interpolation_grad_cont<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_grad_cont(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_cont() = default;

    LS_cell_high_order_grad_cont(const LS_cell_high_order_grad_cont &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
//        std::cout<<"LEVEL SET NORMAL. TO BE SUBSTITUTED WITH PARAMETRIC ONE!"<<std::endl;
        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient(pt, level_set.msh, subcl);
        }

    }

    Eigen::Matrix<T, 2, 1> gradient_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc(pt, level_set.msh, subcl);
        }

    }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence(pt, level_set.msh, subcl);
        }
    }

    T divergence_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }

    T divergence_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

//    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
//    {
//        //agglo_LS_cl = cl;
//        cell_assignment(cl);
//        std::cout<<"If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."<<std::endl;
//        exit(9);
//        return normal( pt );
//    }

    T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout
                << "If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."
                << std::endl;
        exit(9);
        return operator()(pt);
    }

    T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence(pt, level_set.msh, cl);
    }

    T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_disc(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal_disc(pt, level_set.msh, cl);
    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_cont_div_cont2 :
        public Level_set_berstein_curvature2<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

    LS_cell_high_order_grad_cont_div_cont2(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_cont_div_cont2() = default;

    LS_cell_high_order_grad_cont_div_cont2(const LS_cell_high_order_grad_cont_div_cont2 &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }


};

template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_disc_div_cont2 :
        public Level_set_berstein_curvature2<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

    LS_cell_high_order_grad_disc_div_cont2(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_cont2() = default;

    LS_cell_high_order_grad_disc_div_cont2(const LS_cell_high_order_grad_disc_div_cont2 &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_curvature_cont :
        public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_curvature_cont(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_curvature_cont() = default;

    LS_cell_high_order_curvature_cont(const LS_cell_high_order_curvature_cont &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal_grad_cont(pt, level_set.msh, subcl);
        }
    }

/*
    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }
    */

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont(pt, level_set.msh, subcl);
        }

    }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }
/*
    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_disc( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    */
/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }
/*
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }
    */

};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_div_disc_grad_n_cont :
        public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

    LS_cell_high_order_div_disc_grad_n_cont(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_div_disc_grad_n_cont() = default;

    LS_cell_high_order_div_disc_grad_n_cont(const LS_cell_high_order_div_disc_grad_n_cont &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_cont_div_disc :
        public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;
    size_t deg, grad_deg, div_deg;

    LS_cell_high_order_grad_cont_div_disc(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface),
              deg(level_set_.degree_FEM) {
        grad_deg = deg;
        div_deg = deg;
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_cont_div_disc() = default;

    LS_cell_high_order_grad_cont_div_disc(const LS_cell_high_order_grad_cont_div_disc &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;
        deg = other.deg;
        grad_deg = other.grad_deg;
        div_deg = other.div_deg;
    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);

            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_grad_cont(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_grad_cont(pt, level_set.msh, subcl);
        }
    }

    T divergence_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }


    T operator()(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.operator()(pt, level_set.msh, cl);
    }

    T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_grad_cont(pt, level_set.msh, cl);
    }

    T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_disc(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal_grad_cont(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal_disc(pt, level_set.msh, cl);
    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_disc_div_disc :
        public Level_set_berstein<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;
    size_t deg, grad_deg, div_deg;


    LS_cell_high_order_grad_disc_div_disc(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
        grad_deg = deg;
        div_deg = deg;
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_disc() = default;

    LS_cell_high_order_grad_disc_div_disc(const LS_cell_high_order_grad_disc_div_disc &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;
        grad_deg = other.grad_deg;
        div_deg = other.div_deg;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc(pt, level_set.msh, subcl);
        }

    }

    Eigen::Matrix<T, 2, 1> gradient_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc(pt, level_set.msh, cl_old);
        } else {
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }

    T divergence_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

    T divergence(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_disc(pt, level_set.msh, cl);
    }

    T divergence_disc(const point<T, 2> &pt, const cell_type &cl) {
// cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_disc(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal_disc(pt, level_set.msh, cl);
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt, const cell_type &cl) {
        return level_set.normal_disc(pt, level_set.msh, cl);
    }

};

/*
template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_disc_div_cont: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_disc_div_cont(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_cont()=default;

    LS_cell_high_order_grad_disc_div_cont(const LS_cell_high_order_grad_disc_div_cont& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};
*/


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_grad_cont_fast :
        public Level_set_berstein_high_order_interpolation_grad_cont_fast<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_grad_cont_fast(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_grad_cont_fast() = default;

    LS_cell_high_order_grad_cont_fast(const LS_cell_high_order_grad_cont_fast &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> normal_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> normal_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient(pt, level_set.msh, subcl);
        }

    }

/*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence(pt, level_set.msh, subcl);
        }
    }

    T divergence_cont(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont(pt, level_set.msh, subcl);
        }
    }

    T divergence_disc(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc(pt, level_set.msh, subcl);
        }
    }


/*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
// STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
        return normal(pt);
    }

    T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()(pt);
    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction, typename FiniteSpace>
struct LS_cell_high_order_fast :
        public Level_set_berstein_high_order_interpolation_fast<Mesh, Fonction, FiniteSpace, T> {

    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface;
    T radius;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_fast(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

    LS_cell_high_order_fast() = default;

    LS_cell_high_order_fast(const LS_cell_high_order_fast &other) {
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface = other.iso_val_interface;
        radius = other.radius;

    }

    T operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
/// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
//std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal(pt, level_set.msh, subcl);
        }
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient(pt, level_set.msh, subcl);
        }

    }


    T divergence(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {
//std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence(pt, level_set.msh, subcl);
        }
    }


// STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout << "Ho messo normal_disc anzichè normal!" << std::endl;
        return normal(pt);
    }

    T operator()(const point<T, 2> &pt, const cell_type &cl) {
//agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()(pt);
    }


};


template<typename T, typename Mesh, typename Fonction>
struct projected_level_set :
        public level_set<T> {
    std::vector <T> values;
    Eigen::Matrix <T, Dynamic, Dynamic> values_bis; // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh
    std::vector <size_t> boundary_cells;
// In the case in which I use FEM with Qk , k>1 I need another vector for all the values in each node

    size_t degree_FEM;
    size_t number_elements;
    Mesh msh;
    size_t Nx, Ny;
    mesh_init_params <T> params;
    size_t last_row_init, last_row_end, number_faces_one_row;
//  size_t counter_cell , counter_face, num_cell_row;

    T phi_max, phi_min;
    T cut_level;


    projected_level_set(const Fonction &level_set, const Mesh &msh, size_t degree_k, const mesh_init_params <T> &params)
            : number_elements((degree_k + 1) * (degree_k + 1)), msh(msh), degree_FEM(degree_k), Nx(params.Nx),
              Ny(params.Ny), params(params) {

        last_row_init = Ny * (2 * Nx + 1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx - 1;
        number_faces_one_row = 2 * Nx +
                               1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(((Nx + 1) * (Ny + 1)), 1);

//#ifdef NODES
// MATRIX NOTATION
        values_bis = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
// VECTOR NOTATION
//values_bis1= Eigen::Matrix<T, Dynamic, 1>::Zero(number_elements*msh.cells.size(), 1 );

//std::cout<<"Number of cells "<<msh.cells.size()<<std::endl;

// MATRIX NOTATION
// std::cout<<"Dimension of the basis "<<values_bis.size()<<std::endl;
// VECTOR NOTATION
// std::cout<<"Dimension of the basis "<<values_bis1.size()<<std::endl;
        size_t i_global = 0, i_local = 0, i_vertex = 0;
        for (auto &cl: msh.cells) {
/*
            bool boundary_bool = FALSE;
            for (auto& fc:faces(msh,cl)) {
                if (boundary_bool)
                    break;

                if(fc.is_boundary && !boundary_bool){
                    boundary_cells.push_back(offset(msh,cl));
                    boundary_bool = TRUE;
                }
            }
            */

            auto qps = equidistriduted_nodes<T, Mesh>(msh, cl, degree_FEM);
            i_local = 0;
            for (const auto &qp: qps) {

                values.push_back(level_set(qp)); // I DONT KNOW IF IT IS USEFUL

// if (boundary_bool) {
//      values_bis(i_local,i_global) = 1 ;  // MATRIX NOTATION
// }
                values_bis(i_local, i_global) = level_set(qp);  // MATRIX NOTATION
//values_bis1(i_local+i_global) = level_set(qp) ; // VECTOR NOTATION
                i_vertex = i_global + floor(i_global / Nx);
                if (i_local == 0)
                    vertices(i_vertex) = level_set(qp);

                if (i_local == 1)
                    vertices(i_vertex + 1) = level_set(qp);

                if (i_local == (degree_FEM + 2))
                    vertices(i_vertex + Nx + 2) = level_set(qp);

                if (i_local == (degree_FEM + 1))
                    vertices(i_vertex + Nx + 1) = level_set(qp);
                i_local++;
            }
            i_global++;  // MATRIX NOTATION
//  i_global+=number_elements;       // VECTOR NOTATION
        }
//#endif


    }

    projected_level_set() = default;


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        values_bis = values_new;
    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &vertices) {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols(); j++) {

            for (size_t i = 0; i < values_bis.rows(); i++) {
                auto i_vertex = j + floor(j / Nx);
                if (i == 0)
                    values_bis(i, j) = vertices(i_vertex);

                if (i == 1)
                    values_bis(i, j) = vertices(i_vertex + 1);

                if (i == (degree_FEM + 2))
                    values_bis(i, j) = vertices(i_vertex + Nx + 2);

                if (i == (degree_FEM + 1))
                    values_bis(i, j) = vertices(i_vertex + Nx + 1);
            }
        }

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values) {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols(); j++) {

            for (size_t i = 0; i < values_bis.rows(); i++) {
                auto i_vertex = j + floor(j / Nx);
                if (i == 0)
                    vertices(i_vertex) = values(i, j);

                if (i == 1)
                    vertices(i_vertex + 1) = values(i, j);

                if (i == (degree_FEM + 2))
                    vertices(i_vertex + Nx + 2) = values(i, j);

                if (i == (degree_FEM + 1))
                    vertices(i_vertex + Nx + 1) = values(i, j);
            }
        }

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    T operator()(const typename Mesh::node_type &node) const {
// Optimised to check the value of the level set only in the vertices
// std::cout<<"Value in vertices "<<vertices(node.ptid)<<", at position "<<node.ptid<<std::endl;
        return vertices(node.ptid);

    }


// OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    T operator()(const point<T, 2> &pt) const {
//std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter = 0;

// It looks for in what cell the point is
        for (const auto &cl: msh.cells) {
//std::cout<<"pt_in_cell operator in slow levelset"<<std::endl;
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
                return values_cell.dot(cb.eval_basis(pt));

// T tmp=0;
// for(auto i = 0; i<number_elements ; i++)
// {
//     tmp += (values.at(i+counter))*(cb.eval_basis(pt))[i];
// }
// return tmp;
            }
//counter+=number_elements; // OLD VERSION OF THE CODE
            counter += 1;
        }
        std::cout << "IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!" << std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
// Checking if cell is agglomerated or not
/*
        size_t cell_points = (points(msh,cl)).size();
        size_t cells_number = msh.cells.size();
        bool agglomeration=FALSE;
        if ( cells_number < (Nx*Ny-1) ) {
            agglomeration = TRUE;
        }
        if ( cells_number > (Nx*Ny-1) ) {
                  // throw std::logic_error("shouldn't have arrived here...");
               }
        */

//if(cell_points<5)
//{
// MATRIX NOTATION
//   if (!agglomeration) {
//       counter = offset(msh,cl);
//    }
//   else{
//       counter = 1;//cells_counter(msh_origin,msh,cl);
//   }

//std::cout<<"Value of offset "<<counter<<std::endl;
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;

// VECTOR NOTATION

//size_t counter = offset(msh,cl)*number_elements;
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
//auto values_cell = (values_bis1.segment(counter,number_elements));
//T tmp = values_cell.dot( cb.eval_basis(pt) );
//return tmp;
// }
/*
        else
        {
            std::vector<size_t> indices = subcell_finder<T,Mesh>(msh, pt , cl , params);
            cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM,indices);
            size_t counter = 1; // DA TROVAREEE!!!!!!!!!!!!!!!
            auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
            T tmp = values_cell.dot( cb.eval_basis(pt) );
            return tmp;
        }
        */


    }

// IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::face_type &fc) const {
// MATRIX NOTATION
        auto counter_face = offset(msh, fc);
        size_t counter_cell;
// da fc devo trovare la cella in cui sono per la base
//std::cout<<"Face number "<<counter_face<<std::endl;

// ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

// Check if I am in the last row, upper faces (ordered differently)
        if (counter_face >= last_row_init && counter_face <= last_row_end) {
            counter_cell = (Ny - 1) * Nx + counter_face % (last_row_init);
        } else {
// Find in what row the face is
            auto num_cell_row = floor(counter_face / (number_faces_one_row));
            if (counter_face != ((2 * Nx) * (num_cell_row + 1) + num_cell_row)) {
// Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor((counter_face - num_cell_row) / 2.0);
            } else {
// Face on the right boudary,
                counter_cell = (num_cell_row + 1) * Nx - 1;
            }

        }
//std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell = (values_bis.block(0, counter_cell, number_elements, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;


    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;

        ret = gradient(pt);
        return ret / ret.norm();
    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
        size_t counter = 0;
//std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for (const auto &cl: msh.cells) {
// std::cout<<"pt_in_cell gradient in slow levelset"<<std::endl;
            if (pt_in_cell<T, Mesh>(msh, pt, cl)) {
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);

                auto values_cell = values_bis.col(counter);
                auto grad_eval = cb.eval_gradients(pt);
                ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot(grad_eval.col(1));

                return ret;
            }
//counter+=number_elements; // OLD VERSION OF THE CODE
            counter += 1;

        }
        std::cout << "Se compare questo problema in gradient()" << std::endl;
        ret(0) += 1e10;
        ret(1) += 1e10;
        return ret; //to check if doesn't enter in the loop

    }


    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
//std::cout<<"the cell in NEW is the number "<<counter<<std::endl;
//std::cout<<"Value of offset "<<counter<<std::endl;
//cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell = values_bis.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

// VECTOR NOTATION

//size_t counter = offset(msh,cl)*number_elements;
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
//auto values_cell = (values_bis1.segment(counter,number_elements));
//T tmp = values_cell.dot( cb.eval_basis(pt) );
//return tmp;


    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }


// template<typename T , typename MATRIX , typename VECTOR >
    void smooth_cut_off(T C, T x_centre, T y_centre, T radius) {
        T hx = params.hx();
        T hy = params.hy();
        cut_level = C;
// T r0 = radius + 2*sqrt(pow(hx,2) + pow(hy,2)); // check value
//T r0 = radius + 2.5*std::max(hx , hy ); // check value
//T r0 = radius + 2.5*0.0625; // check value
        T pos_r0 = 0.45; //std::min(x_centre , 1 - x_centre );
// IF I wanna define like that I need to pass the value all'inizio, sennò cambia per valure le exact solution (cambiando x_centre).

//T max_r0 = pos_r0-(pos_r0 - 2*0.0625); //2.5*std::max(hx,hy); // if mesh too much coarse
//r0 = std::max(r0 , max_r0);
//r0 = 0.25*max_r0 + 0.75*r0 ;
//if(r0<radius)
//  r0 += 0.0625 ;
        T dist = pos_r0 - radius + 2 * 0.0625;
        T r0 = radius + dist / 2;
        T delta = r0 / 8;
//T delta = 0.0625 ; // r0/20.0; // or better std::max(hx,hy) ??
//T delta = sqrt(pow(hx,2) + pow(hy,2));
//if(std::abs(r0-delta-radius)<2*std::max(hx,hy) )
//   delta = delta/2;

        std::cout << "radius = " << radius << " , r0 = " << r0 << " , delta = " << delta << " , hx = hy = " << hx
                  << std::endl;
        std::cout << "value in alfa in r_int = " << (radius - r0) / delta << std::endl;
        std::cout << "value in alfa in R = " << (pos_r0 - r0) / delta << std::endl;
        auto alfa = [x_centre, y_centre, delta, r0](const typename Mesh::point_type &pt) { // sol
            return (1 - tanh((sqrt(pow((pt.x() - x_centre), 2) + pow((pt.y() - y_centre), 2)) - r0) / delta)) / 2;
        };

        size_t counter = 0;
// Eigen::Matrix<T, Dynamic, 1> tmp_vert = Matrix<T, Dynamic, 1>::Zero(vertices.rows(), 1); ;
        for (auto &pt: msh.points) {
// std::cout<<"the point is "<< pt<<" alfa is "<<alfa(pt)<<std::endl;
            vertices(counter) = (1 - alfa(pt)) * C + alfa(pt) * vertices(counter);
            counter++;
        }

        converting_into_HHO_formulation(vertices);
        phi_max = vertices.maxCoeff();
        phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?

        postprocess_output<double> postoutput00;
//typedef typename Mesh::point_type       point_type;
        point<double, 2> node;
        auto alfa_values = std::make_shared < gnuplot_output_object < double > > ("alfa.dat");
//auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for (auto &pt: msh.points) {
            alfa_values->add_data(pt, alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();
    }


// template<typename T , typename MATRIX , typename VECTOR >
    void cut_off(T d) {
//auto vertices_abs = vertices.cwiseAbs();
//auto phi_max_abs = d*vertices_abs.maxCoeff();
//std::cout<<"MAX VALUE OF PHI ABS"<<phi_max_abs<<std::endl;

        cut_level = d;
//std::cout<<"CUTTING AT d = "<<d<<std::endl;
        T level_set_max = vertices.maxCoeff();
//std::cout<<"MAX VALUE OF PHI BEFORE CUTTING = "<<level_set_max<<std::endl;
//assert(degree_FEM == 1)

        Eigen::Matrix <T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(),
                                                                                               values_bis.cols()); // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
        Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones(vertices.rows(),
                                                                                  1); // saving level_set on vertices mesh


        auto cut_off_level_vec = d * One_vec;
        auto cut_off_level_mat = d * One_mat;

        vertices /= (level_set_max);
        values_bis /= (level_set_max);
// std::cout<<"MAX VALUE OF NORMALISED PHI = "<<vertices.maxCoeff()<<std::endl;
        auto vertices_prova = vertices;
        auto values_bis_prova = values_bis;

        vertices = vertices.cwiseMin(cut_off_level_vec);
        values_bis = values_bis.cwiseMin(cut_off_level_mat);
// Cut off also in inner domain
        vertices = vertices.cwiseMax(-cut_off_level_vec);
        values_bis = values_bis.cwiseMax(-cut_off_level_mat);

// NOT NORMALISED CUT
//vertices = vertices.cwiseMin(cut_off_level_vec*level_set_max);
//values_bis = values_bis.cwiseMin(cut_off_level_mat*level_set_max);


        phi_max = vertices.maxCoeff();
        phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?
//std::cout<<"MAX VALUE OF PHI_CUT AND NORMALISED = "<<phi_max<<std::endl;
        std::cout << "Cut at " << phi_max << " , MIN VALUE OF PHI_CUT AND NORMALISED = " << phi_min
                  << " (NEGATIVE cut off ACTIVED)." << std::endl;

/*
        postprocess_output<double> postoutput2;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto test_activated_nodes = std::make_shared< gnuplot_output_object<double> >("test_activated_nodes.dat");
        auto test_before_cut_off = std::make_shared< gnuplot_output_object<double> >("test_before_cut_off.dat");

        for (size_t i = 0; i<vertices_prova.rows(); i++) {
            node = msh.points.at(i);
            test_before_cut_off->add_data(node,vertices_prova(i));

            if( std::abs(vertices_prova(i) - vertices(i))>1e-10 )
                vertices_prova(i) = 1;
            else
                vertices_prova(i) = 0;
            test_activated_nodes->add_data(node,vertices_prova(i));


        }


        for (size_t j = 0; j<values_bis.cols(); j++)
        {
            bool active_cell= FALSE;
            size_t i = 0;
            while (i<values_bis.rows() && !active_cell ) {
                if( values_bis_prova(i,j)!= values_bis(i,j) ){
                    active_cell = TRUE;
                //std::cout<<"values_bis_prova(i,j)= "<<values_bis_prova(i,j)<<" , values_bis(i,j)= "<<values_bis(i,j)<<std::endl;
              //  std::cout<<" the cell num "<<j<<" is active."<<std::endl;
                }
                i++;
            }
        }



        postoutput2.add_object(test_before_cut_off);
        postoutput2.add_object(test_activated_nodes);
        postoutput2.write();
        */
/*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

    }

    void boundary_con(T d) {
        T level_set_max = vertices.maxCoeff();
        std::cout << "MAX VALUE OF PHI" << level_set_max << std::endl;
//assert(degree_FEM == 1)

        Eigen::Matrix <T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(),
                                                                                               values_bis.cols()); // MATRIX NOTATION
//Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
        Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones(vertices.rows(),
                                                                                  1); // saving level_set on vertices mesh


        auto cut_off_level_vec = d * One_vec;
        auto cut_off_level_mat = d * One_mat;

        vertices /= (level_set_max);
        values_bis /= (level_set_max);
        vertices = vertices.cwiseMin(cut_off_level_vec);
        values_bis = values_bis.cwiseMin(cut_off_level_mat);
/*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

    }


};


template<typename T>
class velocity_field {
public:
    virtual Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
    }

/*
     virtual Eigen::Matrix<T,2,1> flux(const point<T,2>& pt) const
    {
    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }
    */

};

template<typename T>
class velocity_field_pair {
public:
    virtual std::pair <T, T> operator()(const point<T, 2> &pt) const {
    }

/*
     virtual Eigen::Matrix<T,2,1> flux(const point<T,2>& pt) const
    {
    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }
    */

};


template<typename T>
struct rotational_velocity_field :
        public velocity_field<T> {
    T u1, xc, yc;

    rotational_velocity_field(T u1)
            : u1(u1) {
    }

    rotational_velocity_field(T xc, T yc, T u1)
            : u1(u1), xc(xc), yc(yc) {
    }

    Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret(0) = (u1 * pt.y() - xc) / xc;
        ret(1) = (-u1 * pt.x() + yc) / yc;

        return ret;
    }


};

template<typename T>
struct linear_velocity_field :
        public velocity_field<T> {
    T u1, u2, u3, u4;

    linear_velocity_field(T u1, T u2, T u3, T u4)
            : u1(u1), u2(u2), u3(u3), u4(u4) {
    }

    Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret(0) = u1 * pt.x() + u2;
        ret(1) = u3 * pt.y() + u4;

        return ret;
    }
/*
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret(0) = 2*pt.x() - 2*alpha;
        ret(1) = 2*pt.y() - 2*beta;
        return ret;
    }
    */
};


template<typename T>
struct taylor_green_vortex :
        public velocity_field<T> {
    T viscosity = 2.0;
    T time = 0.0;
    T b = 1.0;
    T F = b * std::exp(-2 * viscosity * time);
    bool old_tgv = true;

    taylor_green_vortex(T a, bool old_tgv) : viscosity(a), old_tgv(old_tgv) {};

    taylor_green_vortex(T a, bool old_tgv, T b) : viscosity(a), old_tgv(old_tgv), b(b) {};

    taylor_green_vortex() {};

    taylor_green_vortex(T a) : viscosity(a) {};

    Eigen::Matrix<T, 2, 1> operator()(const point<T, 2> &pt) const {
        Eigen::Matrix<T, 2, 1> ret;

        if (old_tgv) {
            ret(0) = std::cos(2 * M_PI * pt.x()) * std::sin(2 * M_PI * pt.y()) * F;
            ret(1) = -std::sin(2 * M_PI * pt.x()) * std::cos(2 * M_PI * pt.y()) * F;
        } else {
            ret(0) = std::sin(2 * M_PI * pt.x()) * std::cos(2 * M_PI * pt.y()) * F;
            ret(1) = -std::cos(2 * M_PI * pt.x()) * std::sin(2 * M_PI * pt.y()) * F;
        }
        return ret;
    }

    void
    set_time(T new_time) {
        time = new_time;
        F = b * std::exp(-2 * viscosity * time);

    }


};


template<typename Mesh, typename Fonction, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct projection_velocity_high_order :
        public velocity_field_pair<T> {

    size_t last_row_init, last_row_end, number_faces_one_row;


// NEW IMPLEMENTATION STUFF
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton
// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    T u_max0, u_max1;


//SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
//Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
//Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
//std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

    std::pair <Eigen::Matrix<T, Dynamic, Dynamic>, Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO; // projection saved in HHO format: cell by cell
    std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> sol_FEM; // projection saved in Continuos FE format: global nodes
//std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh


// AGGLOMERATED MESHES DATA:
    typedef typename Mesh::cell_type cell_type;
    Mesh agglo_msh;
    std::vector <cell_type> subcells;
    cell_type agglo_LS_cl;

    projection_velocity_high_order(const FiniteSpace &fe_data, const Mesh &msh)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
        std::cout << "STO USANDO: equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)" << std::endl;
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
        sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

        sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                 Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));


    }

    projection_velocity_high_order(const FiniteSpace &fe_data, const Fonction &u, const Mesh &msh)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

// Saving the projection in HHO discontinuous format (MATRIX NOTATION)
//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
        sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

        sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                 Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));


        size_t i_global = 0, i_local = 0; //, i_vertex=0;
        for (auto &cl: msh.cells) {
            auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree_FEM);
            i_local = 0;
            for (const auto &qp: qps) {
                auto asm_map = connectivity_matrix[i_global][i_local].first;
                auto u0 = (u(qp))(0);
                auto u1 = (u(qp))(1);

                sol_HHO.first(i_local, i_global) = u0;
                sol_HHO.second(i_local, i_global) = u1;
                sol_FEM.first(asm_map) = u0;
                sol_FEM.second(asm_map) = u1;
/*
                i_vertex = i_global+floor(i_global/Nx);
                if( i_local==0 ){
                    vertices.first(i_vertex) = u0 ;
                    vertices.second(i_vertex) = u1 ;
                }

                if( i_local==1 ){
                    vertices.first(i_vertex+1) = u0 ;
                    vertices.second(i_vertex+1) = u1 ;
                }

                if( i_local==(degree_FEM+2) ){
                    vertices.first(i_vertex+Nx+2) = u0 ;
                    vertices.second(i_vertex+Nx+2) = u1 ;
                }

                if( i_local==(degree_FEM+1) ){
                    vertices.first(i_vertex+Nx+1) = u0 ;
                    vertices.second(i_vertex+Nx+1) = u1 ;
                }
            */

                i_local++;


            }
            i_global++;


        }

    }


    void set_agglo_mesh(Mesh &m_agglo_msh) {
        agglo_msh = m_agglo_msh;
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(msh.cells[offset_subcells]);

            }
        }

    }

    template<typename MATRIX>
    void set_discrete_points(MATRIX &values_new) {
        sol_HHO = values_new;
        std::cout << " Using set_discrete_points check that sol_FEM already uploaded!" << std::endl;

    }

    template<typename VECTOR>
    void converting_into_HHO_formulation(const VECTOR &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = values_new.first(asm_map);
                sol_HHO.second(i, counter_bis) = values_new.second(asm_map);
            }
//  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
// vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        std::cout << " Using converting_into_HHO_formulation check that sol_FEM already uploaded!" << std::endl;
//set_max_min();
//phi_min = sol_HHO.minCoeff() ;
//phi_max = sol_HHO.maxCoeff() ;

    }

    template<typename MATRIX>
    void converting_into_FE_formulation(const MATRIX &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM.first(asm_map) = values_new.first(i, counter_bis);
                sol_FEM.second(asm_map) = values_new.second(i, counter_bis);
            }
//  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
// vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        std::cout << " Using converting_into_FE_formulation check that sol_HHO already uploaded!" << std::endl;
//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

    }

    template<typename LEVEL_SET, typename TRANSPORT_METHOD>
    void L2_proj_into_FE_formulation(LEVEL_SET &level_set, const Mesh &msh, const TRANSPORT_METHOD &method) {
        std::cout << "L2 projection to have CONTINUOUS FE: SimplicialLLT to invert global Mass Matrix." << std::endl;
        timecounter tc_vel;
        tc_vel.tic();
        Matrix<T, Dynamic, 1> RHS1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        Matrix<T, Dynamic, 1> RHS2 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);

        for (auto cl: msh.cells) {
            auto local_RHS = make_bernstein_local_RHS_VEC(msh, cl, degree_FEM, *this);
            size_t cell_offset = offset(msh, cl);
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                RHS1(asm_map_i) += local_RHS.first(i);
                RHS2(asm_map_i) += local_RHS.second(i);
            }

        }
        sol_FEM.first = solver_global_mass.solve(RHS1);
        sol_FEM.second = solver_global_mass.solve(RHS2);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }

        tc_vel.toc();
//std::cout<<"Time to L2 project velocity field : "<<tc_vel<<std::endl;
    }

    template<typename MATRIX>
    void smooth_converting_into_FE_formulation(const MATRIX &values_new) {
        std::cout << "SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."
                  << std::endl;
        Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sum_first(asm_map) += values_new.first(i, counter_bis);
                sum_second(asm_map) += values_new.second(i, counter_bis);
                counting_avg(asm_map)++;
            }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
        sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
        std::cout
                << "In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"
                << std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

    }


    std::pair <T, T> operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree_FEM);
//std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0, counter, local_dim, 1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0, counter, local_dim, 1)).col(0);
//std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
//std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
        T tmp2 = values_cell_second.dot(cb.eval_basis(pt));
//std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1, tmp2);
    }

    std::pair <T, T> operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {

            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = msh.cells[offset_old];

            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl_old, degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0, offset_old, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, offset_old, local_dim, 1)).col(0);

            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

            return std::make_pair(tmp1, tmp2);

        } else {
//            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
            auto offset = pt_in_subcell(msh, pt, agglo_LS_cl);
            auto subcl = msh.cells[offset];

            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, subcl, degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0, offset, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, offset, local_dim, 1)).col(0);

            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

            return std::make_pair(tmp1, tmp2);

        }

    }


};


template<typename Mesh, typename T = typename Mesh::coordinate_type>
struct velocity_HHO {


// NEW IMPLEMENTATION STUFF
    Mesh msh; // Original mesh, NOT agglomerated.

    size_t n_cls; // #cells
    size_t local_dim;

    Matrix <T, Dynamic, Dynamic> vel_global_n, vel_global_p, vel_global;


// AGGLOMERATED MESHES DATA:
    typedef typename Mesh::cell_type cell_type;
    Mesh agglo_msh;
    std::vector <cell_type> subcells;
    cell_type agglo_LS_cl;

    velocity_HHO() = default;

    velocity_HHO(const velocity_HHO &other) {
        msh = other.msh;
        n_cls = other.n_cls;
        local_dim = other.local_dim;
        vel_global_n = other.vel_global_n;
        vel_global_p = other.vel_global_p;
        vel_global = other.vel_global;
        agglo_msh = other.agglo_msh;
        subcells = other.subcells;
        agglo_LS_cl = other.agglo_LS_cl;
    }

    velocity_HHO(const Mesh &msh, const hho_degree_info &di)
            : msh(msh), n_cls(msh.cells.size()) {
        const auto celdeg = di.cell_degree();
        local_dim = vector_cell_basis<Mesh, T>::size(celdeg);
        vel_global_n = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        vel_global_p = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        vel_global = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);


    }

    void set_agglo_mesh(const Mesh &m_agglo_msh) {
        agglo_msh = m_agglo_msh;
        n_cls = agglo_msh.cells.size();
        vel_global_n = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        vel_global_p = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        vel_global = Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
//        vel_global_n.resize(local_dim, n_cls) ;
//        vel_global_p.resize(local_dim, n_cls) ;
//        vel_global.resize(local_dim, n_cls) ;
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(msh.cells[offset_subcells]);

            }
        }

    }



/*
    std::pair<T,T> operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl) const
    {
        size_t counter = offset(msh,cl) ;
        cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        //std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0,counter,local_dim,1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0,counter,local_dim,1)).col(0);
        //std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
        //std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
        T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );
        //std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1,tmp2);
    }


    //  OPERATOR for MESH AGGLOMERATED
    std::pair<T,T> operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {

            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = msh.cells[offset_old];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl_old , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset_old,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset_old,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }
        else
        {
            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
            auto subcl = msh.cells[offset];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, subcl , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }

    }
    */

};


template<typename Mesh, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
struct velocity_high_order {

    size_t last_row_init, last_row_end, number_faces_one_row;


// NEW IMPLEMENTATION STUFF
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params <T> params; // mesh parameter

    size_t degree_FEM; // FEM degree
    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices
    size_t Nx, Ny; // Number of cells in x and y direciton
// connectivity matrix : for each cell, it stores the global numbering
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;
//std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    T u_max0, u_max1;


//SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
//Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
//Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
//std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

    std::pair <Eigen::Matrix<T, Dynamic, Dynamic>, Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO; // projection saved in HHO format: cell by cell
    std::pair <Matrix<T, Dynamic, 1>, Matrix<T, Dynamic, 1>> sol_FEM; // projection saved in Continuos FE format: global nodes
//std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh

// std::vector<T> weightsArea ;
    Eigen::Matrix<T, Dynamic, 1> weightsArea;

// AGGLOMERATED MESHES DATA:
    typedef typename Mesh::cell_type cell_type;
    Mesh agglo_msh;
    std::vector <cell_type> subcells;
    cell_type agglo_LS_cl;


    velocity_high_order(const FiniteSpace &fe_data, const Mesh &msh)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
//std::cout<<"velocity_high_order: -> implemented with equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)"<<std::endl;
//last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
//last_row_end = last_row_init + Nx-1;
//number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


//vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
        sol_FEM = std::make_pair(Matrix<T, Dynamic, 1>::Zero(ndof_FE), Matrix<T, Dynamic, 1>::Zero(ndof_FE));

        sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls),
                                 Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls));

        weightsArea = Eigen::Matrix<T, Dynamic, 1>::Zero(n_cls, 1);

    }

    void set_agglo_mesh(Mesh &m_agglo_msh) {
        agglo_msh = m_agglo_msh;
    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;

        if ((agglo_LS_cl.user_data.offset_subcells.size() > 1) &&
            (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1])) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(msh.cells[offset_subcells]);

            }
        }

    }


    template<typename MATRIX>
    void set_discrete_points(MATRIX &values_new) {
        sol_HHO = values_new;
        std::cout << " Using set_discrete_points: sol_FEM has to be already uploaded!" << std::endl;

    }

    void set_weight_area(size_t posCell, T w) {
        weightsArea(posCell) = 1.0 / w;
    }

    template<typename VECTOR>
    void converting_into_HHO_formulation(const VECTOR &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = values_new.first(asm_map);
                sol_HHO.second(i, counter_bis) = values_new.second(asm_map);
            }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
//        std::cout<<" Using converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;
//set_max_min();
//phi_min = sol_HHO.minCoeff() ;
//phi_max = sol_HHO.maxCoeff() ;

    }

    template<typename MATRIX>
    void converting_into_FE_formulation(const MATRIX &values_new) {

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM.first(asm_map) = values_new.first(i, counter_bis);
                sol_FEM.second(asm_map) = values_new.second(i, counter_bis);
            }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }

//std::cout<<"Using converting_into_FE_formulation: sol_FEM has to be already uploaded!"<<std::endl;
//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

    }

    template<typename LEVEL_SET, typename TRANSPORT_METHOD>
    void L2_proj_into_FE_formulation(LEVEL_SET &level_set, const Mesh &msh, const TRANSPORT_METHOD &method) {
        std::cout << "L2 projection to have CONTINUOUS FE: SimplicialLLT to invert global Mass Matrix." << std::endl;
        timecounter tc_vel;
        tc_vel.tic();
        Matrix<T, Dynamic, 1> RHS1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        Matrix<T, Dynamic, 1> RHS2 = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        SimplicialLLT <SparseMatrix<T>> solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);

        for (auto cl: msh.cells) {
            auto local_RHS = make_bernstein_local_RHS_VEC(msh, cl, degree_FEM, *this);
            size_t cell_offset = offset(msh, cl);
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map_i = connectivity_matrix[cell_offset][i].first;
                RHS1(asm_map_i) += local_RHS.first(i);
                RHS2(asm_map_i) += local_RHS.second(i);
            }

        }
        sol_FEM.first = solver_global_mass.solve(RHS1);
        sol_FEM.second = solver_global_mass.solve(RHS2);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }

        tc_vel.toc();
//std::cout<<"Time to L2 project velocity field : "<<tc_vel<<std::endl;
    }

    template<typename MATRIX>
    void smooth_converting_into_FE_formulation(const MATRIX &values_new) {
//        std::cout<<"SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."<<std::endl;
        Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sum_first(asm_map) += values_new.first(i, counter_bis);
                sum_second(asm_map) += values_new.second(i, counter_bis);
                counting_avg(asm_map)++;
            }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
        sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
//        std::cout<<"In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

    }


    template<typename MATRIX>
    void weight_converting_into_FE_formulation(const MATRIX &values_new) {
//        std::cout<<"SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."<<std::endl;
        Array<T, Dynamic, 1> counting_avg = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_first = Array<T, Dynamic, 1>::Zero(ndof_FE);
        Array<T, Dynamic, 1> sum_second = Array<T, Dynamic, 1>::Zero(ndof_FE);
//std::array<T, ndof_FE > counting_avg;
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            T wLoc = weightsArea(counter_bis);

            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sum_first(asm_map) += wLoc * values_new.first(i, counter_bis);
                sum_second(asm_map) += wLoc * values_new.second(i, counter_bis);
                counting_avg(asm_map) += wLoc;
            }
//size_t i_vertex = counter_bis+floor(counter_bis/Nx);
//vertices(i_vertex) = sol_HHO(0,counter_bis) ;
//vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
//vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
//vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
        sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO.first(i, counter_bis) = sol_FEM.first(asm_map);
                sol_HHO.second(i, counter_bis) = sol_FEM.second(asm_map);
            }

        }
//std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
//        std::cout<<"In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

//set_max_min();
//phi_min = sol_FEM.minCoeff() ;
//phi_max = sol_FEM.maxCoeff() ;

    }


    std::pair <T, T> operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl, degree_FEM);
//std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0, counter, local_dim, 1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0, counter, local_dim, 1)).col(0);
//std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
//std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
        T tmp2 = values_cell_second.dot(cb.eval_basis(pt));
//std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1, tmp2);
    }


//  OPERATOR for MESH AGGLOMERATED
    std::pair <T, T> operator()(const point<T, 2> &pt) const {

        if (subcells.size() < 1) {

            assert(agglo_LS_cl.user_data.offset_subcells.size() == 2);
            assert(agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1]);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = msh.cells[offset_old];

            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, cl_old, degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0, offset_old, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, offset_old, local_dim, 1)).col(0);

            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

            return std::make_pair(tmp1, tmp2);

        } else {
//            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
            auto offset = pt_in_subcell(msh, pt, agglo_LS_cl);
            auto subcl = msh.cells[offset];

            cell_basis_Lagrangian_ordered<Mesh, T> cb(msh, subcl, degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0, offset, local_dim, 1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0, offset, local_dim, 1)).col(0);

            T tmp1 = values_cell_first.dot(cb.eval_basis(pt));
            T tmp2 = values_cell_second.dot(cb.eval_basis(pt));

            return std::make_pair(tmp1, tmp2);

        }

    }


    void upload_velocity(const std::string &filename_FEM0, const std::string &filename_FEM1) {
        size_t counter_FEM = 0;

        std::ifstream file_FEM0;
        file_FEM0.open(filename_FEM0, std::ios::in | std::ios::out);
        if (!file_FEM0.is_open()) {
            exit(10);
        }

        while (!file_FEM0.eof()) {
            if (counter_FEM < sol_FEM.first.size()) {
                T val;
                file_FEM0 >> val;
                sol_FEM.first(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM0.close();



// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO.first(i, counter_HHO) = sol_FEM.first(asm_map);
            }
        }


        counter_FEM = 0;

        std::ifstream file_FEM1;
        file_FEM1.open(filename_FEM1, std::ios::in | std::ios::out);
        if (!file_FEM1.is_open()) {
            exit(10);
        }

        while (!file_FEM1.eof()) {
            if (counter_FEM < sol_FEM.second.size()) {
                T val;
                file_FEM1 >> val;
                sol_FEM.second(counter_FEM) = val;

                counter_FEM++;
//std::cout<<val <<" , " ;
            } else
                break;

        }
        std::cout << std::endl;
        file_FEM1.close();



// Uploading also sol_HHO
        for (size_t counter_HHO = 0; counter_HHO < n_cls; counter_HHO++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_HHO][i].first;
                sol_HHO.second(i, counter_HHO) = sol_FEM.second(asm_map);
            }
        }


    }


};


template<typename Mesh>
struct Current_Mesh {
    Mesh current_mesh;

    Current_Mesh(const Mesh &msh) : current_mesh(msh) {
    }

    void set_current_mesh(const Mesh &msh) {
        current_mesh = msh;
    }


};


template<typename T, typename Mesh, typename Level_Set, typename Fonction>
struct LS_cell :
        public projected_level_set<T, Mesh, Fonction> {
    typedef typename Mesh::cell_type cell_type;
    cell_type agglo_LS_cl;
    std::vector <cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;

//LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
// : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
// I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell(const Level_Set &level_set_, const Mesh &msh)
            : agglo_msh(msh), level_set(level_set_) {
    }
//LS_cell(const Level_Set & level_set )
//: level_set(level_set){}

//LS_cell()=default;

    T operator()(const point<T, 2> &pt) const {
        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set(pt, level_set.msh, cl_old);
        } else {
//std::cout<<"Ls operator"<<std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set(pt, level_set.msh, subcl);
        }

    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt) const {
        if (subcells.size() < 1) {
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal(pt, level_set.msh, cl_old);
        } else {

            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal(pt, level_set.msh, subcl);
        }
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt) const {
        if (subcells.size() < 1) {
            std::cout << "I m here 2.5 and size is " << agglo_LS_cl.user_data.offset_subcells.size() << std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size() == 1);
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient(pt, level_set.msh, cl_old);
        } else {
            std::cout << "Ls gradient" << std::endl;
            auto offset = pt_in_subcell(level_set.msh, pt, agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient(pt, level_set.msh, subcl);
        }

    }

    void cell_assignment(const cell_type &cl) {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size() > 1) {

            for (auto &offset_subcells: agglo_LS_cl.user_data.offset_subcells) {
                subcells.push_back(level_set.msh.cells[offset_subcells]);

            }
        }

    }

    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const cell_type &cl) {
        agglo_LS_cl = cl;
        return normal(pt);
    }

    T operator()(const point<T, 2> &pt, const cell_type &cl) {
        agglo_LS_cl = cl;
        return operator()(pt);
    }


//  void get_cell()
//  {
//      auto crr_cl = download_current_cell();
//      std::cout<<"IN get_cell.. size cell "<<crr_cl.user_data.offset_subcells.size()<<std::endl;
//      this->cell_assignment(crr_cl);
//   }

};


/**************MOVING INTERFACE: LEVEL SET METHOD  **************/

template<typename T, typename Mesh>
struct projection {
    Eigen::Matrix <T, Dynamic, Dynamic> values_bis;
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    size_t degree_FEM;
    size_t number_elements;
    Mesh msh;
    size_t Nx, Ny;
    mesh_init_params <T> params;
//size_t  last_row_init, last_row_end, number_faces_one_row;

    projection(const Mesh &msh, size_t degree_k, const mesh_init_params <T> &params)
            : number_elements((degree_k + 1) * (degree_k + 1)), msh(msh), degree_FEM(degree_k), Nx(params.Nx),
              Ny(params.Ny), params(params) {
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(((Nx + 1) * (Ny + 1)), 1);
        values_bis = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
    }

    projection() = default;


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        values_bis = values_new;
    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &vertices) {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols(); j++) {

            for (size_t i = 0; i < values_bis.rows(); i++) {
                auto i_vertex = j + floor(j / Nx);
                if (i == 0)
                    values_bis(i, j) = vertices(i_vertex);

                if (i == 1)
                    values_bis(i, j) = vertices(i_vertex + 1);

                if (i == (degree_FEM + 2))
                    values_bis(i, j) = vertices(i_vertex + Nx + 2);

                if (i == (degree_FEM + 1))
                    values_bis(i, j) = vertices(i_vertex + Nx + 1);
            }
        }

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values) {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols(); j++) {

            for (size_t i = 0; i < values_bis.rows(); i++) {
                auto i_vertex = j + floor(j / Nx);
                if (i == 0)
                    vertices(i_vertex) = values(i, j);

                if (i == 1)
                    vertices(i_vertex + 1) = values(i, j);

                if (i == (degree_FEM + 2))
                    vertices(i_vertex + Nx + 2) = values(i, j);

                if (i == (degree_FEM + 1))
                    vertices(i_vertex + Nx + 1) = values(i, j);
            }
        }

    }


    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);
    }

    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell = (values_bis.block(0, counter, number_elements, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree_FEM);
        auto values_cell = values_bis.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
        ret(1) = values_cell.dot(grad_eval.col(1));
        return ret;
    }


    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }

};


template<typename T>
void positive_part(Eigen::Matrix <T, Dynamic, Dynamic> &mat) {
    for (size_t i = 0; i < mat.rows(); i++) {
        for (size_t j = 0; j < mat.cols(); j++) {
            if (mat(i, j) < 0)
                mat(i, j) = 0.;
        }
    }

}





/*

template <typename T>
Eigen::Matrix<T, Dynamic, Dynamic> positive_part(const Eigen::Matrix<T, Dynamic, Dynamic>& mat) {
    //Eigen::Matrix<T, Dynamic, Dynamic> ret =mat;
    Eigen::Matrix<T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(mat.rows(), mat.cols());
    auto positive = mat.cwiseSign();
    std::cout<<"positive: "<<'\n'<<positive<<std::endl;
    for (size_t i = 0; i<mat.rows();i++) {
        for (size_t j = 0; j<mat.cols();j++) {
            if (positive(i,j)==-1) {
                ret(i,j) = 0;
            }
            //if( mat(i,j) < 0 )
            //    ret(i,j) = 0;
        }
    }
    return ret;
}
*/


//template <typename T> int sgn(T val) {
//    return (T(0) < val) - (val < T(0));
//}

template<typename T, typename Mesh>
class entropy {
public:
    virtual T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
    }

    virtual T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
    }

};


template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
struct entropy_flux_ANALYTIC_VEL {
    T eps;
    Fonction phi;
    Mesh msh;
    Vel_Field u;
    Entropy_func E;

    Eigen::Matrix<T, Dynamic, 1> values0, values1;

    entropy_flux_ANALYTIC_VEL(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(
            E_entropy), phi(phi), u(u), msh(msh) {
        eps = E.eps;
//        values0 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        values1 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
//        auto ret = E.E_values + std::log10(eps)*One ;
//        values0 = u.sol_FEM.first.cwiseProduct(ret);
//        values1 = u.sol_FEM.second.cwiseProduct(ret);
    }

    std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T ret = E(pt, cl) + std::log10(eps);
        return std::make_pair(u(pt)[0] * ret, u(pt)[1] * ret);
    }
};


template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
struct entropy_flux {
    T eps;
    Fonction phi;
    Mesh msh;
    Vel_Field u;
    Entropy_func E;

    Eigen::Matrix<T, Dynamic, 1> values0, values1;

    Eigen::Matrix <T, Dynamic, Dynamic> values0_HHO, values1_HHO;

    entropy_flux(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(E_entropy),
                                                                                                      phi(phi), u(u),
                                                                                                      msh(msh) {
        eps = E.eps;
        values0 = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        values1 = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);

        values0_HHO = Matrix<T, Dynamic, Dynamic>::Zero(u.local_dim, u.n_cls);
        values1_HHO = Matrix<T, Dynamic, Dynamic>::Zero(u.local_dim, u.n_cls);


        Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        auto ret = E.E_values + std::log10(eps) * One;
        values0 = u.sol_FEM.first.cwiseProduct(ret);
        values1 = u.sol_FEM.second.cwiseProduct(ret);

        Eigen::Matrix <T, Dynamic, Dynamic> One_Mat = Matrix<T, Dynamic, Dynamic>::Ones(u.local_dim, u.n_cls);
        auto ret_HHO = E.E_values_HHO + std::log10(eps) * One_Mat;

        values0_HHO = u.sol_HHO.first.cwiseProduct(ret_HHO);
        values1_HHO = u.sol_HHO.second.cwiseProduct(ret_HHO);
    }

    std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T ret = E(pt, cl) + std::log10(eps);
        return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
    }
};


template<typename Entropy_func, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
struct entropy_flux_generic {
    T eps;
    Mesh msh;
    Vel_Field u;
    Entropy_func E;


    entropy_flux_generic(Entropy_func &E_entropy, const Vel_Field &u, const Mesh &msh) : E(E_entropy), u(u), msh(msh) {
        eps = E.eps;

    }

    std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T ret = E(pt, cl) + std::log10(eps);
        auto u_pt = u(pt, msh, cl);
        return std::make_pair((u_pt.first) * ret, (u_pt.second) * ret);
    }
};


template<typename Entropy_func, typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
struct entropy_flux_quadratic {
    T eps;
    Fonction phi;
    Mesh msh;
    Vel_Field u;
    Entropy_func E;

    Eigen::Matrix<T, Dynamic, 1> values0, values1;

    entropy_flux_quadratic(Entropy_func &E_entropy, const Fonction &phi, const Vel_Field &u, const Mesh &msh) : E(
            E_entropy), phi(phi), u(u), msh(msh) {
        eps = E.eps;

//        values0 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        values1 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
//        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
        auto ret = E.E_values;
        values0 = u.sol_FEM.first.cwiseProduct(ret);
        values1 = u.sol_FEM.second.cwiseProduct(ret);
    }

    std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T ret = E(pt, cl);
        return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
    }
};


template<typename Entropy_func, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
struct entropy_flux_quadratic_piecewise {


    Mesh msh;
    Vel_Field u;
    Entropy_func E;


    entropy_flux_quadratic_piecewise(Entropy_func &E_entropy, const Vel_Field &u, const Mesh &msh) : E(E_entropy), u(u),
                                                                                                     msh(msh) {


    }

    std::pair <T, T> operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T ret = E(pt, cl);
        return std::make_pair((u(pt, msh, cl).first) * ret, (u(pt, msh, cl).second) * ret);
    }
};


template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy_new :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;
    Eigen::Matrix<T, Dynamic, 1> E_values, E_der;

    non_linear_entropy_new(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;
        E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Log10 *= std::log(10);

        E_values = -((((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).cwiseAbs() + eps * One).array().log10());

        E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        E_der = (-One.cwiseQuotient(
                (((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                        Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
        E_der = (E_der.array().cwiseProduct(((phi.sol_FEM).cwiseProduct(One - phi.sol_FEM)).array().sign()));
        E_der = (E_der.cwiseProduct(One - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;

    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs(f(pt, msh, cl) * (1 - f(pt, msh, cl))) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs(phi(pt, msh, cl) * (1 - phi(pt, msh, cl))) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1. / ((std::abs((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) + eps) * std::log(10)) *
               sgn((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) * (1 - 2 * phi(pt, msh, cl));
    }

};


template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy_new_phimin_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;
    Eigen::Matrix<T, Dynamic, 1> E_values, E_der;
    Eigen::Matrix <T, Dynamic, Dynamic> E_values_HHO, E_der_HHO;

    non_linear_entropy_new_phimin_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;
        E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Log10 *= std::log(10);
        Eigen::Matrix<T, Dynamic, 1> PHI_MAX = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> PHI_MIN = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        PHI_MAX *= phi_max;
        PHI_MIN *= phi_min;

        E_values = -((((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() +
                      eps * One).array().log10());

        E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        E_der = (-One.cwiseQuotient(
                (((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                        Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
        E_der = (E_der.array().cwiseProduct(
                ((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).array().sign()));
        E_der = (E_der.cwiseProduct(PHI_MAX + PHI_MIN - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;



        E_values_HHO = Matrix<T, Dynamic, Dynamic>::Zero(phi.local_dim, phi.n_cls);
        Eigen::Matrix <T, Dynamic, Dynamic> One_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
        Eigen::Matrix <T, Dynamic, Dynamic> Log10_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
        Log10_HHO *= std::log(10);
        Eigen::Matrix <T, Dynamic, Dynamic> PHI_MAX_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
        Eigen::Matrix <T, Dynamic, Dynamic> PHI_MIN_HHO = Matrix<T, Dynamic, Dynamic>::Ones(phi.local_dim, phi.n_cls);
        PHI_MAX_HHO *= phi_max;
        PHI_MIN_HHO *= phi_min;

        E_values_HHO = -((((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).cwiseAbs() +
                          eps * One_HHO).array().log10());

        E_der_HHO = Matrix<T, Dynamic, Dynamic>::Zero(phi.local_dim, phi.n_cls);
        E_der_HHO = (-One_HHO.cwiseQuotient(
                (((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).cwiseAbs() +
                 eps * One_HHO).cwiseProduct(
                        Log10_HHO)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
        E_der_HHO = (E_der_HHO.array().cwiseProduct(
                ((phi.sol_HHO - PHI_MIN_HHO).cwiseProduct(PHI_MAX_HHO - phi.sol_HHO)).array().sign()));
        E_der_HHO = (E_der_HHO.cwiseProduct(PHI_MAX_HHO + PHI_MIN_HHO - 2 * phi.sol_HHO));

    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
               sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
               (phi_max + phi_min - 2 * phi(pt, msh, cl));
    }

};

template<typename T, typename Fonction, typename Mesh>
struct entropy_log_phimin_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;

    entropy_log_phimin_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;

    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        auto f_pt = f(pt, msh, cl);
        return -std::log10(std::abs((f_pt - phi_min) * (phi_max - f_pt)) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        auto phi_pt = phi(pt, msh, cl);
        return -std::log10(std::abs((phi_pt - phi_min) * (phi_max - phi_pt)) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        auto phi_pt = phi(pt, msh, cl);
        return -1. / ((std::abs((phi_max - phi_pt) * (phi_pt - phi_min)) + eps) * std::log(10)) *
               sgn((phi_max - phi_pt) * (phi_pt - phi_min)) * (phi_max + phi_min - 2.0 * phi_pt);
    }

};


template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy_new_phimax_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;
    Eigen::Matrix<T, Dynamic, 1> E_values, E_der;

    non_linear_entropy_new_phimax_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = -phi.phi_max;
        E_values = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> One = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> Log10 = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Log10 *= std::log(10);
        Eigen::Matrix<T, Dynamic, 1> PHI_MAX = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        Eigen::Matrix<T, Dynamic, 1> PHI_MIN = Matrix<T, Dynamic, 1>::Ones(phi.ndof_FE, 1);
        PHI_MAX *= phi_max;
        PHI_MIN *= phi_min;

        E_values = -((((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() +
                      eps * One).array().log10());

        E_der = Matrix<T, Dynamic, 1>::Zero(phi.ndof_FE, 1);
        E_der = (-One.cwiseQuotient(
                (((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).cwiseAbs() + eps * One).cwiseProduct(
                        Log10)));//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
        E_der = (E_der.array().cwiseProduct(
                ((phi.sol_FEM - PHI_MIN).cwiseProduct(PHI_MAX - phi.sol_FEM)).array().sign()));
        E_der = (E_der.cwiseProduct(PHI_MAX + PHI_MIN - 2 * phi.sol_FEM));
//E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;

    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
               sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
               (phi_max + phi_min - 2 * phi(pt, msh, cl));
    }

};


template<typename T, typename Fonction, typename Mesh>
struct entropy_log_phimax_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;


    entropy_log_phimax_phimax(T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = -phi.phi_max;


    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((f(pt, msh, cl) - phi_min) * (phi_max - f(pt, msh, cl))) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs((phi(pt, msh, cl) - phi_min) * (phi_max - phi(pt, msh, cl))) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1. / ((std::abs((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) + eps) * std::log(10)) *
               sgn((phi_max - phi(pt, msh, cl)) * (phi(pt, msh, cl) - phi_min)) *
               (phi_max + phi_min - 2 * phi(pt, msh, cl));
    }

};


template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy_quadratic_piecewise_phimin_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;

    T coeff1, coeff2;
    T pol_order;

    non_linear_entropy_quadratic_piecewise_phimin_phimax(T max_val, const Fonction &phi, const Mesh &msh, T pol_order)
            : eps(eps), phi(phi), msh(msh), pol_order(pol_order) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;


        coeff1 = max_val / (pow(phi_min, pol_order));

        coeff2 = max_val / (pow(phi_max, pol_order));


    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T val = f(pt, msh, cl);
        return (val < 0) ? pow(val, pol_order) * coeff1 : pow(val, pol_order) * coeff2;


    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T val = phi(pt, msh, cl);
        return (val < 0) ? pow(val, pol_order) * coeff1 : pow(val, pol_order) * coeff2;
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        T val = phi(pt, msh, cl);
        return (val < 0) ? (pol_order - 1.0) * pow(val, pol_order - 1) * coeff1 : (pol_order - 1.0) *
                                                                                  pow(val, pol_order - 1) * coeff2;

    }

};

template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy_quadratic_phimin_phimax :
        public entropy<T, Mesh> {
    T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;
    Eigen::Matrix<T, Dynamic, 1> E_values, E_der;
    T coeff1, coeff2;
    T E0;

    non_linear_entropy_quadratic_phimin_phimax(T max_val, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi),
                                                                                                  msh(msh) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;
        auto phi_FEM = phi.sol_FEM;

        coeff1 = max_val / (phi_min * phi_min);

//        coeff2 = max_val / (phi_max*phi_max) ;

        E_values = phi_FEM.cwiseProduct(phi_FEM) * coeff1;

        E_der = 2.0 * coeff1 * phi_FEM;

        E0 = 0.0;

    }

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return f(pt, msh, cl) * f(pt, msh, cl) * coeff1;

    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return phi(pt, msh, cl) * phi(pt, msh, cl) * coeff1;
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {

        return phi(pt, msh, cl) * 2.0 * coeff1;;
    }

};


template<typename T, typename Fonction, typename Mesh>
struct non_linear_entropy :
        public entropy<T, Mesh> {
    const T eps;
    Fonction phi;
    T phi_max, phi_min;
    Mesh msh;

    non_linear_entropy(const T eps, const Fonction &phi, const Mesh &msh) : eps(eps), phi(phi), msh(msh) {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;

    }

/// THIS WAS FOR A GENERAL PHI, RE-WRITTEN FOR PHI BETWEEN 0 AND 1
/*
    T operator()(const Fonction& f, const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-f(pt,msh,cl))*(f(pt,msh,cl)-phi_min) ) + eps );
    }

    T operator()(const point<T,2>& pt , const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min) ) + eps );
    }

    T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
       // std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1./(( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) +eps)*std::log(10)) * sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) * ( phi_max - 2*phi(pt,msh,cl) + phi_min ) ;
    }
    */

    T operator()(const Fonction &f, const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs(f(pt, msh, cl) * (1 - f(pt, msh, cl))) + eps);
    }

    T operator()(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
        return -std::log10(std::abs(phi(pt, msh, cl) * (1 - phi(pt, msh, cl))) + eps);
    }

    T derivative(const point<T, 2> &pt, const typename Mesh::cell_type &cl) const {
// std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1. / ((std::abs((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) + eps) * std::log(10)) *
               sgn((1 - phi(pt, msh, cl)) * phi(pt, msh, cl)) * (1 - 2 * phi(pt, msh, cl));
    }

};


template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix <T, Dynamic, Dynamic>
make_lagrange_local_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {

//auto f_neigh = cl.user_data.f_neighbors;
//auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
//Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi * phi.transpose();
// phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
//ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

    return ret;
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix <T, Dynamic, Dynamic>
make_lagrange_lumped_mass_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {
    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2 * (degree + di));

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi;
    }

    return ret;
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>>
make_local_cij_matrix(const Mesh &msh, const typename Mesh::cell_type &cl, size_t degree, size_t di = 0) {
    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix <T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix <T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

// for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2 * (degree + di)); // integration of order 2k

    for (auto &qp: qps) {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    return std::make_pair(ret0, ret1);
}


template<typename VECTOR, typename Mesh, typename MATRIX, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, 1> make_dij_vector(const Mesh &msh, const MATRIX &dij, const VECTOR &phi_old) {
    Matrix<T, Dynamic, 1> ret = Eigen::Matrix<T, Dynamic, 1>::Zero(dij.rows(), 1);


    for (size_t i = 0; i < dij.rows(); i++) {
        auto tmp = (dij.row(i)).adjoint();
        ret(i) = tmp.dot(phi_old) - tmp(i) * (phi_old(i));
    }
    return ret;
}

template<typename VECTOR, typename T>
Matrix<T, Dynamic, 1>
solveFEM(const VECTOR &lumped_mass, const VECTOR &conv, const VECTOR &last_term, const VECTOR &phi_old, T dt,
         const std::vector <size_t> &bdry_nodes) {
/*
    Matrix<T, Dynamic, 1> sol =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    size_t j = 0;
    for (size_t i = 0 ; i < phi_old.rows() ; i++ ) {
        if( i == bdry_nodes.at(j) ){
            sol(i) = phi_old(i);
            j++; // I can do since bdry_nodes is ordered
        }
        else
           sol(i) = phi_old(i) - dt * conv(i)/( lumped_mass(i) ) + dt * last_term(i)/( lumped_mass(i) );
    }
    return sol;
    */
// if I dont consider boundary condition here, but just solve for all


    return phi_old - dt * conv.cwiseQuotient(lumped_mass) + dt * last_term.cwiseQuotient(lumped_mass);

}


template<typename Fonction, typename VECTOR, typename MATRIX, typename T>
Matrix<T, Dynamic, 1>
solveFEM_Entropic(const MATRIX &mass, const VECTOR &conv, const VECTOR &last_term, const Fonction &phi_old, T dt) {
// if I dont consider boundary condition here, but just solve for all-> look to solveFEM
    auto b = phi_old - dt * conv + dt * last_term;

    return mass.completeOrthogonalDecomposition().solve(b);


}

template<typename Fonction, typename VECTOR, typename MATRIX, typename T>
Matrix<T, Dynamic, 1>
solveFEM_Entropic_FAST(const MATRIX &llt, const VECTOR &conv, const VECTOR &last_term, const Fonction &phi_old, T dt) {
// if I dont consider boundary condition here, but just solve for all-> look to solveFEM
    auto b = phi_old - dt * conv + dt * last_term;

    return llt.solve(b);


}


/*

std::vector< size_t > find_neighbors(  const typename Mesh::node_type& node )
{
    size_t row = floor( node/(M+1) ) ;
    size_t col = n % (M+1) ;

    size_t central_cell = col + row*M ;

}
*/



template<typename T, typename Mesh>
class Finite_Element {
public:

    Mesh msh_last;
    Mesh msh_next;

    Mesh msh; // Original mesh, not agglomerated
// number of degree of freedom (HHO setting) , #vertices , #cells
    size_t ndof_disc, n_vertices, n_cls;
    size_t ndof_FE; // number of degree of freedom (Continuous FEM setting)
    size_t num_faces = 4; // #faces
    mesh_init_params <T> params; // parameters mesh
    size_t order; // FE order of polynomial B^k
    size_t local_ndof; // local degree of freedom


    size_t Nx, Ny; // number of cells in x and y direction
    T hx; // step size along x direction
    T hy; // step size along y direction

    std::vector <std::set<size_t>> S_i;
    typedef typename Mesh::point_type point_type;
    typedef typename Mesh::cell_type cell_type;
    std::vector <std::pair<std::pair < point_type, cell_type>, std::map<size_t, std::pair < point_type, cell_type>> > >
    S_pt_cell;


//std::map<size_t , std::pair<typename Mesh::point_type , typename Mesh::cell_type > >>
    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;

    std::vector<bool> Dirichlet_boundary; //(ndof_FE , FALSE );
    std::vector<bool> Dirichlet_boundary_inlet; //(ndof_FE , FALSE );

    Finite_Element(Mesh &other_msh, size_t order, const mesh_init_params <T> &params) : msh(other_msh), n_vertices(
            other_msh.nodes.size()), n_cls(other_msh.cells.size()), order(order), local_ndof((order + 1) * (order + 1)),
                                                                                        hx(params.hx()),
                                                                                        hy(params.hy()),
                                                                                        connectivity_matrix(n_cls,
                                                                                                            std::vector <
                                                                                                            std::pair <
                                                                                                            size_t, bool
                                                                                                                    >> (local_ndof)),
                                                                                        Nx(params.Nx), Ny(params.Ny),
                                                                                        params(params) {


        ndof_disc = n_vertices * n_cls;

//std::cout<<"n_vertices "<<n_vertices<<" , n_cls "<<n_cls<<" , ndof_disc "<<ndof_disc<<std::endl;
        if (order == 0)
            ndof_FE = msh.cells.size();

        size_t counter = 0, i_global = 0;
        for (const auto &cl: msh.cells) {

            if (order == 0) {
                ndof_FE = msh.cells.size();
                connectivity_matrix[counter][0].first = counter;
                connectivity_matrix[counter][0].second = false;

            } else {


                std::vector <size_t> loc_bdry_nodes;
                auto fcs = faces(msh, cl);
                for (size_t face_i = 0; face_i < num_faces; face_i++) {
                    auto fc = fcs[face_i];
//std::cout<<"fc is "<<fc<<std::endl;
// In HHO flow problem I can have different types of boundary;
// For level set evolution, I just focus on Dirichelet boundary
// The indication of the type of boundary in fc is relative to HHO problem, so useless now
                    if (fc.is_boundary) {
                        if (face_i == 0) {
                            loc_bdry_nodes.push_back(0);
                            loc_bdry_nodes.push_back(1);

                            if (order > 1) {
                                for (size_t j = 0; j <= order - 2; j++)
                                    loc_bdry_nodes.push_back(4 + j);
                            }

                        } else if (face_i == 1) {
                            loc_bdry_nodes.push_back(1);
                            loc_bdry_nodes.push_back(2);
                            if (order > 1) {
                                for (size_t j = 0; j <= order - 2; j++)
                                    loc_bdry_nodes.push_back(order + 3 + j);
                            }
                        } else if (face_i == 2) {
                            loc_bdry_nodes.push_back(2);
                            loc_bdry_nodes.push_back(3);
                            if (order > 1) {
                                for (size_t j = 0; j <= order - 2; j++)
                                    loc_bdry_nodes.push_back(2 * order + 2 + j);
                            }
                        } else if (face_i == 3) {
                            loc_bdry_nodes.push_back(0);
                            loc_bdry_nodes.push_back(3);
                            if (order > 1) {
                                for (size_t j = 0; j <= order - 2; j++)
                                    loc_bdry_nodes.push_back(3 * order + 1 + j);
                            }

                        } else
                            exit(1);

                    }

                }

                size_t offset_curr = offset(msh, cl);
                sort(loc_bdry_nodes.begin(), loc_bdry_nodes.end());
                loc_bdry_nodes.erase(unique(loc_bdry_nodes.begin(), loc_bdry_nodes.end()), loc_bdry_nodes.end());





//std::cout<<"loc_bdry_nodes "<<std::endl;
//for(auto i : loc_bdry_nodes)
//    std::cout<<i<<" , ";
//std::cout<<std::endl;

                for (size_t i_local = 0; i_local < local_ndof; i_local++) {
// if boundary = TRUE is node on the boudnary , else not
                    bool boundary = binary_search(loc_bdry_nodes.begin(), loc_bdry_nodes.end(), i_local);

// Case: first cell
                    if (offset_curr == 0) {
                        connectivity_matrix[counter][i_local].first = i_global;
                        connectivity_matrix[counter][i_local].second = boundary;
                        i_global++;
                    }

// Case: First row of cells, a part of cell[0]
// Left face enumeration for cell i = Right face enumeration for cell i-1
                    else if (offset_curr > 0 && offset_curr < Nx) {
                        if (i_local == 0) { // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][1].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local == 3) { // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][2].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local >= 3 * order + 1 && i_local <= 4 * order - 1) // nodes in face 3
                        {
// how many points i_local is distant from v3 vertices
// Idea is f1 of cell[counter-1] = f2 of cell[counter] (i.e. = means same ordering). It means:
//    face 1             face 3
// 2*ordering + 1 ---- 3*ordering + 1
//    |                      |
//    |                      |
//    |                      |
//  ordering + 3  ---- 4*ordering - 1

                            size_t dist_v3 = i_local - (3 * order + 1);
                            size_t j = 2 * order + 1 - dist_v3;
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][j].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else {
                            connectivity_matrix[counter][i_local].first = i_global;
                            connectivity_matrix[counter][i_local].second = boundary;
                            i_global++;
                        }

                    }

// Case: Left Boundary cells
// Bottom face enumeration for cell i = Top face enumeration for cell i-Nx
                    else if (offset_curr % Nx == 0 && offset_curr > 0) {
                        if (i_local == 0) { // vertex 3 of cell[counter-Nx] = vertex 0 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][3].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local == 1) { // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][2].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local >= 4 && i_local <= order + 2) // nodes in face 0
                        {
// how many points i_local is distant from v0 vertices
// Idea is f2 of cell[counter-Nx] = f0 of cell[counter] (i.e. = means same ordering). It means:
//         face 0 ; cell[counter]
//     4        ----     ordering + 2
//     |                      |
//         face 2 ; cell[counter-Nx]
//     |                      |
//  3*ordering  ----    2*ordering +2

                            size_t dist_v0 = i_local - 4;
                            size_t j = 3 * order - dist_v0;
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][j].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else {
                            connectivity_matrix[counter][i_local].first = i_global;
                            connectivity_matrix[counter][i_local].second = boundary;
                            i_global++;
                        }
                    }

// All the other cells ( i.e. internal and right boundary cells ) are both 2 the cases
                    else {
                        if (i_local == 0) { // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][1].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local == 3) { // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][2].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local == 1) { // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][2].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local >= 3 * order + 1 && i_local <= 4 * order - 1) // nodes in face 3
                        {
                            size_t dist_v3 = i_local - (3 * order + 1);
                            size_t j = 2 * order + 1 - dist_v3;
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - 1][j].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else if (i_local >= 4 && i_local <= order + 2) // nodes in face 0
                        {
                            size_t dist_v0 = i_local - 4;
                            size_t j = 3 * order - dist_v0;
                            connectivity_matrix[counter][i_local].first = connectivity_matrix[counter - Nx][j].first;
                            connectivity_matrix[counter][i_local].second = boundary;
                        } else {
                            connectivity_matrix[counter][i_local].first = i_global;
                            connectivity_matrix[counter][i_local].second = boundary;
                            i_global++;
                        }
                    }

                } // End of local loop for each cell
            }
            counter++;

        } // End of loop over the cells.


        if (order == 0)
            ndof_FE = msh.cells.size();
        else
            ndof_FE = i_global;

        S_i.resize(ndof_FE);
        Dirichlet_boundary.resize(ndof_FE);
        Dirichlet_boundary_inlet.resize(ndof_FE);

        S_pt_cell.resize(ndof_FE);

        for (auto &cl: msh.cells) {
            auto offset_cl = offset(msh, cl);
            auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, order);
            for (size_t i = 0; i < local_ndof; i++) {
                auto asm_map_i = connectivity_matrix[offset_cl][i].first;
                S_pt_cell[asm_map_i].first = std::make_pair(qps[i], cl);
                for (size_t j = 0; j < local_ndof; j++) {
                    auto asm_map_j = connectivity_matrix[offset_cl][j].first;
                    S_i[asm_map_i].insert(asm_map_j);

                    S_pt_cell[asm_map_i].second.insert(std::make_pair(asm_map_j, std::make_pair(qps[j], cl)));
//( std::make_pair(qps(i),cl) , std::make_pair(qps(j),cl) ) ;

                }
            }
        }


/*
        size_t size_supp_nodes = 0;
        std::cout<<"Supporting nodes IN FE METHOD:"<<std::endl;
        size_t jjjj = 0;
        for (auto& i: S_i) {
            size_supp_nodes+=i.size();
            std::cout <<"Node "<<jjjj<<":";
            for (auto it=i.begin(); it != i.end(); ++it)
                std::cout << ' ' << *it;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
        std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;


        jjjj = 0;
        for (auto& i: S_pt_cell) {

            std::cout <<"Node "<<jjjj<<" = ( "<<S_pt_cell[jjjj].first.first<<" , "<< offset(msh,S_pt_cell[jjjj].first.second)<<" ) "<<std::endl;
            for (auto it=i.second.begin(); it != i.second.end(); ++it)
                std::cout << '\t'<<" j = "<< it->first << " -> ( " << it->second.first<<" , "<< offset(msh, it->second.second)<<" ) "<<std::endl;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
         */
//        std::cout<<"Beginning of connectivity matrix"<<std::endl;



// Dirichlet boundary vector
        for (size_t i = 0; i < n_cls; i++) {
            for (size_t j = 0; j < local_ndof; j++) {
//                std::cout<<"( "<<connectivity_matrix[i][j].first<<" , "<<connectivity_matrix[i][j].second<<" ) , ";
                auto asmap = connectivity_matrix[i][j];
                Dirichlet_boundary[asmap.first] = asmap.second;
//std::cout<<"Node "<<asmap.first << " is Dirichlet "<<asmap.second<< "  ,  ";
            }
//            std::cout<<std::endl;
        }
//        std::cout<<std::endl;
//        std::cout<<"End of connectivity matrix"<<std::endl;






    }

    Finite_Element(const Finite_Element &other) {
        msh_last = other.msh_last;
        msh_next = other.msh_next;
        msh = other.msh;
        ndof_disc = other.ndof_disc;
        n_vertices = other.n_vertices;
        n_cls = other.n_cls;
        ndof_FE = other.ndof_FE;
        num_faces = other.num_faces;
        params = other.params;
        order = other.order;
        local_ndof = other.local_ndof;


        Nx = other.Nx;
        Ny = other.Ny;
        hx = other.hx;
        hy = other.hy;

        S_i = other.S_i;
        S_pt_cell = other.S_pt_cell;


        connectivity_matrix = other.connectivity_matrix;

        Dirichlet_boundary = other.Dirichlet_boundary;
        Dirichlet_boundary_inlet = other.Dirichlet_boundary_inlet;

    }

    Finite_Element() = default;

// It returns a vector in which each element is a pair (offset cell mesh at t^N , offset integration cell at t^0 )
// Notice that the first element is useful for the basis, the second for the quadrature domain.
    std::vector <std::pair<size_t, size_t>>
    mapping_S(const typename Mesh::cell_type &cl) const {
// cl is in the agglo_mesh at time t+1 -> msh_next
//auto i = offset(msh,cl) ;
//auto S_i = cl.user_data.offset_subcells ;

        std::vector <std::pair<size_t, size_t>> ret;
        size_t i_cl_next = offset(msh_next, cl);
// For each cell of the agglo mesh t^{N+1}, loop the original subcells K_i of mesh t^0
        for (auto &i: cl.user_data.offset_subcells) {

//std::cout<<"i = "<<i<<std::endl;
            if ((cl.user_data.offset_subcells[0] == cl.user_data.offset_subcells[1])) {
                size_t posp = i_cl_next + 1;
                size_t pospp = i_cl_next + Nx - 1;
                int posn = i_cl_next;
                int posnn = i_cl_next - Nx + 1;
                int limit_inf = i_cl_next - Nx + 1;
                int limit_sup = i_cl_next + Nx - 1;
//for( auto& cl_last : msh_last.cells )
                while (posn > limit_inf || pospp < msh_last.cells.size() || posnn >= 0 || posp < limit_sup) {
                    if (ret.size() == 1)
                        break;

//std::cout<<"posn = "<<posn<<" and i - Nx + 1 = "<<i - Nx + 1<<std::endl;
                    if (posn > limit_inf && posp < msh_last.cells.size()) {
                        auto cl_lastn = msh_last.cells[posn];
                        for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"i_last_n = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                break;
                            }
                        }
                    }
                    if (ret.size() == 1)
                        break;

                    if (posnn >= 0 && posp < msh_last.cells.size()) {
                        auto cl_lastn = msh_last.cells[posnn];
                        for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"i_last_nn = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                break;
                            }
                        }
                    }
                    if (ret.size() == 1)
                        break;


                    if (posp < limit_sup && posp < msh_last.cells.size()) {
                        auto cl_lastp = msh_last.cells[posp];
                        for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"i_last_p = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                break;
                            }
                        }
                    }
                    if (ret.size() == 1)
                        break;

                    if (pospp < msh_last.cells.size()) {
                        auto cl_lastp = msh_last.cells[pospp];
                        for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"i_last_pp = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                break;
                            }
                        }
                    }
                    if (ret.size() == 1)
                        break;


                    posp++;
                    posn--;
                    pospp++;
                    posnn--;
                }
                break;

            } else {
//for( auto& cl_last : msh_last.cells )
                size_t posp = i_cl_next + 1;
                size_t pospp = i_cl_next + Nx - 1;
                int posn = i_cl_next;
                int posnn = i_cl_next - Nx + 1;
                int limit_inf = i_cl_next - Nx + 1;
                int limit_sup = i_cl_next + Nx - 1;


                while (posn > limit_inf || pospp < msh_last.cells.size() || posnn >= 0 || posp < limit_sup) {
                    bool cell_n_found = FALSE;
                    if (ret.size() == cl.user_data.offset_subcells.size()) // || ret ==  cl.user_data.offset_subcells )
                        break;


                    if (posn > limit_inf && posp < msh_last.cells.size()) {
                        auto cl_lastn = msh_last.cells[posn];
                        for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_n = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                cell_n_found = TRUE;
                                break;
                            }
                        }
                    }
                    if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                        break;


                    if (posnn >= 0 && posp < msh_last.cells.size()) {
                        auto cl_lastn = msh_last.cells[posnn];
                        for (auto &i_last: cl_lastn.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_nn = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastn), i));
                                cell_n_found = TRUE;
                                break;
                            }
                        }
                    }
                    if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                        break;


                    if (posp < limit_sup && posp < msh_last.cells.size()) {
                        auto cl_lastp = msh_last.cells[posp];
                        for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_p = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                cell_n_found = TRUE;
                                break;
                            }
                        }
                    }
                    if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                        break;

                    if (pospp < msh_last.cells.size()) {
                        auto cl_lastp = msh_last.cells[pospp];
                        for (auto &i_last: cl_lastp.user_data.offset_subcells) {
//std::cout<<"AGGLO: i_last_pp = "<<i_last<<std::endl;
                            if (i_last == i) {
                                ret.push_back(std::make_pair(offset(msh_last, cl_lastp), i));
                                cell_n_found = TRUE;
                                break;
                            }
                        }
                    }
                    if (cell_n_found == TRUE || ret.size() == cl.user_data.offset_subcells.size())
                        break;


                    posp++;
                    posn--;
                    pospp++;
                    posnn--;
                }


            }


        }
        return ret;
    }



//void
//assembling(SparseMatrix<T>& Global_Mass ,SparseMatrix<T>& Global_c_term_x ,SparseMatrix<T>& Global_c_term_y, DiagonalMatrix<T, Dynamic>& Global_Mass_Lumped , Matrix<T, Dynamic, 1>& RHS){


// }

/*
    size_t get_order() const { return order; }
    size_t get_n_nodes() const { return n_nodes; }
    size_t get_n_cells() const { return n_cls; }
    size_t get_hx() const { return hx; }
    size_t get_hy() const { return hy; }
    size_t get_Nx() const { return Nx; }
    size_t get_Ny() const { return Ny; }
    size_t get_local_ndof() const { return local_ndof; }
    size_t get_ndof() const { return ndof; }
    */
};


template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
void global_update_vector(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
        global(kk) += local(i);
        i++;
    }

}


template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
void global_update_vector_NOSUM(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
        global(kk) = local(i);
        i++;
    }

}


template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
void global_update_vector_MAX(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
        auto max_glob = global(kk);
        global(kk) = std::max(local(i), max_glob);
        i++;
    }

}

template<typename VECTOR_LOC, typename VECTOR_GLOB, typename NODES>
void global_update_vector_MIN(const VECTOR_LOC &local, VECTOR_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;
        auto min_glob = global(kk);
        global(kk) = std::min(local(i), min_glob);
        i++;
    }

}


template<typename MATRIX_LOC, typename MATRIX_GLOB, typename NODES>
void global_update_NOSUM(const MATRIX_LOC &local, MATRIX_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t j = 0;
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;

        for (auto &l: nodes_position) {
            size_t ll = l.ptid;

//std::cout<<"colonna "<<ll<<std::endl;
//std::cout<<"j "<<j<<std::endl;
            global(kk, ll) = local(i, j);
            j++;
        }
        i++;

    }

}


template<typename MATRIX_LOC, typename MATRIX_GLOB, typename NODES>
void global_update(const MATRIX_LOC &local, MATRIX_GLOB &global, const NODES &nodes_position) {
    size_t i = 0;
// std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for (auto &k: nodes_position) {
        size_t j = 0;
        size_t kk = k.ptid;
//std::cout<<"riga "<<kk<<std::endl;
// std::cout<<"i "<<i<<std::endl;

        for (auto &l: nodes_position) {
            size_t ll = l.ptid;

//std::cout<<"colonna "<<ll<<std::endl;
//std::cout<<"j "<<j<<std::endl;
            global(kk, ll) += local(i, j);
            j++;
        }
        i++;

    }

}


/*

// OLD IMPLEMENTATION
template< typename MATRIX_LOC , typename MATRIX_GLOB , typename NODES>
void global_update2( const MATRIX_LOC& local , MATRIX_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;

   std::cout<<"LOCAL "<<std::endl;
   std::cout<<local<<std::endl;


    for(auto & k : nodes_position)
    {
        size_t j = 0;
        //size_t kk = k.ptid;
        std::cout<<"riga "<<k<<std::endl;
        std::cout<<"i "<<i<<std::endl;

        for(auto & l : nodes_position)
        {
            //size_t ll = l.ptid;

            std::cout<<"colonna "<<l<<std::endl;
            std::cout<<"j "<<j<<std::endl;

            global( k  , l  ) += local ( i , j ) ;
            j++;
        }
        i++;

    }
    std::cout<<"GLOBAL "<<std::endl;
    std::cout<<global<<std::endl;

}
*/



std::vector <size_t> boundary_nodes_function(size_t Nx, size_t Ny) {
// IT WORKS ONLY FOR Q1!!!
    std::vector <size_t> bdry_nodes;
    for (size_t j = 1; j <= Ny; j++) {
        bdry_nodes.push_back(j * (Nx + 1) - 1);
        bdry_nodes.push_back(j * (Nx + 1));
    }
    for (size_t j = 1; j < Nx; j++) {
        bdry_nodes.push_back(j);
        bdry_nodes.push_back(Ny * (Nx + 1) + j);
    }
    bdry_nodes.push_back(0);
    bdry_nodes.push_back((Ny + 1) * (Nx + 1) - 1);
    std::sort(bdry_nodes.begin(), bdry_nodes.end());

    return bdry_nodes;
}


template<typename Node, typename SUPP_NODES>
void supporting_nodes(SUPP_NODES &ret, const Node &nodes_position) {

    for (auto &i: nodes_position) {
        for (auto &j: nodes_position) {
            (ret.at(i.ptid)).insert(j.ptid);
//    std::cout<<"ret("<<i.ptid<<") is "<<j<<std::endl;
        }
//std::sort(ret(i.ptid).begin(), ret(i.ptid).end() ); // set already increasing ordered
    }

}


template<typename Node, typename MATRIX>
void division_Si(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(counter, elem) = mat1(counter, elem) / mat2(counter, elem);
        }
        counter++;
    }
}

template<typename Node, typename MATRIX>
void division_Si_T(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(elem, counter) = mat1(elem, counter) / mat2(elem, counter);
        }
        counter++;
    }
}

template<typename Node, typename MATRIX>
void moltiplication_Si_T(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(elem, counter) += (mat1(elem, counter) * mat2(elem, counter));
        }
        counter++;
    }
}


template<typename Node, typename MATRIX>
void moltiplication_Si(const Node &S_i, const MATRIX &mat1, const MATRIX &mat2, MATRIX &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(counter, elem) += (mat1(counter, elem) * mat2(counter, elem));
        }
        counter++;
    }
}

template<typename Node, typename MATRIX, typename VECTOR>
void sum_Si(const Node &S_i, const MATRIX &mat, const VECTOR &vec, VECTOR &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(counter) += mat(counter, elem) * vec(elem);
        }
        counter++;
    }
}

template<typename Node, typename MATRIX, typename VECTOR>
void averaged_sum_Si(const Node &S_i, const MATRIX &mat, const VECTOR &vec, VECTOR &sol) {
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            sol(counter) += mat(counter, elem) * (vec(elem) - vec(counter));
        }
        counter++;
    }
}


/*
template < typename VECTOR, typename MATRIX , typename T , typename POS >
void checking_phi_l( const VECTOR& lumped_mass, const MATRIX& cij_x , const MATRIX& cij_y , const MATRIX& d_ij, const VECTOR& phi_old , const VECTOR& phi_l , T dt , const POS& S_i )
{


    VECTOR K_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    VECTOR Dl_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    // SBAGLIATO NON è PHI_OLD MA IL FLUSSO CHE SERVE QUI DENTRO!
    averaged_sum_Si( S_i , cij_x , phi_old , K_term );
    averaged_sum_Si( S_i , cij_y , phi_old , K_term );
    sum_Si( S_i , d_ij , phi_old , Dl_term );
    //std::cout<<'\n'<<"check Dij "<<'\n'<<Dl_term-d_ij*phi_old<<std::endl;
    VECTOR tmp =  lumped_mass.cwiseProduct( (phi_l - phi_old)/dt ) + K_term - Dl_term;
    std::cout<<'\n'<<"check phi_l vec is "<<'\n'<<tmp<<std::endl;
}
*/
template<typename VECTOR, typename T>
void checking_phi_lBIS(const VECTOR &lumped_mass, const VECTOR &cij_term, const VECTOR &dij_term, const VECTOR &phi_old,
                       const VECTOR &phi_l, T dt) {

    VECTOR tmp = lumped_mass.cwiseProduct((phi_l - phi_old) / dt) + cij_term - dij_term;
    std::cout << '\n' << "CHECK BIS phi_l vec is " << '\n' << tmp << std::endl;
}


/*
template < typename VECTOR , typename MATRIX , typename T , typename POS >
void checking_phi_h( const MATRIX& mass, const MATRIX& cij_x , const MATRIX& cij_y , const MATRIX& dC_ij , const VECTOR& phi_old , const VECTOR& phi_h , T dt , const POS& S_i)
{

    VECTOR K_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Dc_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    // SBAGLIATO NON è PHI_OLD MA IL FLUSSO CHE SERVE QUI DENTRO!
    averaged_sum_Si( S_i , cij_x , phi_old , K_term );
    averaged_sum_Si( S_i , cij_y , phi_old , K_term );
    sum_Si( S_i , dC_ij , phi_old , Dc_term );
    VECTOR tmp =  mass*( (phi_h - phi_old)/dt ) + K_term  - dC_ij*phi_old;
   // std::cout<<'\n'<<"check DCij "<<'\n'<<Dc_term-dC_ij*phi_old<<std::endl;
    std::cout<<'\n'<<"check phi_h vec is "<<'\n'<<tmp<<std::endl;
}
*/
template<typename VECTOR, typename T, typename MATRIX>
void checking_phi_hBIS(const MATRIX &mass, const VECTOR &cij_term, const VECTOR &dij_term, const VECTOR &phi_old,
                       const VECTOR &phi_h, T dt) {

    VECTOR tmp = mass * ((phi_h - phi_old) / dt) + cij_term - dij_term;
    std::cout << '\n' << "CHECK BIS phi_H vec is " << '\n' << tmp << std::endl;
}


template<typename Entropy, typename Fonction, typename Fonction_TILDE, typename Mesh, typename Vel_Field, typename T, typename POSITION, typename VECTOR>
void
r_i_calculator(const Mesh &msh, const typename Mesh::cell_type &cl, const Entropy &E, const Fonction_TILDE &phi_tilde,
               const Fonction &phi, T dt, const Vel_Field &u, const POSITION &S_i, VECTOR &Emax_global,
               VECTOR &Emin_global, VECTOR &R_i) {
    size_t di = 0;
    cell_basis_Lagrangian<Mesh, T> cb(msh, cl, phi.degree_FEM);
    auto cbs = cb.size();
    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
    auto qps = integrate(msh, cl, 2 * (phi.degree_FEM + di));


    auto nds = nodes(msh, cl);
    iter_swap(nds.end() - 1, nds.end() - 2);

    auto pts = points(msh, cl);
    iter_swap(pts.end() - 1, pts.end() - 2);


    size_t counter = 0;
/// FARE FUNZIONE max_min_entropy PER RENDERE IL CODICE PULITO
    Eigen::Matrix<T, Dynamic, 1> Emax = Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
    Eigen::Matrix<T, Dynamic, 1> Emin = Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
    for (auto &nd: nds) {
        auto i = nd.ptid;
        T max_loc = -1e20;
        T min_loc = 1e20;
        for (auto &pt_j: pts) {
            Emax(counter) = std::max(E(pt_j, cl), max_loc);
            Emin(counter) = std::min(E(pt_j, cl), min_loc);
            max_loc = std::max(Emax(counter), max_loc);
            min_loc = std::min(Emin(counter), min_loc);
        }

        counter++;
    }
    global_update_vector_MAX(Emax, Emax_global, nds);
    global_update_vector_MIN(Emin, Emin_global, nds);
// std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//  std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;

    for (auto &qp: qps) {
        auto bi = cb.eval_basis(qp.first);
        auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
        auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

        auto f = (
                ((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt + u(qp.first, msh, cl).first * phi_grad0 +
                 u(qp.first, msh, cl).second * phi_grad1) *
                E.derivative(qp.first, cl)); //.cwiseQuotient( Emax - Emin ) ;
        ret += qp.second * bi * f;
    }
    global_update_vector(ret, R_i, nds);

}


template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
VECTOR
alfaf_ij_creator(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, const VECTOR &phi_L, T dt,
                 const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

    MATRIX new_mass = -mass;
    for (size_t i = 0; i < new_mass.rows(); i++) {
        new_mass(i, i) += lumped_mass(i);
    }

    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

    MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(mass.rows(), mass.cols());
    MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(mass.rows(), mass.cols());

    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR phi_max = phi_old;
    VECTOR phi_min = phi_old;


    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
            phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
        }
        counter++;
    }

    for (size_t i = 0; i < f_ij.rows(); i++) {
        for (size_t j = 0; j < f_ij.cols(); j++) {
            f_ij(i, j) = new_mass(i, j) * (delta_phi(j) - delta_phi(i)) + dt * new_D(i, j) * (phi_old(j) - phi_old(i));
            T f_tmp = f_ij(i, j);
            P_plus(i) += std::max(0., f_tmp);
            P_minus(i) += std::min(0., f_tmp);
        }
        Q_plus(i) = lumped_mass(i) * (phi_max(i) - phi_L(i));
        Q_minus(i) = lumped_mass(i) * (phi_min(i) - phi_L(i));
        if (std::abs(P_plus(i)) > 1e-20) {
            T Q_P_plus = Q_plus(i) / P_plus(i);
            R_plus(i) = std::min(1., Q_P_plus);
        }
        if (std::abs(P_minus(i)) > 1e-20) {
            T Q_P_minus = Q_minus(i) / P_minus(i);
            R_minus(i) = std::min(1., Q_P_minus);
        }
    }

    for (size_t i = 0; i < f_ij.rows(); i++) {
        for (size_t j = 0; j < f_ij.cols(); j++) {
            if (f_ij(i, j) > 0)
                alpha_ij(i, j) = std::min(R_plus(i), R_minus(j));
            else
                alpha_ij(i, j) = std::min(R_plus(j), R_minus(i));
        }

    }

    size_t counter2 = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            ret(counter2) += (alpha_ij(counter2, elem) * f_ij(counter2, elem));
        }
        counter2++;
    }


// CHECKING F and Alpha properties
/*
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij(i,j)+f_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

/*
    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij(i,j)-alpha_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

/*
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij(counter3,elem)+f_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij(counter3,elem)-alpha_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */
//  CHECKING F_IJ
    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    averaged_sum_Si(S_i, new_mass, delta_phi, ret0);
    averaged_sum_Si(S_i, new_D, phi_old, ret1);
    VECTOR f_i = (ret0 + dt * ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    sum_Si(S_i, f_ij, One_Vec, f_i_NEW);

//std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;

    return ret;

}


template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
VECTOR f_ij_creator(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, T dt, const MATRIX &D_ij,
                    const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

    MATRIX new_mass = -mass;
    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
    for (size_t i = 0; i < new_mass.rows(); i++) {
        new_mass(i, i) += lumped_mass(i);
    }

/*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    averaged_sum_Si(S_i, new_mass, delta_phi, ret0);
    averaged_sum_Si(S_i, new_D, phi_old, ret1);
/*
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter) += mat(counter,elem)*(vec(elem)-vec(counter));
        }
        counter++;
    }
    */
//  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

//    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
//    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

    return (ret0 + dt * ret1);

}

template<typename FUNCTION, typename T>
void mapping_phi(FUNCTION &phi, T phi_max, T phi_min) {
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones(phi.vertices.rows(), 1);
    Matrix <T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(phi.values_bis.rows(),
                                                                                    phi.values_bis.cols());
// mapping between 0 and 1
    phi.vertices = (phi.vertices - phi_min * Vec_One) / (phi_max - phi_min);
    phi.values_bis = (phi.values_bis - phi_min * Mat_One) / (phi_max - phi_min);
}

template<typename FUNCTION, typename T>
void inverse_mapping_phi(FUNCTION &phi, T phi_max, T phi_min) {
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones(phi.vertices.rows(), 1);
    Matrix <T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(phi.values_bis.rows(),
                                                                                    phi.values_bis.cols());
    phi.vertices = phi_min * Vec_One + phi.vertices * (phi_max - phi_min);
    phi.values_bis = phi_min * Mat_One + phi.values_bis * (phi_max - phi_min);
}


template<typename LS, typename VL>
void
savingVelocityLevelSet(const LS &level_set, const VL &u) {
    auto ls = level_set.sol_FEM;
    auto ls_ndofFE = level_set.ndof_FE;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u_ndofFE = u.ndof_FE;
/*
    postprocess_output<double> postoutput;

    auto test_ls  = std::make_shared< gnuplot_output_object<double> >("HHO_level_set.dat");
    auto test_u0  = std::make_shared< gnuplot_output_object<double> >("HHO_velocityX.dat");
    auto test_u1  = std::make_shared< gnuplot_output_object<double> >("HHO_velocityY.dat");

    for( size_t iLS  = 0 ; iLS < ls_ndofFE ; iLS++ )
        // test_ls->add_data(ls);

    for( size_t iLS  = 0 ; iLS < ls_ndofFE ; iLS++ )
    {
        // test_u0->add_data(node,valueD);
        // test_u1->add_data(node,valueD);
    }



    postoutput.add_object(test_ls);
    postoutput.add_object(test_u0);
    postoutput.add_object(test_u1);


    postoutput.write();
    */


    std::string filename_ls = "FEM_level_set.txt";
    std::ofstream interface_fileLS(filename_ls, std::ios::out | std::ios::trunc);


    if (interface_fileLS) {
        for (size_t iLS = 0; iLS < ls_ndofFE; iLS++) {
            interface_fileLS << std::setprecision(15) << ls(iLS) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< ls(iLS) <<std::endl;
        }
        interface_fileLS.close();

    } else
        std::cerr << "File 'FEM_level_set' has not been opened" << std::endl;


    std::string filename_u0 = "FEM_velocityX.txt";
    std::ofstream interface_fileU0(filename_u0, std::ios::out | std::ios::trunc);


    if (interface_fileU0) {
        for (size_t iU = 0; iU < u_ndofFE; iU++) {
            interface_fileU0 << std::setprecision(15) << u0(iU) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< u0(iU) <<std::endl;
        }
        interface_fileU0.close();

    } else
        std::cerr << "File 'FEM_velocityX' has not been opened" << std::endl;

    std::string filename_u1 = "FEM_velocityY.txt";
    std::ofstream interface_fileU1(filename_u1, std::ios::out | std::ios::trunc);


    if (interface_fileU0) {
        for (size_t iU = 0; iU < u_ndofFE; iU++) {
            interface_fileU1 << std::setprecision(15) << u1(iU) << std::endl;
// std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1)<< (*lsPointer) <<std::endl;
// std::cout << std::setprecision(15)<< u1(iU) <<std::endl;
        }
        interface_fileU1.close();

    } else
        std::cerr << "File 'FEM_velocityY' has not been opened" << std::endl;


}


template<typename T, typename Mesh, typename FiniteSpace>
struct L2_projection {
    SparseMatrix <T> Global_Mass; // Global mass, saved for FEM problem
    Matrix<T, Dynamic, 1> RHS;    // Known term
    std::vector <Triplet<T>> triplets; // Position elements: Sparse Matrix Notation

    Eigen::Matrix <T, Dynamic, Dynamic> sol_HHO; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh


    size_t number_elements;

    size_t n_cls; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices; // #vertices

    size_t degree_FEM;
    Mesh msh;
    size_t Nx, Ny;
    mesh_init_params <T> params;

    std::vector <std::vector<std::pair < size_t, bool>>>
    connectivity_matrix;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes


    L2_projection(const FiniteSpace &fe_data, const Mesh &msh)
            : degree_FEM(fe_data.order), local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx), Ny(fe_data.Ny),
              params(fe_data.params), dim_HHO(fe_data.ndof_disc), n_cls(fe_data.n_cls), n_vertices(fe_data.n_vertices),
              connectivity_matrix(fe_data.connectivity_matrix), ndof_FE(fe_data.ndof_FE) {
        sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(local_dim, n_cls);
        sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero(n_vertices, 1);
    }


    L2_projection() = default;


    void set_discrete_points(Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
        sol_HHO = values_new;
    }


    void converting_into_HHO_formulation(const Eigen::Matrix<T, Dynamic, 1> &values_new) {
        std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_HHO(i, counter_bis) = values_new(asm_map);
            }
            size_t i_vertex = counter_bis + floor(counter_bis / Nx);
            vertices(i_vertex) = sol_HHO(0, counter_bis);
            vertices(i_vertex + 1) = sol_HHO(1, counter_bis);
            vertices(i_vertex + Nx + 2) = sol_HHO(2, counter_bis);
            vertices(i_vertex + Nx + 1) = sol_HHO(3, counter_bis);
        }

    }

    void converting_into_FE_formulation(const Eigen::Matrix <T, Dynamic, Dynamic> &values_new) {
        std::cout << "L2 projection for phi_tilde post-resolution." << std::endl;
        for (size_t counter_bis = 0; counter_bis < n_cls; counter_bis++) {
            for (size_t i = 0; i < local_dim; i++) {
                size_t asm_map = connectivity_matrix[counter_bis][i].first;
                sol_FEM(asm_map) = values_new(i, counter_bis);
            }
        }


    }


    T operator()(const typename Mesh::node_type &node) const {
        return vertices(node.ptid);
    }

    T operator()(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

        size_t counter = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0, counter, local_dim, 1)).col(0);
        T tmp = values_cell.dot(cb.eval_basis(pt));
        return tmp;
    }

    Eigen::Matrix<T, 2, 1> gradient(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {

// MATRIX NOTATION
        size_t counter = offset(msh, cl);
        Eigen::Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, degree_FEM);
//cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval = cb.eval_gradients(pt);
        ret(0) = values_cell.dot(grad_eval.col(0));
// std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot(grad_eval.col(1));
//values_cell.dot( grad_eval.col(1) );
// std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


// IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T, 2, 1> normal(const point<T, 2> &pt, const Mesh &msh, const typename Mesh::cell_type &cl) const {
        Eigen::Matrix<T, 2, 1> ret;
        ret = gradient(pt, msh, cl);
        return ret / ret.norm();

    }


};


template<typename VEC, typename DIAG, typename T>
T time_step_CFL_unstesdy_Stokes(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary,
                                T &dt) {
    T eps = 0.0;
    T tau_min = dt;
    T CFL_numb = 10.0;
    size_t i = 0;
    for (const auto &dir_elem: Dirichlet_boundary) {
        if (!dir_elem) {
            if ((1 + 2 * tau_min * dii.coeff(i) / lumped_mass(i)) < eps) {
                std::cout << "tau_min PRE modification is " << tau_min;
                tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii.coeff(i);
                std::cout << " and tau_min POST modification is " << tau_min << std::endl;
            }
            CFL_numb = std::min(CFL_numb, (eps - 1.0) / 2.0 * lumped_mass(i) / dii.coeff(i));
        }
        i++;
    }
    std::cout << "CFL_numb ---> " << CFL_numb << std::endl;
    std::cout << yellow << bold << "dt is " << dt << " and tau min is " << tau_min << reset << std::endl;
    dt = std::min(dt, tau_min);
    return CFL_numb;
}


template<typename VEC, typename DIAG, typename T>
T time_step_CFL_L2_velocity_NEW(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary,
                                T &dt) {
    T eps = 1e-2; //0.0;
    T tau_min = dt;
    T CFL_numb = 1000.0;
    T dt_CFL = 1000.0;
//    T dt_CFL_2 = 1000.0;
//    T CFL_numb_max = -100.0 ;
    size_t i = 0;
    for (const auto &dir_elem: Dirichlet_boundary) {
        if (!dir_elem) {
            if ((1 + 2 * tau_min * dii(i) / lumped_mass(i)) < eps) {
                std::cout << "----> SMALLER dt_m NEEDED: dt_m PRE modification is " << tau_min;
                tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i);
                std::cout << " and POST becomes " << tau_min << std::endl;
            }
//std::cout<<"dii(i) =  "<<dii(i)<<" , lumped_mass(i) = "<< lumped_mass(i)<<" , tau_min = "<< tau_min <<", (1 + 2*tau_min*dii(i)/lumped_mass(i) ) = "<< (1 + 2*tau_min*dii(i)/lumped_mass(i) ) << " , ,(eps-1.0)/2.0*lumped_mass(i)/dii(i)  = " <<(eps-1.0)/2.0*lumped_mass(i)/dii(i)  <<std::endl;
            CFL_numb = std::min(CFL_numb, 1 + 2 * tau_min * dii(i) / lumped_mass(i));
            dt_CFL = std::min(dt_CFL, eps * (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i));
//            dt_CFL_2 = std::min( dt_CFL_2 , (-1.0)/2.0*lumped_mass(i)/dii(i)  );
//            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
        }
        i++;
    }

//std::cout<<"CFL_numb_max ---> "<<CFL_numb_max<<std::endl;
    if (dt != tau_min) {
        tau_min = floorf(tau_min * 10000) / 10000;
        std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << tau_min << std::endl;
        std::cout << "-> CFL number = " << CFL_numb << std::endl;
        dt = std::min(dt, tau_min);
        return CFL_numb;
    } else {
//        std::cout<<"-> dt_CFL = "<<dt_CFL<<std::endl;
        if (dt_CFL < dt) {
            dt_CFL = floorf(dt_CFL * 10000) / 10000;
            std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << dt_CFL << std::endl;
            dt = std::min(dt, dt_CFL);
        }
//        std::cout<<"-> dt_CFL_2 = "<<dt_CFL_2<<std::endl;
//        std::cout<<"-> CFL number = "<<CFL_numb<<std::endl;
        return CFL_numb;
    }
}

template<typename VEC, typename DIAG, typename T>
std::pair <T, T>
time_step_CFL_OK(const DIAG &dii, const VEC &lumped_mass, const std::vector<bool> &Dirichlet_boundary, T &dt) {
    T eps = 0.0;
    T tau_min = dt;
    T CFL_numb = 1000.0;
    T dt_CFL = 1000.0;
//    T dt_CFL_2 = 1000.0;
//    T CFL_numb_max = -100.0 ;
    size_t i = 0;
    for (const auto &dir_elem: Dirichlet_boundary) {
        if (!dir_elem) {
            if ((1 + 2 * tau_min * dii(i) / lumped_mass(i)) < eps) {
                std::cout << "----> SMALLER dt_m NEEDED: dt_m PRE modification is " << tau_min;
                tau_min = (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i);
                std::cout << " and POST becomes " << tau_min << std::endl;
            }
//std::cout<<"dii(i) =  "<<dii(i)<<" , lumped_mass(i) = "<< lumped_mass(i)<<" , tau_min = "<< tau_min <<", (1 + 2*tau_min*dii(i)/lumped_mass(i) ) = "<< (1 + 2*tau_min*dii(i)/lumped_mass(i) ) << " , ,(eps-1.0)/2.0*lumped_mass(i)/dii(i)  = " <<(eps-1.0)/2.0*lumped_mass(i)/dii(i)  <<std::endl;
            CFL_numb = std::min(CFL_numb, 1 + 2 * tau_min * dii(i) / lumped_mass(i));
            dt_CFL = std::min(dt_CFL, (eps - 1.0) / 2.0 * lumped_mass(i) / dii(i));
//            dt_CFL_2 = std::min( dt_CFL_2 , (-1.0)/2.0*lumped_mass(i)/dii(i)  );
//            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
        }
        i++;
    }

//std::cout<<"CFL_numb_max ---> "<<CFL_numb_max<<std::endl;
    if (dt != tau_min) {
//        tau_min = floorf(tau_min * 10000) / 10000;
        std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << tau_min << std::endl;
        std::cout << "-> CFL number = " << CFL_numb << std::endl;
        dt = std::min(dt, tau_min);
    } else {
//        std::cout<<"-> dt_CFL = "<<dt_CFL<<std::endl;
        if (dt_CFL < dt) {
//            dt_CFL = floorf(dt_CFL * 10000) / 10000;
            std::cout << "OLD dt_m = " << dt << " and NEW dt_m = " << dt_CFL << std::endl;
            dt = std::min(dt, dt_CFL);
        }
//        std::cout<<"-> dt_CFL_2 = "<<dt_CFL_2<<std::endl;
//        std::cout<<"-> CFL number = "<<CFL_numb<<std::endl;

    }
    return std::make_pair(CFL_numb, dt_CFL);
}


template<typename Entropy, typename Fonction, typename Fonction_TILDE, typename Mesh, typename Vel_Field, typename T, typename VECTOR>
void r_i_calculator_Bernstein(const Mesh &msh, const typename Mesh::cell_type &cl, const Entropy &E,
                              const Fonction_TILDE &phi_tilde, const Fonction &phi, T dt, const Vel_Field &u,
                              VECTOR &Emax_global, VECTOR &Emin_global, VECTOR &R_i) {
    size_t di = 1;
    cell_basis_Bernstein<Mesh, T> cb(msh, cl, phi.degree_FEM);
    auto cbs = cb.size();
    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
    auto qps = integrate(msh, cl, 2 * (phi.degree_FEM + di));

    auto nds = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, phi.degree_FEM);

    size_t offset_cell = offset(msh, cl);

    T max_loc = -1e20;
    T min_loc = 1e20;

    for (auto &ndj: nds) {
        max_loc = std::max(E(ndj, cl), max_loc);
        min_loc = std::min(E(ndj, cl), min_loc);
    }

    for (size_t i = 0; i < phi.local_dim; i++) {
        size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
        Emax_global(asm_map) = std::max(Emax_global(asm_map), max_loc);
        Emin_global(asm_map) = std::min(Emin_global(asm_map), min_loc);
    }

//std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;


    for (auto &qp: qps) {
        auto bi = cb.eval_basis(qp.first);
        auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
        auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

        auto f = (
                ((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt + u(qp.first, msh, cl).first * phi_grad0 +
                 u(qp.first, msh, cl).second * phi_grad1) *
                E.derivative(qp.first, cl)); //.cwiseQuotient( Emax - Emin ) ;
        ret += qp.second * bi * f;
    }

    for (size_t i = 0; i < phi.local_dim; i++) {
        size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
        R_i(asm_map) += ret(i);
    }


}


template<typename T>
void positive_part_SPARSE(SparseMatrix <T> &mat) {
    for (size_t i = 0; i < mat.rows(); i++) {
        for (size_t j = 0; j < mat.cols(); j++) {
            if (mat.coeff(i, j) < 0.)
                mat.coeffRef(i, j) = 0.;
        }
    }

}


template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
VECTOR alfaf_ij_creator_M_LUMPED_SPARSE(const VECTOR &lumped_mass, const VECTOR &delta_phi, const VECTOR &phi_L, T dt,
                                        const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old,
                                        const POSITION &S_i) {


    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
//    std::cout<<'\n'<<"new_D = "<<'\n'<<new_D<<'\n'<<std::endl;
    SparseMatrix <T> f_ij = SparseMatrix<T>(Dc_ij.rows(), Dc_ij.cols());
    std::vector <Triplet<T>> triplets0;
    SparseMatrix <T> alpha_ij = SparseMatrix<T>(Dc_ij.rows(), Dc_ij.cols());
    std::vector <Triplet<T>> triplets1;


//MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
//MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);

    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);
    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(Dc_ij.rows(), 1);

    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(Dc_ij.rows(), 1);
    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(Dc_ij.rows(), 1);
    VECTOR phi_max = phi_old;
    VECTOR phi_min = phi_old;


    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
            phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
        }
        counter++;
    }

    counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            auto value = dt * new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));
//            std::cout<<'\n'<<"value = "<<value<<'\n'<<std::endl;
//            std::cout<<'\n'<<"phi_old(elem)-phi_old(counter) = "<<phi_old(elem)-phi_old(counter)<<'\n'<<std::endl;
//            std::cout<<'\n'<<"new_D.coeff(counter,elem) = "<<new_D.coeff(counter,elem)<<'\n'<<std::endl;

            triplets0.push_back(Triplet<T>(counter, elem, value));
            P_plus(counter) += std::max(0., value);
            P_minus(counter) += std::min(0., value);

        }

        Q_plus(counter) = lumped_mass(counter) * (phi_max(counter) - phi_L(counter));
        Q_minus(counter) = lumped_mass(counter) * (phi_min(counter) - phi_L(counter));

        if (std::abs(P_plus(counter)) > 1e-14) {
//            std::cout<<'\n'<<"R_plus(counter) = "<<Q_plus(counter)/P_plus(counter)<<std::endl;
            R_plus(counter) = std::min(1.0, Q_plus(counter) / P_plus(counter));
        }
        if (std::abs(P_minus(counter)) > 1e-14) {
//            std::cout<<'\n'<<"R_minus(counter) = "<<Q_minus(counter)/P_minus(counter)<<std::endl;
            R_minus(counter) = std::min(1.0, Q_minus(counter) / P_minus(counter));
        }


        counter++;
    }

//    std::cout<<'\n'<<"P_plus = "<<'\n'<<P_plus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"P_minus = "<<'\n'<<P_minus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"Q_plus = "<<'\n'<<Q_plus<<'\n'<<std::endl;
//    std::cout<<'\n'<<"Q_minus = "<<'\n'<<Q_minus<<'\n'<<std::endl;
    std::cout << '\n' << "R_plus = " << '\n' << R_plus << '\n' << std::endl;
    std::cout << '\n' << "R_minus = " << '\n' << R_minus << '\n' << std::endl;
    f_ij.setFromTriplets(triplets0.begin(), triplets0.end());
    triplets0.clear();

    size_t i = 0;
    for (auto &row_i: S_i) {
        for (auto &j: row_i) {
            if (f_ij.coeff(i, j) >= 0) {
                auto value = std::min(R_plus(i), R_minus(j));
                triplets1.push_back(Triplet<T>(i, j, value));

            } else {
                auto value = std::min(R_plus(j), R_minus(i));
                triplets1.push_back(Triplet<T>(i, j, value));

            }
        }
        i++;
    }

    alpha_ij.setFromTriplets(triplets1.begin(), triplets1.end());
    triplets1.clear();
//    std::cout<<'\n'<<"alpha_ij = "<<'\n'<<alpha_ij<<'\n'<<std::endl;

    size_t counter2 = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            ret(counter2) += (alpha_ij.coeff(counter2, elem) * f_ij.coeff(counter2, elem));
        }
        counter2++;
    }

//    std::cout<<'\n'<<"ret = "<<'\n'<<ret<<'\n'<<std::endl;
// CHECKING F and Alpha properties

/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }



    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */



/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    //  CHECKING F_IJ

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    size_t counter4 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));
            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));
        }
        counter++;
    }

    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    //sum_Si( S_i , f_ij , One_Vec , f_i_NEW );
    size_t counter5 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));
        }
        counter5++;
    }

    std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;
    */
    return ret;

}

template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
VECTOR
alfaf_ij_creator_SPARSE(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, const VECTOR &phi_L,
                        T dt, const MATRIX &D_ij, const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

    MATRIX new_mass = -mass;
    for (size_t i = 0; i < new_mass.rows(); i++) {
        new_mass.coeffRef(i, i) += lumped_mass(i);
    }

    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

    SparseMatrix <T> f_ij = SparseMatrix<T>(mass.rows(), mass.cols());
    std::vector <Triplet<T>> triplets0;
    SparseMatrix <T> alpha_ij = SparseMatrix<T>(mass.rows(), mass.cols());
    std::vector <Triplet<T>> triplets1;


//MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
//MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR phi_max = phi_old;
    VECTOR phi_min = phi_old;


    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            phi_max(counter) = std::max(phi_old(elem), phi_max(counter));
            phi_min(counter) = std::min(phi_old(elem), phi_min(counter));
        }
        counter++;
    }

    counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            auto value = new_mass.coeff(counter, elem) * (delta_phi(elem) - delta_phi(counter)) +
                         dt * new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));

            triplets0.push_back(Triplet<T>(counter, elem, value));
            P_plus(counter) += std::max(0., value);
            P_minus(counter) += std::min(0., value);

        }

        Q_plus(counter) = lumped_mass(counter) * (phi_max(counter) - phi_L(counter));
        Q_minus(counter) = lumped_mass(counter) * (phi_min(counter) - phi_L(counter));
        if (std::abs(P_plus(counter)) > 1e-14) {
            R_plus(counter) = std::min(1.0, Q_plus(counter) / P_plus(counter));
        }
        if (std::abs(P_minus(counter)) > 1e-14) {
            R_minus(counter) = std::min(1.0, Q_minus(counter) / P_minus(counter));
        }


        counter++;
    }


    f_ij.setFromTriplets(triplets0.begin(), triplets0.end());
    triplets0.clear();

    size_t i = 0;
    for (auto &row_i: S_i) {
        for (auto &j: row_i) {
            if (f_ij.coeff(i, j) >= 0) {
                auto value = std::min(R_plus(i), R_minus(j));
                triplets1.push_back(Triplet<T>(i, j, value));

            } else {
                auto value = std::min(R_plus(j), R_minus(i));
                triplets1.push_back(Triplet<T>(i, j, value));

            }
        }
        i++;
    }

    alpha_ij.setFromTriplets(triplets1.begin(), triplets1.end());
    triplets1.clear();


    size_t counter2 = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            ret(counter2) += (alpha_ij.coeff(counter2, elem) * f_ij.coeff(counter2, elem));
        }
        counter2++;
    }


// CHECKING F and Alpha properties

/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }



    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */



/*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    //  CHECKING F_IJ

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    size_t counter4 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));
            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));
        }
        counter++;
    }

    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    //sum_Si( S_i , f_ij , One_Vec , f_i_NEW );
    size_t counter5 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));
        }
        counter5++;
    }

    std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;
    */
    return ret;

}


template<typename T, typename MATRIX, typename VECTOR, typename POSITION>
VECTOR
f_ij_creator_SPARSE(const VECTOR &lumped_mass, const MATRIX &mass, const VECTOR &delta_phi, T dt, const MATRIX &D_ij,
                    const MATRIX &Dc_ij, const VECTOR &phi_old, const POSITION &S_i) {

    MATRIX new_mass = -mass;
    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
    for (size_t i = 0; i < new_mass.rows(); i++) {
        new_mass.coeffRef(i, i) += lumped_mass(i);
    }

/*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
//averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );
//averaged_sum_Si( S_i , new_D , phi_old , ret1 );

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            ret0(counter) += new_mass.coeff(counter, elem) * (delta_phi(elem) - delta_phi(counter));
            ret1(counter) += new_D.coeff(counter, elem) * (phi_old(elem) - phi_old(counter));


        }
        counter++;
    }

//  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

//    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
//    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

    return (ret0 + dt * ret1);

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                               Fonction &phi, Vel_Field &u,
                                                               const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
//        phi.coefficients_mapping_MAX_MAX( );
//        //phi.coefficients_mapping();
//    }
//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;


    T eps = 1e-14; //constant into entropy
// NON LINEAR ENTROPY INITIALISATION [0,1]

//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION [phi_min, phi_max]
    non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
//    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


// SAVING OF USEFUL MATRICES
    auto global_mass = method.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
//    timecounter tc_solver;
//    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }

//    tc_solver.toc();
//    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


//    tc_solver2.toc();
//    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



//    timecounter tc_case00;
//    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;


// CHECK TIME STEP dt
//    T dt_old = dt ;
//    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//    T nu_max0 = CFL_numb/fe_data.hx;
//    T nu0 = dt_old/fe_data.hx;
//    T nu1 = dt/fe_data.hx;

//    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;






// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

//    timecounter tc_case02;
//    tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
//    timecounter tc_case03;
//    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
// IN [phi_min,phi_max]
                auto value_2 = std::max((value_1 - phi.phi_min) * (phi.phi_max - value_1), 0.0);
//                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 ); // IN [0,1]

//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                bool check_else = FALSE;
                T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
//std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
//std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
//auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
//std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max(1.0 - c_comp * value, 0.0);
                if (check_else) {
//std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                    value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
//std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();


//    tc_case03.toc();
//    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


//    timecounter tc_solver5;
//    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

//    tc_solver5.toc();
//    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

//    timecounter tc_case06;
//    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);

//    if(!mapping){
//        phi.coefficients_inverse_mapping_MAX_MAX( );
//        //phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


//    tc_case06.toc();
//    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;
//
//    tc.toc();
//    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



//return phi_tilde;
    return CFL_numb;
}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONS_LIMITED(const Mesh &msh,
                                                                              const FiniteSpace &fe_data, Fonction &phi,
                                                                              Vel_Field &u,
                                                                              const Method_Transport &method, T &dt,
                                                                              bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//timecounter tc;
//tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );


    non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// SAVING OF USEFUL MATRICES
    auto global_mass = method.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;

//    std::cout<<'\n'<<"global_mass = "<<'\n'<<global_mass<<std::endl;

// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)

//    ConjugateGradient<SparseMatrix<T> > solver_prova;
//    solver_prova.compute(global_mass);
//    if(solver_prova.info()!=Success){
//           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
//           exit(1);
//       }

//timecounter tc_solver;
//tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }



//tc_solver.toc();
//std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


//tc_solver2.toc();
//std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;





// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//    std::cout<<"mass_phi_old  "<<'\n'<<mass_phi_old<<'\n'<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
//    time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );
    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//   std::cout<<'\n'<<"dt = "<<dt<<std::endl;


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
//    T c_e = 1.0;
//    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]


                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//     Matrix<T, Dynamic, 1> b_prova = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//    Matrix<T, Dynamic, 1> phi_H_prova = solver_prova.solve(b_prova);

//    std::cout<<'\n'<<"b_phiH = "<<'\n'<<b_phiH<<std::endl;
//
//    std::cout<<'\n'<<"phi_H_prova = "<<'\n'<<phi_H_prova<<std::endl;
//
//    std::cout<<'\n'<<"phi_H = "<<'\n'<<phi_H<<std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//    std::cout<<'\n'<<"delta_phi = "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

//    std::cout<<'\n'<<"f_i = "<<'\n'<<f_i<<std::endl;

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    return CFL_numb;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_transport_high_order_FTC_M_consistent(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                          const Method_Transport &method, T &dt, bool mapping) {


    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
    entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// SAVING OF USEFUL MATRICES
    auto global_mass = method.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;


    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            auto val = q_entropy(pts[i], cl);
            entropic_flux0_loc(i) = val.first;
            entropic_flux1_loc(i) = val.second;

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
        Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);
            entropic_flux0(asm_map) = sol0_entropic(i);
            entropic_flux1(asm_map) = sol1_entropic(i);

        }


        i_fl++;
    }




// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;


// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    auto S_pt_cell = fe_data.S_pt_cell;


    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;

        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;

        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i.second) {

            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;
            N_i_entropic += ((entropic_flux0(elem_j) - E.derivative(pt_i, cl_i) * flux0(elem_j)) *
                             global_cij_x.coeff(counter_row, elem_j) +
                             (entropic_flux1(elem_j) - E.derivative(pt_i, cl_i) * flux1(elem_j)) *
                             global_cij_y.coeff(counter_row, elem_j));

            D_i_entropic0 += (entropic_flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                              entropic_flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));
            D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                              flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

            T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                u1(counter_row) * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(
                    u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(
                    u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j)
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


        }

        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
        if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 1.0;
        }
        if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 0.0;
        }

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


// CHECK TIME STEP dt

    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]

                dii_E(counter) -= value_E;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;
    size_t counter_row_prova = 0;

    postprocess_output<double> postoutput1;

    auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE_piece_qua.dat");
    auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL_piece_qua.dat");
    auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE_piece_qua.dat");

    for (auto &row_i: S_pt_cell) {
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        auto dii = dij.diagonal();

        test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
        test_dii->add_data(pt_i, -dii(counter_row_prova));
        test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
        counter_row_prova++;

    }


    postoutput1.add_object(test_dii_dijE);
    postoutput1.add_object(test_dii);
    postoutput1.add_object(test_dijE);


    postoutput1.write();

///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;

    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
            phi_H(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }



// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;


//    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i ); // Calculated into alfaf_ij_creator_SPARSE

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    counter_dir = 0;

    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
        if (dir_elem) {

            phi_new(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    return CFL_numb;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_transport_high_order_FTC_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                      const Method_Transport &method, T &dt, bool mapping) {


    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
    entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// SAVING OF USEFUL MATRICES

    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;





// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            auto val = q_entropy(pts[i], cl);
            entropic_flux0_loc(i) = val.first;
            entropic_flux1_loc(i) = val.second;

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
        Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);
            entropic_flux0(asm_map) = sol0_entropic(i);
            entropic_flux1(asm_map) = sol1_entropic(i);

        }


        i_fl++;
    }






// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;


// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    auto S_pt_cell = fe_data.S_pt_cell;


    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;

        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;

        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i.second) {

            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;
            N_i_entropic += ((entropic_flux0(elem_j) - E.derivative(pt_i, cl_i) * flux0(elem_j)) *
                             global_cij_x.coeff(counter_row, elem_j) +
                             (entropic_flux1(elem_j) - E.derivative(pt_i, cl_i) * flux1(elem_j)) *
                             global_cij_y.coeff(counter_row, elem_j));

            D_i_entropic0 += (entropic_flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                              entropic_flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));
            D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                              flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

            T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                u1(counter_row) * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(
                    u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(
                    u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j)
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


        }

        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
        if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 1.0;
        }
        if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 0.0;
        }

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


// CHECK TIME STEP dt

    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]

                dii_E(counter) -= value_E;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;
    size_t counter_row_prova = 0;

    postprocess_output<double> postoutput1;

    auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE_piece_qua.dat");
    auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL_piece_qua.dat");
    auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE_piece_qua.dat");

    for (auto &row_i: S_pt_cell) {
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        auto dii = dij.diagonal();

        test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
        test_dii->add_data(pt_i, -dii(counter_row_prova));
        test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
        counter_row_prova++;

    }


    postoutput1.add_object(test_dii_dijE);
    postoutput1.add_object(test_dii);
    postoutput1.add_object(test_dijE);


    postoutput1.write();

///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> phi_H = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij.cwiseQuotient(global_lumped_mass);


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;
//    std::cout<<" delta_phi = "<<delta_phi<<std::endl;

//    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i ); // Calculated into alfaf_ij_creator_SPARSE

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_M_LUMPED_SPARSE(global_lumped_mass, delta_phi, phi_L, dt,
                                                                           dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    return CFL_numb;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_transport_highorder_limited_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                         const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent -  limiting) -----------"<<reset<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//timecounter tc;
//tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
//    non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
    non_linear_entropy_new_phimax_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimax_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
    auto global_mass = method.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;

//    std::cout<<'\n'<<"global_mass = "<<'\n'<<global_mass<<std::endl;

// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)

//    ConjugateGradient<SparseMatrix<T> > solver_prova;
//    solver_prova.compute(global_mass);
//    if(solver_prova.info()!=Success){
//           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
//           exit(1);
//       }

//timecounter tc_solver;
//tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }



//tc_solver.toc();
//std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//timecounter tc_solver2;
//tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


//tc_solver2.toc();
//std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;





// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//    std::cout<<"mass_phi_old  "<<'\n'<<mass_phi_old<<'\n'<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
//    time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );
    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);

//   std::cout<<'\n'<<"dt = "<<dt<<std::endl;


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
//    T c_e = 1.0;
//    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto value_E = dij.coeff(counter, elem) * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));

// COMPRESSION -> IF ADDING TO BE DONE BETWEEN [phi_min,phi_max]


                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_E));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();

//std::cout<< "Entropic process."<< std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"phi_L = "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//     Matrix<T, Dynamic, 1> b_prova = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//    Matrix<T, Dynamic, 1> phi_H_prova = solver_prova.solve(b_prova);

//    std::cout<<'\n'<<"b_phiH = "<<'\n'<<b_phiH<<std::endl;
//
//    std::cout<<'\n'<<"phi_H_prova = "<<'\n'<<phi_H_prova<<std::endl;
//
//    std::cout<<'\n'<<"phi_H = "<<'\n'<<phi_H<<std::endl;

//    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
//    std::cout << "The relative error is: " << relative_error0 << std::endl;


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//    std::cout<<'\n'<<"delta_phi = "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

//    std::cout<<'\n'<<"f_i = "<<'\n'<<f_i<<std::endl;

// CORRECTION TERM: Boris–Book–Zalesak’s limiting for scalar equations
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//    std::cout<<'\n'<<"correction_fi = "<<'\n'<<correction_fi<<std::endl;
//    std::cout<<'\n'<<"phi_new = "<<'\n'<<phi_new<<std::endl;

// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);





//std::cout  << "Extension to preserving HO." << std::endl;

//tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    return CFL_numb;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_transport_entropic_M_lumped(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;

    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
    non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//        non_linear_entropy_new_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//        typedef non_linear_entropy_new_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//        entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);





//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    auto S_pt_cell = fe_data.S_pt_cell;


    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;

        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;

        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i.second) {

            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;

            auto q_etro0j = q_entropy(pt_j, cl_j).first;
            auto q_etro1j = q_entropy(pt_j, cl_j).second;
            auto Ederi = E.derivative(pt_i, cl_i);
            auto flux0j = flux0(elem_j);
            auto flux1j = flux1(elem_j);
            auto gl_cxij = global_cij_x.coeff(counter_row, elem_j);
            auto gl_cyij = global_cij_y.coeff(counter_row, elem_j);

            N_i_entropic += ((q_etro0j - Ederi * flux0j) * gl_cxij + (q_etro1j - Ederi * flux1j) * gl_cyij);
            D_i_entropic0 += (q_etro0j * gl_cxij + q_etro1j * gl_cyij);
            D_i_entropic1 += (flux0j * gl_cxij + flux1j * gl_cyij);

//            N_i_entropic += ( (q_entropy(pt_j,cl_j).first - E.derivative(pt_i,cl_i)*flux0(elem_j) )*global_cij_x.coeff(counter_row,elem_j) + (q_entropy(pt_j,cl_j).second - E.derivative(pt_i,cl_i)*flux1(elem_j) )*global_cij_y.coeff(counter_row,elem_j) );
//            D_i_entropic0 += ( q_entropy(pt_j,cl_j).first * global_cij_x.coeff(counter_row,elem_j) + q_entropy(pt_j,cl_j).second * global_cij_y.coeff(counter_row,elem_j) );
//            D_i_entropic1 += ( flux0(elem_j)*global_cij_x.coeff(counter_row,elem_j) + flux1(elem_j)*global_cij_y.coeff(counter_row,elem_j) ) ;

            T value0 = std::abs(u0(counter_row) * nij0.coeff(counter_row, elem_j) +
                                u1(counter_row) * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(
                    u0(elem_j) * nij0.coeff(counter_row, elem_j) + u1(elem_j) * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(u0(counter_row) * nji0.coeff(counter_row, elem_j) +
                                    u1(counter_row) * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(
                    u0(elem_j) * nji0.coeff(counter_row, elem_j) + u1(elem_j) * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j)
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


        }

        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.derivative(pt_i, cl_i));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
        if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 1.0;
        }
        if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 0.0;
        }

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                dii_E(counter) -= value_E;
                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
        counter++;
    }


//    size_t counter_row_prova = 0;
//
//    postprocess_output<double> postoutput1;
//
//    auto test_dii_dijE  = std::make_shared< gnuplot_output_object<double> >("test_diiL_diiE_piece_qua.dat");
//    auto test_dii  = std::make_shared< gnuplot_output_object<double> >("test_diiL_piece_qua.dat");
//    auto test_dijE  = std::make_shared< gnuplot_output_object<double> >("test_diiE_piece_qua.dat");
//
//    for(auto& row_i:S_pt_cell)
//    {
//        auto pt_i = row_i.first.first ;
//        auto cl_i = row_i.first.second ;
//        auto dii = dij.diagonal();
////            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
////                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
//        test_dii_dijE->add_data(pt_i,dii(counter_row_prova) - dii_E(counter_row_prova));
//        test_dii->add_data(pt_i,dii(counter_row_prova) );
//        test_dijE->add_data(pt_i, dii_E(counter_row_prova));
//        counter_row_prova++;
//
//    }
//
//
//
//    postoutput1.add_object(test_dii_dijE);
//    postoutput1.add_object(test_dii);
//    postoutput1.add_object(test_dijE);
//
//
//
//    postoutput1.write();


    size_t counter_row_prova = 0;

    postprocess_output<double> postoutput1;

    auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
    auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
    auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");
    auto test_Ri = std::make_shared < gnuplot_output_object < double > > ("test_Ri.dat");

    for (auto &row_i: S_pt_cell) {
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
        test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
        test_dii->add_data(pt_i, -dii(counter_row_prova));
        test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
        test_Ri->add_data(pt_i, R_i(counter_row_prova));


        counter_row_prova++;

    }


    postoutput1.add_object(test_Ri);
    postoutput1.add_object(test_dii_dijE);
    postoutput1.add_object(test_dii);
    postoutput1.add_object(test_dijE);


    postoutput1.write();


//   auto CFL_numb_E = time_step_CFL_OK( dii_E , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );
//    std::cout<<"CFL low order = "<< CFL_numb_L.first << " , CFL entropic = "<<CFL_numb_E.first<<std::endl;
//    std::cout<<"TIME STEP: dt_cfl low order = "<< CFL_numb_L.second << " , dt_cfl entropic = "<<CFL_numb_E.second<<std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
    phi.sol_FEM = phi_E;
    phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    return CFL_numb_L;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_transport_entropic_M_lumped_Ri_correct(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                           const Method_Transport &method, T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;

    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;

    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
    entropy_log_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef entropy_log_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux_generic<Entropy_func, Mesh, Vel_Field, T> q_entropy(E, u, msh);


// NON LINEAR ENTROPY INITIALISATION NEW [-phimax, phimax]
//    entropy_log_phimax_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef entropy_log_phimax_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux_generic<Entropy_func,Mesh,Vel_Field,T> q_entropy(E , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC
//    T max_val = 14.0 ;
//    non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> E(max_val , phi ,msh );
//    typedef non_linear_entropy_quadratic_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic<Entropy_func2,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW QUADRATIC PIECEWISE
//    T max_val = 4.0 ; // 14.0
//    T pol_order = 8.0 ; // 2.0
//    non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> E(max_val , phi , msh,pol_order );
//    typedef non_linear_entropy_quadratic_piecewise_phimin_phimax<T,Fonction,Mesh> Entropy_func2;
//    entropy_flux_quadratic_piecewise<Entropy_func2,Mesh,Vel_Field,T> q_entropy(E , u , msh );


// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);


    Matrix<T, Dynamic, 1> entropic_flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> entropic_flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> entropic_flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> entropic_flux1 = Matrix<T, Dynamic, 1>::Zero(dim);



//    Matrix<T, Dynamic, 1> entropic_flux0_loc_prove = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
//    Matrix<T, Dynamic, 1> entropic_flux1_loc_prove = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
//
//    Matrix<T, Dynamic, 1> entropic_flux0_prove = Matrix<T, Dynamic, 1>::Zero(dim) ;
//    Matrix<T, Dynamic, 1> entropic_flux1_prove = Matrix<T, Dynamic, 1>::Zero(dim) ;



//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            auto phi_pt = phi(pts[i], msh, cl);
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi_pt;
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi_pt;

            auto val = q_entropy(pts[i], cl);
            entropic_flux0_loc(i) = val.first;
            entropic_flux1_loc(i) = val.second;

//            entropic_flux0_loc_prove(i) = q_entropy.values0_HHO(i,i_fl) ;
//            entropic_flux1_loc_prove(i) = q_entropy.values1_HHO(i,i_fl);
//            std::cout<<"val.first = "<<val.first<<std::endl;
//            std::cout<<"val.second = "<<val.second<<std::endl;
//            std::cout<<"entropic_flux0_loc_prove(i) = "<<entropic_flux0_loc_prove(i)<<std::endl;
//            std::cout<<"entropic_flux1_loc_prove(i) = "<<entropic_flux1_loc_prove(i)<<std::endl;
        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);


        Matrix<T, Dynamic, 1> sol0_entropic = cod.solve(entropic_flux0_loc);
        Matrix<T, Dynamic, 1> sol1_entropic = cod.solve(entropic_flux1_loc);

//        Matrix<T, Dynamic, 1> sol0_entropic_prove = cod.solve(entropic_flux0_loc_prove);
//        Matrix<T, Dynamic, 1> sol1_entropic_prove = cod.solve(entropic_flux1_loc_prove);

        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);


            entropic_flux0(asm_map) = sol0_entropic(i);
            entropic_flux1(asm_map) = sol1_entropic(i);

//            entropic_flux0_prove(asm_map) = sol0_entropic_prove(i) ;
//            entropic_flux1_prove(asm_map) = sol1_entropic_prove(i) ;



        }


        i_fl++;
    }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


//    std::cout << "entropic_flux0 - entropic_flux0_prove" <<'\n'<<entropic_flux0 - entropic_flux0_prove<<'\n' << std::endl;
//    std::cout << "entropic_flux1 - entropic_flux1_prove" <<'\n'<<entropic_flux1 - entropic_flux1_prove<<'\n' << std::endl;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    auto S_pt_cell = fe_data.S_pt_cell;


    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;

        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;

        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        auto E_der_i = E.derivative(pt_i, cl_i);
        for (auto &elem: row_i.second) {

            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;
//            std::cout<<"entropic_flux0(elem_j) - q_entropy(pt_i,cl_i) = "<<entropic_flux0(elem_j) - q_entropy(pt_i,cl_i).first<<std::endl;

            auto entr_flux0_j = entropic_flux0(elem_j);
            auto entr_flux1_j = entropic_flux1(elem_j);
            auto gl_c0_ij = global_cij_x.coeff(counter_row, elem_j);
            auto gl_c1_ij = global_cij_y.coeff(counter_row, elem_j);
            auto flux0_j = flux0(elem_j);
            auto flux1_j = flux1(elem_j);

            N_i_entropic += ((entr_flux0_j - E_der_i * flux0_j) * gl_c0_ij +
                             (entr_flux1_j - E_der_i * flux1_j) * gl_c1_ij);
            D_i_entropic0 += (entr_flux0_j * gl_c0_ij + entr_flux1_j * gl_c1_ij);
            D_i_entropic1 += (flux0_j * gl_c0_ij + flux1_j * gl_c1_ij);

            auto n0ij = nij0.coeff(counter_row, elem_j);
            auto n1ij = nij1.coeff(counter_row, elem_j);

            T value0 = std::abs(u0(counter_row) * n0ij + u1(counter_row) * n1ij);
            T value1 = std::abs(u0(elem_j) * n0ij + u1(elem_j) * n1ij);
            T value = std::max(value0, value1);

            auto n0ji = nji0.coeff(counter_row, elem_j);
            auto n1ji = nji1.coeff(counter_row, elem_j);

            T value_adj0 = std::abs(u0(counter_row) * n0ji + u1(counter_row) * n1ji);
            T value_adj1 = std::abs(u0(elem_j) * n0ji + u1(elem_j) * n1ji);
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);
            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j)
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


        }

        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E_der_i);

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
        if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i = "<<D_i<<std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
//            std::cout<<"Imposition of R_i = 1 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 1.0;
        }
        if (R_i(counter_row) < 0) {
//            std::cout<<"Imposition of R_i = 0 for i = "<<counter_row<<". It was R_i = "<<R_i(counter_row)<<std::endl;
            R_i(counter_row) = 0.0;
        }

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt
    auto CFL_numb_L = std::make_pair(10,
                                     1); // time_step_CFL_OK( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                dii_E(counter) -= value_E;
                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
        counter++;
    }


    size_t counter_row_prova = 0;

    postprocess_output<double> postoutput1;

    auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
    auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
    auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");
    auto test_Ri = std::make_shared < gnuplot_output_object < double > > ("test_Ri.dat");

    for (auto &row_i: S_pt_cell) {
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
        test_dii_dijE->add_data(pt_i, -dii(counter_row_prova) + dii_E(counter_row_prova));
        test_dii->add_data(pt_i, -dii(counter_row_prova));
        test_dijE->add_data(pt_i, -dii_E(counter_row_prova));
        test_Ri->add_data(pt_i, R_i(counter_row_prova));


        counter_row_prova++;

    }


    postoutput1.add_object(test_Ri);
    postoutput1.add_object(test_dii_dijE);
    postoutput1.add_object(test_dii);
    postoutput1.add_object(test_dijE);


    postoutput1.write();


//   auto CFL_numb_E = time_step_CFL_OK( dii_E , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );
//    std::cout<<"CFL low order = "<< CFL_numb_L.first << " , CFL entropic = "<<CFL_numb_E.first<<std::endl;
//    std::cout<<"TIME STEP: dt_cfl low order = "<< CFL_numb_L.second << " , dt_cfl entropic = "<<CFL_numb_E.second<<std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
    size_t counter_dir = 0;

    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
        if (dir_elem) {

            phi_E(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
    phi.sol_FEM = phi_E;
    phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    return CFL_numb_L;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING(const Mesh &msh,
                                                                                    const FiniteSpace &fe_data,
                                                                                    Fonction &phi, Vel_Field &u,
                                                                                    const Method_Transport &method,
                                                                                    T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;

    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION (OLD)
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

// NON LINEAR ENTROPY INITIALISATION NEW phimin phimax
//    non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new_phimin_phimax<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    T max_val = 14.0;
    non_linear_entropy_quadratic_phimin_phimax<T, Fonction, Mesh> E(max_val, phi, msh);
    typedef non_linear_entropy_quadratic_phimin_phimax<T, Fonction, Mesh> Entropy_func2;
    entropy_flux_quadratic<Entropy_func2, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);


// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

//            if( counter_row == 569 )
//            {
//                std::cout<<"elem = "<<elem<<" , q_entropy.values0(elem) = "<<q_entropy.values0(elem)<<" , E.E_der(counter_row) = "<<E.E_der(counter_row)<<" , flux0(elem) ="<<flux0(elem)<<" , global_cij_x.coeff(counter_row,elem) = "<<global_cij_x.coeff(counter_row,elem)<<std::endl;
//                std::cout<<"elem = "<<elem<<" , q_entropy.values1(elem) = "<<q_entropy.values1(elem)<<" , E.E_der(counter_row) = "<<E.E_der(counter_row)<<" , flux1(elem) ="<<flux1(elem)<<" , global_cij_y.coeff(counter_row,elem) = "<<global_cij_y.coeff(counter_row,elem)<<std::endl;
//                std::cout<<"elem = "<<elem<<" , q_entropy.values0(elem) - E.E_der(counter_row) = "<<q_entropy.values0(elem) - E.E_der(counter_row) <<" , q_entropy.values1(elem) - E.E_der(counter_row) = "<<q_entropy.values1(elem) - E.E_der(counter_row)<<" , Ni0(elem) = "<<(q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem)<<" , Ni1 = "<<(q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) <<std::endl;
//                std::cout<<"elem = "<<elem<<" , D_i_entropic0 = "<<D_i_entropic0<<" , D_i_entropic1 = "<<D_i_entropic1<<" , N_i_entropic ="<<N_i_entropic<<std::endl;
//            }

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

//        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
//            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
//            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
//        }
        if (std::abs(N_i_entropic) < 1e-14 && std::abs(D_i) < 1e-14) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-14);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i
                      << " , std::abs(N_i_entropic) = " << std::abs(N_i_entropic) << " , D_i = " << D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        if (R_i(counter_row) > 1) {

//            std::cout<<"counter_row = "<<counter_row<<" , R_i(counter_row) = "<<R_i(counter_row)<<" , std::abs(N_i_entropic) = "<<std::abs(N_i_entropic)<<" , D_i ="<<D_i<<std::endl;
//            std::cout<<"std::abs(D_i_entropic0) = "<<std::abs(D_i_entropic0)<<" , std::abs(D_i_entropic1) = "<<std::abs(D_i_entropic1)<<" , std::abs(E.E_der(counter_row)) ="<<std::abs(E.E_der(counter_row))<<std::endl;
            std::cout << "Imposition of R_i = 1 for i = " << counter_row << ". It was R_i = " << R_i(counter_row)
                      << std::endl;
            R_i(counter_row) = 1.0;
        }
        if (R_i(counter_row) < 0) {
            std::cout << "Imposition of R_i = 0 for i = " << counter_row << ". It was R_i = " << R_i(counter_row)
                      << std::endl;
            R_i(counter_row) = 0.0;
        }

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                dii_E(counter) -= value_E;
                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
//        if(dii_E(counter) < -0.1 )
//        {
//            std::cout<<"counter = "<<counter << " , dii_E(counter) = "<<dii_E(counter)<< " , dii_L(counter) = "<<dij.coeff( counter , counter )<<std::endl;
//
//            for(auto& elem:row_i)
//            {
//                auto R_ij_prova = std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) ) ;
//                std::cout<<"elem = "<<elem<<" , R_ij_prova = "<<R_ij_prova << " , value_E = "<<dij.coeff( counter , elem ) * R_ij_prova<<std::endl;
//            }
//
//        }
        counter++;
    }


    auto S_pt_cell = fe_data.S_pt_cell;
    size_t counter_row_prova = 0;

    postprocess_output<double> postoutput1;

    auto test_dii_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiL_diiE.dat");
    auto test_dii = std::make_shared < gnuplot_output_object < double > > ("test_diiL.dat");
    auto test_dijE = std::make_shared < gnuplot_output_object < double > > ("test_diiE.dat");

    for (auto &row_i: S_pt_cell) {
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        auto dii = dij.diagonal();
//            if( std::abs(dii_E(counter_row_prova) - dii(counter_row_prova))<= 1e-12 )
//                std::cout<< "counter = "<<counter_row_prova<< " , pt_i = "<<pt_i<< ", dii_E(counter) = "<<dii_E(counter_row_prova)<<", dii_L(counter) = "<<dii(counter_row_prova)<< std::endl;
        test_dii_dijE->add_data(pt_i, dii(counter_row_prova) - dii_E(counter_row_prova));
        test_dii->add_data(pt_i, dii(counter_row_prova));
        test_dijE->add_data(pt_i, dii_E(counter_row_prova));
        counter_row_prova++;

    }

    postoutput1.add_object(test_dii_dijE);
    postoutput1.add_object(test_dii);
    postoutput1.add_object(test_dijE);


    postoutput1.write();


    auto CFL_numb_E = time_step_CFL_OK(dii_E, global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);
//    std::cout<< "Entropic process."<< std::endl;
    std::cout << "CFL low order = " << CFL_numb_L.first << " , CFL entropic = " << CFL_numb_E.first << std::endl;
    std::cout << "TIME STEP: dt_cfl low order = " << CFL_numb_L.second << " , dt_cfl entropic = " << CFL_numb_E.second
              << std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
    phi.sol_FEM = phi_E;
    phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    return CFL_numb_E;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING_ANALYTIC_VEL(const Mesh &msh,
                                                                                                 const FiniteSpace &fe_data,
                                                                                                 Fonction &phi,
                                                                                                 Vel_Field &u,
                                                                                                 const Method_Transport &method,
                                                                                                 T &dt, bool mapping) {
// Starting time for FE calculation
//std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_lumped - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;

    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;





// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux_ANALYTIC_VEL<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;







// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u(pts[i])[0] * phi(pts[i], msh, cl);
            flux1_loc(i) = u(pts[i])[1] * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }

//
//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    auto S_pt_cell = fe_data.S_pt_cell;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;

    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i.second) {
            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;


//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy(pt_j, cl_j).first - E.E_der(counter_row) * flux0(elem_j)) *
                             global_cij_x.coeff(counter_row, elem_j) +
                             (q_entropy(pt_j, cl_j).second - E.E_der(counter_row) * flux1(elem_j)) *
                             global_cij_y.coeff(counter_row, elem_j));
            D_i_entropic0 += (q_entropy(pt_j, cl_j).first * global_cij_x.coeff(counter_row, elem_j) +
                              q_entropy(pt_j, cl_j).second * global_cij_y.coeff(counter_row, elem_j));
            D_i_entropic1 += (flux0(elem_j) * global_cij_x.coeff(counter_row, elem_j) +
                              flux1(elem_j) * global_cij_y.coeff(counter_row, elem_j));

            T value0 = std::abs(
                    u(pt_i)[0] * nij0.coeff(counter_row, elem_j) + u(pt_i)[1] * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(
                    u(pt_j)[0] * nij0.coeff(counter_row, elem_j) + u(pt_j)[1] * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u(pt_i)[0] * nji0.coeff(counter_row, elem_j) + u(pt_i)[1] * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(
                    u(pt_j)[0] * nji0.coeff(counter_row, elem_j) + u(pt_j)[1] * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem_j)
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    auto CFL_numb_L = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);


// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> dii_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                dii_E(counter) -= value_E;
//                std::cout<<"R_ij = "<<R_ij<<"value_E = "<<value_E<<std::endl;
                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
//        std::cout<<"Line = "<<counter<<" -> dii_E(counter) = "<<dii_E(counter)<<std::endl;
        counter++;
    }

    auto CFL_numb_E = time_step_CFL_OK(dii_E, global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);
//    std::cout<< "Entropic process."<< std::endl;
    std::cout << "CFL low order = " << CFL_numb_L.first << " , CFL entropic = " << CFL_numb_E.first << std::endl;
    std::cout << "TIME STEP: dt_cfl low order = " << CFL_numb_L.second << " , dt_cfl entropic = " << CFL_numb_E.second
              << std::endl;


///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
    phi.sol_FEM = phi_E;
    phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    return CFL_numb_L;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Method_Transport, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONSISTENT_NO_LIMITING(const Mesh &msh,
                                                                                        const FiniteSpace &fe_data,
                                                                                        Fonction &phi, Vel_Field &u,
                                                                                        const Method_Transport &method,
                                                                                        T &dt, bool mapping) {
// Starting time for FE calculation
//    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - M_consitent - No limiting) -----------"<<reset<<std::endl;


//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;

    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


//    if(!mapping){
////        phi.coefficients_mapping_MAX_MAX( );
//        phi.coefficients_mapping();
//    }

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
//    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
//    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
//    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new_phimin_phimax<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;
    auto global_mass = method.Global_Mass;
    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;


//    timecounter tc_solver;
//    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }

//    tc_solver.toc();
//    std::cout << "Inversion consistent mass matrix with Cholesky method. Time needed = " << tc_solver << " seconds." << reset << std::endl;




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


//    tc_solver2.toc();
//    std::cout << "Direct inversion of the local Vandermonde matrix." << std::endl;


// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//    std::cout << "Resolution of the low order transport." << std::endl;


// CHECK TIME STEP dt

//    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    auto CFL_numb = time_step_CFL_OK(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet, dt);



// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_ij = std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//                auto R_ij = 1.0 ;
                auto value_E = dij.coeff(counter, elem) * R_ij;
//                std::cout<<"R_ij = "<<std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) )<<std::endl;
                term_dij(counter) += value_E * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

//
//    std::cout<< "Entropic process."<< std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
//    Matrix<T, Dynamic, 1> phi_E = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij.cwiseQuotient(global_lumped_mass);

// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;

    Matrix<T, Dynamic, 1> b_phiE = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_E = solver_global_mass.solve(b_phiE);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection



//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

//       T relative_error0 = (global_mass*phi_E - b_phiE).norm() / b_phiE.norm();
//       std::cout << "The relative error in solving the transport problem (mass consistent) is: " << relative_error0 << std::endl;


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//    size_t counter_dir = 0 ;
//
//    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
//    {
//        if(dir_elem){
//            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
//            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
//            phi_new(counter_dir) = phi_FEM(counter_dir) ;
//        }
//        counter_dir++ ;
//    }


// SAVING AND UPLOAD phi_E  INTO CLASS projected_level_set
    phi.sol_FEM = phi_E;
    phi.converting_into_HHO_formulation(phi_E);

//    if(!mapping){
////        phi.coefficients_inverse_mapping_MAX_MAX( );
//        phi.coefficients_inverse_mapping();
//    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();



//    tc.toc();
//    std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;
//
//
//
//    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;

    return CFL_numb;
}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                        Vel_Field &u, T &dt, bool mapping) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED) -----------"
              << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


    if (!mapping) {
        phi.coefficients_mapping_MAX_MAX();
//phi.coefficients_mapping();
    }
//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
    non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
              << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
              << reset << std::endl;


    timecounter tc_case00;
    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row));

        if (std::abs(N_i_entropic) < 1e-20 && std::abs(D_i) < 1e-20) {
            R_i(counter_row) = std::abs(N_i_entropic) / (D_i + 1e-18);
            std::cout << "R_i = " << R_i(counter_row) << " , R_i^{OLD} = " << std::abs(N_i_entropic) / D_i << std::endl;
        } else
            R_i(counter_row) = std::abs(N_i_entropic) / D_i;


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
              << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

    T nu_max0 = CFL_numb / fe_data.hx;
    T nu0 = dt_old / fe_data.hx;
    T nu1 = dt / fe_data.hx;

    std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
              << " and with dt appeared by CFL COND " << nu1 << std::endl;

    if (dt_old != dt) {
        std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

    timecounter tc_case02;
    tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
    timecounter tc_case03;
    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                bool check_else = FALSE;
                T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
//std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
//std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
//auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
//std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max(1.0 - c_comp * value, 0.0);
                if (check_else) {
//std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                    value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
//std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;

    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
        if (dir_elem) {
//phi_L(counter_dir) = phi_FEM(counter_dir) ;
//phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);

    if (!mapping) {
        phi.coefficients_inverse_mapping_MAX_MAX();
//phi.coefficients_inverse_mapping();
    }
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP(const Mesh &msh, const FiniteSpace &fe_data,
                                                               Fonction &phi, Vel_Field &u, T &dt, bool mapping) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


    if (!mapping)
        phi.coefficients_mapping_MAX_MAX();

//phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
//phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
    non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
              << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
              << reset << std::endl;


    timecounter tc_case00;
    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        R_i(counter_row) = std::abs(N_i_entropic) /
                           (std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row)));


        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
              << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

    T nu_max0 = CFL_numb / fe_data.hx;
    T nu0 = dt_old / fe_data.hx;
    T nu1 = dt / fe_data.hx;

    std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
              << " and with dt appeared by CFL COND " << nu1 << std::endl;

    if (dt_old != dt) {
        std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

/*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

    timecounter tc_case02;
    tc_case02.tic();

/*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
    timecounter tc_case03;
    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

//auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
//auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
//bool check_else = FALSE;
//T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    //std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    //std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    //auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
/*
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    //std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    //std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;

                } // CONTROLLA QUAAAAA
                */
                auto value_dC_ij = value_E;  //* value_C ;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H (new method book Alexandre), t = " << tc_solver5 << " seconds"
              << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

//Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;

    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {
        if (dir_elem) {
//phi_L(counter_dir) = phi_FEM(counter_dir) ;
//phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);

    if (!mapping)
        phi.coefficients_inverse_mapping_MAX_MAX();
//phi.coefficients_inverse_mapping();
//phi_exact.coefficients_inverse_mapping();


    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u, T &dt) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM NEW D -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;


// NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14; //constant into entropy
    non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);
    typedef non_linear_entropy_new<T, Fonction, Mesh> Entropy_func;
    entropy_flux<Entropy_func, Fonction, Mesh, Vel_Field, T> q_entropy(E, phi, u, msh);

// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
/*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER LLT." << std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
              << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"
              << reset << std::endl;


    timecounter tc_case00;
    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
//Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
//Emax_global *= -1e20;
//Emin_global *= 1e20;

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

//Matrix<T, Dynamic, 1> R_i_prova = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for (auto &elem: row_i) {

//Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
//Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ((q_entropy.values0(elem) - E.E_der(counter_row) * flux0(elem)) *
                             global_cij_x.coeff(counter_row, elem) +
                             (q_entropy.values1(elem) - E.E_der(counter_row) * flux1(elem)) *
                             global_cij_y.coeff(counter_row, elem));
            D_i_entropic0 += (q_entropy.values0(elem) * global_cij_x.coeff(counter_row, elem) +
                              q_entropy.values1(elem) * global_cij_y.coeff(counter_row, elem));
            D_i_entropic1 += (flux0(elem) * global_cij_x.coeff(counter_row, elem) +
                              flux1(elem) * global_cij_y.coeff(counter_row, elem));

            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));

        R_i(counter_row) = std::abs(N_i_entropic) /
                           (std::abs(D_i_entropic0) + std::abs(D_i_entropic1) * std::abs(E.E_der(counter_row)));
//R_i_prova(counter_row) = std::abs(N_i_entropic) ;

        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset
              << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

    T nu_max0 = CFL_numb / fe_data.hx;
    T nu0 = dt_old / fe_data.hx;
    T nu1 = dt / fe_data.hx;

    std::cout << "VALID FOR u = (1,0). nu_max VERO = " << nu_max0 << " , nu max con dt assegnato = " << nu0
              << " and with dt appeared by CFL COND " << nu1 << std::endl;

    if (dt_old != dt) {
        std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;


/*

    // CONSTANT TERM (PHI TILDE PROBLEM)
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;

*/

/*
    timecounter tc_case02;
    tc_case02.tic();

    // TERM R_i^n

    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        //auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    //R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i_prova<<" , "<<R_i_bis<<" , DIFF -> "<<R_i_prova- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
*/
    timecounter tc_case03;
    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
//auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff(counter, elem) * R_i_j;
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//T value = 0.0;
                bool check_else = FALSE;
                T value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
/*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
                    std::cout << "SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "
                              << std::abs(phi_FEM(counter) - phi_FEM(elem)) << " and value_2 = " << value_2
                              << std::endl;
                    std::cout << "elem = " << elem << " and counter = " << counter << std::endl;
                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    std::cout << "1.0 - c_comp * value = " << (1.0 - c_comp * value) << " and value_C = " << value_C
                              << std::endl;
                    check_else = TRUE;
                }
/*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max(1.0 - c_comp * value, 0.0);
                if (check_else) {
                    std::cout << "value_C GIUSTO = " << value_C << std::endl;
                    value = (value_2) / (std::abs(phi_FEM(counter) - phi_FEM(elem)) + 1e-18);
                    value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
                    std::cout << "Se NaN-> metto dC = 0!!! -> value_C CORRETTO = " << value_C << '\n' << std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

//auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

//std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
//std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

//T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

//std::cout << "The PROVA error is: " << error1_prova << std::endl;
//std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
            phi_H(counter_dir) = phi_FEM(counter_dir);
            phi_new(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }

    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);
    phi.coefficients_inverse_mapping();

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_CORRECT_FAST(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u, T &dt) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;


// NON LINEAR ENTROPY INITIALISATION
    const T eps = 1e-14; //constant into entropy
    non_linear_entropy_new<T, Fonction, Mesh> E(eps, phi, msh);


// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);


// SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
//ConjugateGradient<SparseMatrix<T> > solver_global_mass;

    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER 0->phi_tilde" << std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset
              << std::endl;


/*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




// ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << std::endl;


    timecounter tc_case00;
    tc_case00.tic();

// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM;
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;

// TERM R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;


    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {

            Emax_global(counter_row) = std::max(E.E_values(elem), Emax_global(counter_row));
            Emin_global(counter_row) = std::min(E.E_values(elem), Emin_global(counter_row));


            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;

            if (counter_row != elem)
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if (dt_old != dt) {
        std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




// CONSTANT TERM (PHI TILDE PROBLEM)
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt * conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


    timecounter tc_solver3;
    tc_solver3.tic();

// RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection

// norm() is L2 norm
    T relative_error0 = (global_mass * phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;

/*
    auto prova_phi_tilde_2 = solver2_bis.solve(b);
    T relative_error2 = (global_mass*prova_phi_tilde_2 - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;


    if(solver_global_mass.info()!=Success) {
        std::cout<<"FAILED SOLVER 1->phi_tilde"<<std::endl;
        exit(1);
    }
    */
    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

// SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout << "CONVERTING phi_tilde" << std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation(phi_tilde.sol_FEM);
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


    timecounter tc_case02;
    tc_case02.tic();

// TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for (auto &cl: msh.cells) {
        size_t di = 1;
        size_t offset_cell = offset(msh, cl);
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
//auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
//auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto &qp: qps) {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first, msh, cl)(0);
            auto phi_grad1 = phi.gradient(qp.first, msh, cl)(1);

            auto f = (((phi_tilde(qp.first, msh, cl) - phi(qp.first, msh, cl)) / dt +
                       u(qp.first, msh, cl).first * phi_grad0 + u(qp.first, msh, cl).second * phi_grad1) *
                      E.derivative(qp.first, cl));
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++) {
            size_t asm_map = phi.connectivity_matrix[offset_cell][i].first;
            R_i(asm_map) += ret(i);
        }

    }


// R_i FINALISATION:
//std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
//R_i = R_i.cwiseQuotient( Emax_global - Emin_global );
//std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
//std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;

    timecounter tc_case03;
    tc_case03.tic();

// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix <T> dC_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {

                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
                auto value_E = std::min(dij.coeff(counter, elem), R_i_j);
//triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
                auto value_2 = std::max(value_1 * (1.0 - value_1), 0.0);

                bool check_else = FALSE;
//triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
//if( std::abs(phi_FEM(counter_tmp) - phi_FEM(elem))>1e-15 ){
                auto value = value_2 / (std::abs(phi_FEM(counter) - phi_FEM(elem)));

                if ((std::abs(phi_FEM(counter) - phi_FEM(elem)) < 1e-20) && (std::abs(value_2) < 1e-20)) {
                    std::cout << "SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "
                              << std::abs(phi_FEM(counter) - phi_FEM(elem)) << " and value_2 = " << value_2
                              << std::endl;
                    std::cout << "elem = " << elem << " and counter = " << counter << std::endl;

                    auto value_C = std::max(1.0 - c_comp * value, 0.0);
                    std::cout << "1.0 - c_comp * value = " << (1.0 - c_comp * value) << " and value_C = " << value_C
                              << std::endl;
                    check_else = TRUE;
                }


                auto value_C = std::max(1.0 - c_comp * value, 0.0);
                if (check_else) {
                    std::cout << "value_C GIUSTO = " << value_C << std::endl;
                    value = (value_2 + 1e-18) / (std::abs(phi_FEM(counter) - phi_FEM(elem)));
                    value_C = std::max(1.0 - c_comp * value, 0.0);
//value_C = 1.0;
                    std::cout << "Se NaN-> metto dC = 0!!! -> value_C CORRETTO = " << value_C << std::endl;
                }

                auto value_dC_ij = value_E * value_C;
                triplets_dC_ij.push_back(Triplet<T>(counter, elem, value_dC_ij));

                term_dij_no_entropy(counter) += dij.coeff(counter, elem) * (phi_FEM(elem) - phi_FEM(counter));

                term_dij(counter) += value_dC_ij * (phi_FEM(elem) - phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets(triplets_dC_ij.begin(), triplets_dC_ij.end());
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

    relative_error0 = (global_mass * phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
/*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
            phi_H(counter_dir) = phi_FEM(counter_dir);
            phi_new(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }

    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;
    phi.converting_into_HHO_formulation(phi_new);
    phi.coefficients_inverse_mapping();

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Transport_Method, typename T = typename Mesh::coordinate_type>
std::pair <T, T>
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                                   Fonction &phi, Vel_Field &u,
                                                                   const Transport_Method &method, T &dt) {
// Starting time for FE calculation
//    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND) -----------"<<std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

//    timecounter tc;
//    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;
//    std::cout<<"u0"<<'\n'<<u0<<'\n'<<std::endl;
//    std::cout<<"u0_cellwise"<<'\n'<<u0_cellwise<<std::endl;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;





// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//    timecounter tc_solver2;
//    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            auto phi_pt = phi(pts[i], msh, cl);
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi_pt;
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi_pt;

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


//    tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



//    timecounter tc_case00;
//    tc_case00.tic();



// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//    Matrix<T, Dynamic, 1> conv_global = (flux0.transpose()*global_cij_x + flux1.transpose()*global_cij_y).transpose();


// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {
            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//    tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
    auto CFL_numb = std::make_pair(10,
                                   1); //time_step_CFL_OK( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );



//    std::cout<<"------------------------------------UNSTEADY STOKES CFL COND PROVA!!!!! "<<std::endl;
//    T CFL_numb = time_step_CFL_unstesdy_Stokes( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;

    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary_inlet) {

//std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }








// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);



//    tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


//    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



//return phi_tilde;
    return CFL_numb;
}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename Transport_Method, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh &msh, const FiniteSpace &fe_data,
                                                                   Fonction &phi, Vel_Field &u,
                                                                   const Transport_Method &method, T &dt,
                                                                   const FiniteSpace &fe_data_u) {
// Starting time for FE calculation
    std::cout << "----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND - VEL L^\tilde{k}) -----------"
              << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;

    auto S_pt_cell = fe_data.S_pt_cell;

//size_t degree_u = fe_data_u.order; // finite element order
//size_t dim_u = fe_data_u.ndof_FE ;
//size_t n_cls = fe_data.n_cls ;
//size_t local_ndof_u = fe_data_u.local_ndof ; // local degrees of freedom
//auto S_i_u = fe_data_u.S_i;
//auto S_pt_cell_u = fe_data_u.S_pt_cell ;
//std::cout<<"HP: DoF velocity > DoF level set . "<<std::endl;
//if( degree_u > degree)
//    exit(10) ;

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x;
    auto global_cij_y = method.Global_c_term_y;
    auto local_vandermonde = method.local_vandermonde;

    auto cij_norm = method.cij_norm;
    auto nij0 = method.nij0;
    auto nij1 = method.nij1;

    auto cji_norm = method.cij_norm;
    auto nji0 = method.nji0;
    auto nji1 = method.nji1;





// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);

        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u(pts[i], msh, cl).first * phi(pts[i], msh, cl);
            flux1_loc(i) = u(pts[i], msh, cl).second * phi(pts[i], msh, cl);

        }


        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        for (auto &elem: row_i.second) {
            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;
            T value0 = std::abs(u(pt_i, msh, cl_i).first * nij0.coeff(counter_row, elem_j) +
                                u(pt_i, msh, cl_i).second * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(u(pt_j, msh, cl_j).first * nij0.coeff(counter_row, elem_j) +
                                u(pt_j, msh, cl_j).second * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(u(pt_i, msh, cl_i).first * nji0.coeff(counter_row, elem_j) +
                                    u(pt_i, msh, cl_i).second * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(u(pt_j, msh, cl_j).first * nji0.coeff(counter_row, elem_j) +
                                    u(pt_j, msh, cl_j).second * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem_j) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();
/*
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
     dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );

     triplets_dij.clear();
    */





    tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "CHECKING OF CFL CONDITION (ALEXANDRE BOOK):" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet,
                                               dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;
    std::cout << "CFL condition ---------> dt =  " << CFL_numb << std::endl;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
/*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << "----------- FINE TRANSPORT PROBLEM -----------" << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                            Vel_Field &u, T &dt) {
// Starting time for FE calculation
    std::cout << "----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND) -----------" << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;





// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {
            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "CHECKING OF CFL CONDITION (ALEXANDRE BOOK):" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet,
                                               dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;
    std::cout << "CFL condition ---------> dt =  " << CFL_numb << std::endl;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
/*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << "----------- FINE TRANSPORT PROBLEM -----------" << std::endl;



//return phi_tilde;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                            Vel_Field &u, T &dt, const FiniteSpace &fe_data_u) {
// Starting time for FE calculation
    std::cout << "----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND - VEL L^\tilde{k}) -----------"
              << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;

    auto S_pt_cell = fe_data.S_pt_cell;

    size_t degree_u = fe_data_u.order; // finite element order
//size_t dim_u = fe_data_u.ndof_FE ;
//size_t n_cls = fe_data.n_cls ;
//size_t local_ndof_u = fe_data_u.local_ndof ; // local degrees of freedom
//auto S_i_u = fe_data_u.S_i;
//auto S_pt_cell_u = fe_data_u.S_pt_cell ;
//std::cout<<"HP: DoF velocity > DoF level set . "<<std::endl;
//if( degree_u > degree)
//    exit(10) ;

// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;
//auto phi_exact_FEM = phi_exact.sol_FEM ;



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;





// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);

        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u(pts[i], msh, cl).first * phi(pts[i], msh, cl);
            flux1_loc(i) = u(pts[i], msh, cl).second * phi(pts[i], msh, cl);

        }


        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
//std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_pt_cell) {
        T sum_row = 0.0;
        auto pt_i = row_i.first.first;
        auto cl_i = row_i.first.second;
        for (auto &elem: row_i.second) {
            auto pt_j = elem.second.first;
            auto cl_j = elem.second.second;
            size_t elem_j = elem.first;
            T value0 = std::abs(u(pt_i, msh, cl_i).first * nij0.coeff(counter_row, elem_j) +
                                u(pt_i, msh, cl_i).second * nij1.coeff(counter_row, elem_j));
            T value1 = std::abs(u(pt_j, msh, cl_j).first * nij0.coeff(counter_row, elem_j) +
                                u(pt_j, msh, cl_j).second * nij1.coeff(counter_row, elem_j));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(u(pt_i, msh, cl_i).first * nji0.coeff(counter_row, elem_j) +
                                    u(pt_i, msh, cl_i).second * nji1.coeff(counter_row, elem_j));
            T value_adj1 = std::abs(u(pt_j, msh, cl_j).first * nji0.coeff(counter_row, elem_j) +
                                    u(pt_j, msh, cl_j).second * nji1.coeff(counter_row, elem_j));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem_j);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem_j);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem_j)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem_j) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem_j, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem_j) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
//std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();
/*
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
     dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );

     triplets_dij.clear();
    */





    tc_case00.toc();
//std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "CHECKING OF CFL CONDITION (ALEXANDRE BOOK):" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary_inlet,
                                               dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;
    std::cout << "CFL condition ---------> dt =  " << CFL_numb << std::endl;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
//std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
/*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
//std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << "----------- FINE TRANSPORT PROBLEM -----------" << std::endl;



//return phi_tilde;

}

template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u,
                                         T &dt) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM LOW ORDER FAST -----------" << reset
              << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;



// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;





// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);

    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << std::endl;


    timecounter tc_case00;
    tc_case00.tic();



// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;



// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {
            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;

    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);
    std::cout << "----------------------> COND IN TEMPO CFL t_CFL = " << CFL_numb << " (ALEXANDRE BOOK)" << std::endl;
//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if (dt_old != dt) {
        dt = floorf(CFL_numb * 0.98 * 1000) / 1000;
        std::cout << yellow << bold << "ATTENTION CHANGIN dt!!! ----> " << reset << "dt is " << dt_old
                  << " and dt CFL is " << dt << " !" << std::endl;
//exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }







// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check_C_NEW(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                        Vel_Field &u, T &dt, Matrix<T, Dynamic, 1> &phi2,
                                                        Matrix<T, Dynamic, 1> &phi3, int i_prova,
                                                        Matrix<T, Dynamic, 1> &vecprova0,
                                                        Matrix<T, Dynamic, 1> &vecprova1,
                                                        Matrix<T, Dynamic, 1> &vecprova2,
                                                        Matrix<T, Dynamic, 1> &vecprovabis0,
                                                        Matrix<T, Dynamic, 1> &vecprovabis1,
                                                        Matrix <T, Dynamic, Dynamic> &vecprovabis2,
                                                        Matrix <T, Dynamic, Dynamic> &vecprovabis3,
                                                        Matrix <T, Dynamic, Dynamic> &vecprovabis4,
                                                        Matrix <T, Dynamic, Dynamic> &vecprovabis5,
                                                        Matrix<T, Dynamic, 1> &vecprovabis6,
                                                        Matrix<T, Dynamic, 1> &vecprovabis7) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- CHECKING ---> TRANSPORT PROBLEM LOW ORDER FAST -----------" << reset
              << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;

    std::cout << "IMPORTANTEEEEE --------------------------_> i = " << i_prova << std::endl;

// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

//auto global_cij_x = phi.Global_c_term_x ;
//auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde;


//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;
    SparseMatrix <T> global_cij_x; // Global mass, saved for FEM problem
    SparseMatrix <T> global_cij_y;
    global_cij_x = SparseMatrix<T>(dim, dim); //(b_i,b_j)_ij , b_i Lagrange basis fx
    global_cij_y = SparseMatrix<T>(dim, dim); //(b_i,b_j)_ij , b_i Lagrange basis fx
    std::vector <Triplet<T>> triplets_c_term_x_l; // Position elements: Sparse Matrix Notation
    std::vector <Triplet<T>> triplets_c_term_y_l; // Position elements: Sparse Matrix Notation
    for (const auto &cl: msh.cells) {
        size_t cell_offset = offset(msh, cl);
//auto local_cij_lagrangian = make_lagrangian_local_cij_matrix (msh, cl, degree);
        auto local_cij_lagrangian = make_bernstein_local_cij_matrix_with_velocity(msh, cl, degree, u);
        auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
//std::cout<< "local_cij_lagrangian.first "<<'\n'<<local_cij_lagrangian.first<<std::endl;


// Assembling triplets for global problem
        for (size_t i = 0; i < local_ndof; i++) {
            size_t asm_map_i = phi.connectivity_matrix[cell_offset][i].first;
            for (size_t j = 0; j < local_ndof; j++) {
                size_t asm_map_j = phi.connectivity_matrix[cell_offset][j].first;
                triplets_c_term_x_l.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij_lagrangian.first(i, j)));
                triplets_c_term_y_l.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij_lagrangian.second(i, j)));

            }
        }

    }

    global_cij_x.setFromTriplets(triplets_c_term_x_l.begin(), triplets_c_term_x_l.end());
    triplets_c_term_x_l.clear();

    global_cij_y.setFromTriplets(triplets_c_term_y_l.begin(), triplets_c_term_y_l.end());
    triplets_c_term_y_l.clear();
/*
    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;
    */
    SparseMatrix <T> cij_norm = (global_cij_x.cwiseProduct(global_cij_x) +
                                 global_cij_y.cwiseProduct(global_cij_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
    SparseMatrix <T> nij0 = global_cij_x.cwiseQuotient(cij_norm);
    SparseMatrix <T> nij1 = global_cij_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
    SparseMatrix <T> cji_x = global_cij_x.adjoint();
    SparseMatrix <T> cji_y = global_cij_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
    SparseMatrix <T> cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
    SparseMatrix <T> nji0 = cji_x.cwiseQuotient(cji_norm);
    SparseMatrix <T> nji1 = cji_y.cwiseQuotient(cji_norm);


    Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_y.rows(), 1);

    for (size_t k = 0; k < global_cij_x.cols(); k++) {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i = 0; i < global_cij_x.rows(); i++) {
        std::cout << "The sum is " << sum1(i) << " and " << sum0(i) << std::endl;
    }


    for (size_t counter_sum = 0; counter_sum < global_cij_x.rows(); counter_sum++) {
        for (size_t counter_col = 0; counter_col < global_cij_x.cols(); counter_col++) {

            if (counter_col == counter_sum)
                std::cout << "In (" << counter_sum << " , " << counter_col << " ), c^0 = "
                          << global_cij_x.coeff(counter_sum, counter_col) << " and c1 = "
                          << global_cij_y.coeff(counter_sum, counter_col) << std::endl;
            else
                std::cout << "In (" << counter_sum << " , " << counter_col << " ), c^0_ij + c^0_ji = "
                          << global_cij_x.coeff(counter_sum, counter_col) + global_cij_x.coeff(counter_col, counter_sum)
                          << " and c^1_ij + c^1_ji = "
                          << global_cij_y.coeff(counter_sum, counter_col) + global_cij_y.coeff(counter_col, counter_sum)
                          << std::endl;
        }
    }


// VANDERMONDE MATRIX INTERPOLATION
//size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    Matrix<T, Dynamic, 1> flux0_prova = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1_prova = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux0_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> vel2_loc0 = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> sol_vel_gl0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> vel2_loc1 = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> sol_vel_gl1 = Matrix<T, Dynamic, 1>::Zero(dim);

/*
    Matrix<T, Dynamic, Dynamic> sol_vel_gl_cellwise = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,msh.cells.size()) ;
    Matrix<T, Dynamic, Dynamic> one_loc = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,local_ndof) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);
    ColPivHouseholderQR<Matrix<T, Dynamic, Dynamic > > cod_bis(local_vandermonde);


    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            //std::cout<<"pts[i] = "<<pts[i] << " HHO_u0 = "<<u0_cellwise(i,i_fl)<<std::endl;
            flux0_prova_loc(i) = u0_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            flux1_prova_loc(i) = u1_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            vel2_loc0(i) = u0_cellwise(i,i_fl) ;
            vel2_loc1(i) = u1_cellwise(i,i_fl) ;
            one_loc(i,i) = 1.0;
            if(i_prova == 0){
                //std::cout<<"phi(" << pts[i] <<", msh , cl ) = "<<phi(pts[i] , msh , cl )<<std::endl;
                vecprovabis4(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
            }
            else
                vecprovabis5(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
        }

        Matrix<T, Dynamic, 1> sol0_bis = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1_bis = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0 = cod_bis.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod_bis.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol_vel0 = cod_bis.solve(vel2_loc0);
        Matrix<T, Dynamic, 1> sol_vel1 = cod_bis.solve(vel2_loc1);
        Matrix<T, Dynamic, Dynamic> check_inversion = cod_bis.solve(one_loc);

        //T relative_error01 = (local_vandermonde*sol_vel- vel2_loc).norm() / vel2_loc.norm();
        //std::cout << "The relative error0 of VELOCITY is: " << relative_error01 << std::endl;


        //std::cout<<"Cell = "<<offset(msh,cl)<<", check_inversion_Vandermonde = "<<'\n'<<check_inversion <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", vel2_loc = "<<'\n'<<vel2_loc <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC = "<<'\n'<<sol_vel <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC - u0 LOC = "<<'\n'<<sol_vel - u0_cellwise.col(i_fl)  <<std::endl;

        if(i_prova == 0){
        //std::cout<<"-------------------> sol0 - sol0_bis "<<'\n'<< sol0 - sol0_bis<<std::endl;
        //std::cout<<"-------------------> sol1 - sol1_bis "<<'\n'<< sol1 - sol1_bis<<std::endl;
            vecprovabis2.col(offset(msh,cl)) = flux0_loc  ; // è quello +0.5
            vecprovabis3.col(offset(msh,cl)) = flux1_loc  ; // è quello +0.5

        }
        if(i_prova == 1)
        {
            //std::cout<<"-------------------> sol0 - vecprovabis2 "<<'\n'<< flux0_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> sol1 - vecprovabis3 "<<'\n'<< flux1_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 0 LOC"<<'\n'<< flux0_prova_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 1 LOC"<<'\n'<< flux1_prova_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;

            //std::cout<<"-------------------> CHECK phi VAL LOC ----------"<<'\n'<< vecprovabis5.col(offset(msh,cl)) - vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL +0.5 ----------"<<'\n'<<  vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL OLD ----------"<<'\n'<<  vecprovabis5.col(offset(msh,cl))<<std::endl;


        }

        Matrix<T, Dynamic, 1>     sol0_prova = cod.solve(flux0_prova_loc);
        Matrix<T, Dynamic, 1>     sol1_prova = cod.solve(flux1_prova_loc);



        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }
        //T relative_error0 = (local_vandermonde*sol0_prova - flux0_prova_loc).norm() / flux0_prova_loc.norm();
        //T relative_error1 = (local_vandermonde*sol1_prova - flux1_prova_loc).norm() / flux1_prova_loc.norm();
        //T relative_error2 = (local_vandermonde*sol0 - flux0_loc).norm() / flux0_loc.norm();
        //T relative_error3 = (local_vandermonde*sol1- flux1_loc).norm() / flux1_loc.norm();
        //std::cout << "The relative error0 is: " << relative_error0 << std::endl;
        //std::cout << "The relative error1 is: " << relative_error1<< std::endl;
        //std::cout << "The relative error2 is: " << relative_error2 << std::endl;
        //std::cout << "The relative error3 is: " << relative_error3<< std::endl;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;
            flux0_prova(asm_map) = sol0_prova(i) ;
            flux1_prova(asm_map) = sol1_prova(i) ;
            sol_vel_gl0(asm_map) = sol_vel0(i) ;
            sol_vel_gl1(asm_map) = sol_vel1(i) ;
            sol_vel_gl_cellwise(i,i_fl) = sol_vel0.dot( cb.eval_basis(pts[i]) );
        }


        i_fl++;
    }

    */


// auto check_div_u = 1.0/2.0 * global_cij_x *sol_vel_gl0   + global_cij_y * sol_vel_gl1 ;
// auto check_div_u_2 = 1.0/2.0 * Global_c_term_x_lagrangian *u0   + Global_c_term_y_lagrangian * u1 ;

//std::cout<<"----------CHECK DIV Bernstein -> "<<'\n'<<check_div_u<<std::endl;
//std::cout<<"----------CHECK DIV Lagrangian -> "<<'\n'<<check_div_u_2<<std::endl;

/*
    for(auto& cl:msh.cells)
    {
        size_t cell_offset = offset(msh, cl) ;
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++)
        {
            auto pt = pts[i];
            std::cout<<"In pt = "<<pt<<" --> u0(pt) = "<<u(pt,msh,cl).first<<" and ERROR = "<<  (u(pt,msh,cl).first - sol_vel_gl_cellwise(i,cell_offset))<<std::endl;
        }

    }

    //std::cout<<"-------------------> sol_vel - u0 "<<'\n'<< sol_vel_gl - u0<<std::endl;


    tc_solver2.toc();
    std::cout  << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"  << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    if(i_prova == 1){
        //std::cout<<"----->CHECK PROJECTION flux0 = "<<'\n'<<flux0 +0.5*u0 - vecprovabis0 <<std::endl;
        //std::cout<<"----->CHECK PROJECTION flux1 = "<<'\n'<<flux1 +0.5*u1 - vecprovabis1 <<std::endl;

        std::cout<<"----->CHECK PROJECTION flux0 TEORIC = "<<'\n'<<vecprovabis0 - flux0_prova<<std::endl;

        std::cout<<"----->CHECK PROJECTION flux1 TEORIC = "<<'\n'<<vecprovabis1 - flux1_prova <<std::endl;


        //std::cout<<"---> flux0 ERROR = "<<'\n'<<flux0 - vecprovabis0 <<std::endl;
        //std::cout<<"---> flux1 ERROR = "<<'\n'<<flux1 - vecprovabis1 <<std::endl;
        //std::cout<<"---> flux0  = "<<'\n'<<flux0  <<std::endl;
        //std::cout<<"---> flux1  = "<<'\n'<<flux1  <<std::endl;
        //std::cout<<"---> u0_cellwise = "<<'\n'<<u0_cellwise - vecprovabis2 <<std::endl;
        //std::cout<<"---> u1_cellwise = "<<'\n'<<u1_cellwise - vecprovabis3 <<std::endl;
        //std::cout<<"---> phi_FEM = "<<'\n'<<phi_FEM - vecprovabis4 <<std::endl;
        //std::cout<<"---> global_cij_x = "<<'\n'<<global_cij_x - vecprovabis5 <<std::endl;
        //std::cout<<"---> global_cij_y = "<<'\n'<<global_cij_y - vecprovabis6 <<std::endl;

    }
    if(i_prova == 0){
        vecprovabis0 = flux0 ;
        vecprovabis1 = flux1 ;


    }
    */
// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * phi_FEM + global_cij_y * phi_FEM;
//Matrix<T, Dynamic, 1> prova0_fl =  0.5*(global_cij_x * u0  + global_cij_y * u1) ;
    Matrix<T, Dynamic, 1> prova0_fl1 = global_cij_x * flux0_prova + global_cij_y * flux1_prova;

    if (i_prova == 0)
        vecprova2 = conv_global;

    if (i_prova == 1) {
//std::cout<<"---> prova0_fl = "<<'\n'<<prova0_fl - vecprovabis7 <<std::endl;
//std::cout<<"------> prova0_fl_somma phi_tilde convolution = "<<'\n'<<vecprova2 - conv_global - vecprovabis7  <<std::endl;
        std::cout << "------> CHECK CONVOLUTION +0.5 = " << '\n' << prova0_fl1 - vecprova2 << std::endl;
    }
//if(i_prova == 0)//{
//vecprovabis7 = prova0_fl ;
//}
//if(i_prova == 1)
//std::cout<<"--------->   conv_global = "<<'\n'<<conv_global - vecprova2 <<std::endl;


// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {
            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();



//tc_case00.toc();
//std::cout  << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if (dt_old != dt) {
        dt = floorf(CFL_numb * 0.98 * 1000) / 1000;
        std::cout << yellow << bold << "ATTENTION CHANGIN dt!!! ----> " << reset << "dt is " << dt_old
                  << " and dt CFL is " << dt << " !" << std::endl;
//exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

    if (i_prova == 1)
//  std::cout<<"global_lumped_mass = "<<'\n'<<global_lumped_mass - vecprova0 <<std::endl;
        if (i_prova == 0)
            vecprova0 = global_lumped_mass;

    if (i_prova == 1)
//  std::cout<<"term_dij_no_entropy = "<<'\n'<<term_dij_no_entropy - vecprova1 <<std::endl;
        if (i_prova == 0)
            vecprova1 = term_dij_no_entropy;



// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


    if (i_prova == 1)
//   std::cout<<"phi_FEM = "<<'\n'<<phi_FEM - phi2 <<std::endl;

        if (i_prova == 0)
            phi2 = phi_FEM;


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi,
                                                  Vel_Field &u, T &dt, Matrix<T, Dynamic, 1> &phi2,
                                                  Matrix<T, Dynamic, 1> &phi3, int i_prova,
                                                  Matrix<T, Dynamic, 1> &vecprova0, Matrix<T, Dynamic, 1> &vecprova1,
                                                  Matrix<T, Dynamic, 1> &vecprova2, Matrix<T, Dynamic, 1> &vecprovabis0,
                                                  Matrix<T, Dynamic, 1> &vecprovabis1,
                                                  Matrix <T, Dynamic, Dynamic> &vecprovabis2,
                                                  Matrix <T, Dynamic, Dynamic> &vecprovabis3,
                                                  Matrix <T, Dynamic, Dynamic> &vecprovabis4,
                                                  Matrix <T, Dynamic, Dynamic> &vecprovabis5,
                                                  Matrix<T, Dynamic, 1> &vecprovabis6,
                                                  Matrix<T, Dynamic, 1> &vecprovabis7) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- CHECKING ---> TRANSPORT PROBLEM LOW ORDER FAST -----------" << reset
              << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
    auto u0_cellwise = u.sol_HHO.first;
    auto u1_cellwise = u.sol_HHO.second;

    std::cout << "IMPORTANTEEEEE --------------------------_> i = " << i_prova << std::endl;

// SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

    auto cij_norm = phi.cij_norm;
    auto nij0 = phi.nij0;
    auto nij1 = phi.nij1;

    auto cji_norm = phi.cij_norm;
    auto nji0 = phi.nji0;
    auto nji1 = phi.nji1;

//std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;
    SparseMatrix <T> Global_c_term_x_lagrangian; // Global mass, saved for FEM problem
    SparseMatrix <T> Global_c_term_y_lagrangian;
    Global_c_term_x_lagrangian = SparseMatrix<T>(dim, dim); //(b_i,b_j)_ij , b_i Lagrange basis fx
    Global_c_term_y_lagrangian = SparseMatrix<T>(dim, dim); //(b_i,b_j)_ij , b_i Lagrange basis fx
    std::vector <Triplet<T>> triplets_c_term_x_l; // Position elements: Sparse Matrix Notation
    std::vector <Triplet<T>> triplets_c_term_y_l; // Position elements: Sparse Matrix Notation
    for (const auto &cl: msh.cells) {
        size_t cell_offset = offset(msh, cl);
//auto local_cij_lagrangian = make_lagrangian_local_cij_matrix (msh, cl, degree);
        auto local_cij_lagrangian = make_bernstein_local_cij_matrix_with_velocity(msh, cl, degree, u);
        auto qps = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
//std::cout<< "local_cij_lagrangian.first "<<'\n'<<local_cij_lagrangian.first<<std::endl;


// Assembling triplets for global problem
        for (size_t i = 0; i < local_ndof; i++) {
            size_t asm_map_i = phi.connectivity_matrix[cell_offset][i].first;
            for (size_t j = 0; j < local_ndof; j++) {
                size_t asm_map_j = phi.connectivity_matrix[cell_offset][j].first;
                triplets_c_term_x_l.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij_lagrangian.first(i, j)));
                triplets_c_term_y_l.push_back(Triplet<T>(asm_map_i, asm_map_j, local_cij_lagrangian.second(i, j)));

            }
        }

    }

    Global_c_term_x_lagrangian.setFromTriplets(triplets_c_term_x_l.begin(), triplets_c_term_x_l.end());
    triplets_c_term_x_l.clear();

    Global_c_term_y_lagrangian.setFromTriplets(triplets_c_term_y_l.begin(), triplets_c_term_y_l.end());
    triplets_c_term_y_l.clear();

    Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(Global_c_term_x_lagrangian.rows(), 1);

    Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(Global_c_term_y_lagrangian.rows(), 1);

    for (size_t k = 0; k < global_cij_x.cols(); k++) {
        sum0 += (Global_c_term_x_lagrangian).col(k);
        sum1 += (Global_c_term_y_lagrangian).col(k);
    }

    for (size_t i = 0; i < Global_c_term_x_lagrangian.rows(); i++) {
        std::cout << "The sum is " << sum1(i) << " and " << sum0(i) << std::endl;
    }


    for (size_t counter_sum = 0; counter_sum < Global_c_term_x_lagrangian.rows(); counter_sum++) {
        for (size_t counter_col = 0; counter_col < Global_c_term_x_lagrangian.cols(); counter_col++) {

            if (counter_col == counter_sum)
                std::cout << "In (" << counter_sum << " , " << counter_col << " ), c^0 = "
                          << Global_c_term_x_lagrangian.coeff(counter_sum, counter_col) << " and c1 = "
                          << Global_c_term_y_lagrangian.coeff(counter_sum, counter_col) << std::endl;
            else
                std::cout << "In (" << counter_sum << " , " << counter_col << " ), c^0_ij + c^0_ji = "
                          << Global_c_term_x_lagrangian.coeff(counter_sum, counter_col) +
                             Global_c_term_x_lagrangian.coeff(counter_col, counter_sum) << " and c^1_ij + c^1_ji = "
                          << Global_c_term_y_lagrangian.coeff(counter_sum, counter_col) +
                             Global_c_term_y_lagrangian.coeff(counter_col, counter_sum) << std::endl;
        }
    }


// VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

    Matrix<T, Dynamic, 1> flux0_prova = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1_prova = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux0_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> vel2_loc0 = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> sol_vel_gl0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> vel2_loc1 = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> sol_vel_gl1 = Matrix<T, Dynamic, 1>::Zero(dim);


    Matrix <T, Dynamic, Dynamic> sol_vel_gl_cellwise = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof, msh.cells.size());
    Matrix <T, Dynamic, Dynamic> one_loc = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof, local_ndof);

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);
    ColPivHouseholderQR <Matrix<T, Dynamic, Dynamic>> cod_bis(local_vandermonde);


    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u0_cellwise(i, i_fl) * phi(pts[i], msh, cl);
            flux1_loc(i) = u1_cellwise(i, i_fl) * phi(pts[i], msh, cl);
//std::cout<<"pts[i] = "<<pts[i] << " HHO_u0 = "<<u0_cellwise(i,i_fl)<<std::endl;
            flux0_prova_loc(i) = u0_cellwise(i, i_fl) * (phi(pts[i], msh, cl) + 0.5);
            flux1_prova_loc(i) = u1_cellwise(i, i_fl) * (phi(pts[i], msh, cl) + 0.5);
            vel2_loc0(i) = u0_cellwise(i, i_fl);
            vel2_loc1(i) = u1_cellwise(i, i_fl);
            one_loc(i, i) = 1.0;
            if (i_prova == 0) {
//std::cout<<"phi(" << pts[i] <<", msh , cl ) = "<<phi(pts[i] , msh , cl )<<std::endl;
                vecprovabis4(i, offset(msh, cl)) = (phi(pts[i], msh, cl));
            } else
                vecprovabis5(i, offset(msh, cl)) = (phi(pts[i], msh, cl));
        }

        Matrix<T, Dynamic, 1> sol0_bis = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1_bis = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0 = cod_bis.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod_bis.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol_vel0 = cod_bis.solve(vel2_loc0);
        Matrix<T, Dynamic, 1> sol_vel1 = cod_bis.solve(vel2_loc1);
        Matrix <T, Dynamic, Dynamic> check_inversion = cod_bis.solve(one_loc);

//T relative_error01 = (local_vandermonde*sol_vel- vel2_loc).norm() / vel2_loc.norm();
//std::cout << "The relative error0 of VELOCITY is: " << relative_error01 << std::endl;


//std::cout<<"Cell = "<<offset(msh,cl)<<", check_inversion_Vandermonde = "<<'\n'<<check_inversion <<std::endl;
//std::cout<<"Cell = "<<offset(msh,cl)<<", vel2_loc = "<<'\n'<<vel2_loc <<std::endl;
//std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC = "<<'\n'<<sol_vel <<std::endl;
//std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC - u0 LOC = "<<'\n'<<sol_vel - u0_cellwise.col(i_fl)  <<std::endl;

        if (i_prova == 0) {
//std::cout<<"-------------------> sol0 - sol0_bis "<<'\n'<< sol0 - sol0_bis<<std::endl;
//std::cout<<"-------------------> sol1 - sol1_bis "<<'\n'<< sol1 - sol1_bis<<std::endl;
            vecprovabis2.col(offset(msh, cl)) = flux0_loc; // è quello +0.5
            vecprovabis3.col(offset(msh, cl)) = flux1_loc; // è quello +0.5

        }
        if (i_prova == 1) {
//std::cout<<"-------------------> sol0 - vecprovabis2 "<<'\n'<< flux0_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
//std::cout<<"-------------------> sol1 - vecprovabis3 "<<'\n'<< flux1_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;
            std::cout << "-------------------> FLUX THEORETICAL 0 LOC" << '\n'
                      << flux0_prova_loc - vecprovabis2.col(offset(msh, cl)) << std::endl;
            std::cout << "-------------------> FLUX THEORETICAL 1 LOC" << '\n'
                      << flux1_prova_loc - vecprovabis3.col(offset(msh, cl)) << std::endl;

//std::cout<<"-------------------> CHECK phi VAL LOC ----------"<<'\n'<< vecprovabis5.col(offset(msh,cl)) - vecprovabis4.col(offset(msh,cl))<<std::endl;
//std::cout<<"-------------------> CHECK phi VAL SOL +0.5 ----------"<<'\n'<<  vecprovabis4.col(offset(msh,cl))<<std::endl;
//std::cout<<"-------------------> CHECK phi VAL SOL OLD ----------"<<'\n'<<  vecprovabis5.col(offset(msh,cl))<<std::endl;


        }

        Matrix<T, Dynamic, 1> sol0_prova = cod.solve(flux0_prova_loc);
        Matrix<T, Dynamic, 1> sol1_prova = cod.solve(flux1_prova_loc);


        if (cod.info() != Success) {
            std::cout << "Not positive" << std::endl;
            assert(0);
        }
//T relative_error0 = (local_vandermonde*sol0_prova - flux0_prova_loc).norm() / flux0_prova_loc.norm();
//T relative_error1 = (local_vandermonde*sol1_prova - flux1_prova_loc).norm() / flux1_prova_loc.norm();
//T relative_error2 = (local_vandermonde*sol0 - flux0_loc).norm() / flux0_loc.norm();
//T relative_error3 = (local_vandermonde*sol1- flux1_loc).norm() / flux1_loc.norm();
//std::cout << "The relative error0 is: " << relative_error0 << std::endl;
//std::cout << "The relative error1 is: " << relative_error1<< std::endl;
//std::cout << "The relative error2 is: " << relative_error2 << std::endl;
//std::cout << "The relative error3 is: " << relative_error3<< std::endl;
        cell_basis_Bernstein<Mesh, T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();

        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);
            flux0_prova(asm_map) = sol0_prova(i);
            flux1_prova(asm_map) = sol1_prova(i);
            sol_vel_gl0(asm_map) = sol_vel0(i);
            sol_vel_gl1(asm_map) = sol_vel1(i);
            sol_vel_gl_cellwise(i, i_fl) = sol_vel0.dot(cb.eval_basis(pts[i]));
        }


        i_fl++;
    }


    auto check_div_u = 1.0 / 2.0 * global_cij_x * sol_vel_gl0 + global_cij_y * sol_vel_gl1;
    auto check_div_u_2 = 1.0 / 2.0 * Global_c_term_x_lagrangian * u0 + Global_c_term_y_lagrangian * u1;

    std::cout << "----------CHECK DIV Bernstein -> " << '\n' << check_div_u << std::endl;
    std::cout << "----------CHECK DIV Lagrangian -> " << '\n' << check_div_u_2 << std::endl;


    for (auto &cl: msh.cells) {
        size_t cell_offset = offset(msh, cl);
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++) {
            auto pt = pts[i];
            std::cout << "In pt = " << pt << " --> u0(pt) = " << u(pt, msh, cl).first << " and ERROR = "
                      << (u(pt, msh, cl).first - sol_vel_gl_cellwise(i, cell_offset)) << std::endl;
        }

    }

//std::cout<<"-------------------> sol_vel - u0 "<<'\n'<< sol_vel_gl - u0<<std::endl;


    tc_solver2.toc();
    std::cout << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << std::endl;


    timecounter tc_case00;
    tc_case00.tic();

    if (i_prova == 1) {
//std::cout<<"----->CHECK PROJECTION flux0 = "<<'\n'<<flux0 +0.5*u0 - vecprovabis0 <<std::endl;
//std::cout<<"----->CHECK PROJECTION flux1 = "<<'\n'<<flux1 +0.5*u1 - vecprovabis1 <<std::endl;

        std::cout << "----->CHECK PROJECTION flux0 TEORIC = " << '\n' << vecprovabis0 - flux0_prova << std::endl;

        std::cout << "----->CHECK PROJECTION flux1 TEORIC = " << '\n' << vecprovabis1 - flux1_prova << std::endl;


//std::cout<<"---> flux0 ERROR = "<<'\n'<<flux0 - vecprovabis0 <<std::endl;
//std::cout<<"---> flux1 ERROR = "<<'\n'<<flux1 - vecprovabis1 <<std::endl;
//std::cout<<"---> flux0  = "<<'\n'<<flux0  <<std::endl;
//std::cout<<"---> flux1  = "<<'\n'<<flux1  <<std::endl;
//std::cout<<"---> u0_cellwise = "<<'\n'<<u0_cellwise - vecprovabis2 <<std::endl;
//std::cout<<"---> u1_cellwise = "<<'\n'<<u1_cellwise - vecprovabis3 <<std::endl;
//std::cout<<"---> phi_FEM = "<<'\n'<<phi_FEM - vecprovabis4 <<std::endl;
//std::cout<<"---> global_cij_x = "<<'\n'<<global_cij_x - vecprovabis5 <<std::endl;
//std::cout<<"---> global_cij_y = "<<'\n'<<global_cij_y - vecprovabis6 <<std::endl;

    }
    if (i_prova == 0) {
        vecprovabis0 = flux0;
        vecprovabis1 = flux1;


    }

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//Matrix<T, Dynamic, 1> prova0_fl =  0.5*(global_cij_x * u0  + global_cij_y * u1) ;
    Matrix<T, Dynamic, 1> prova0_fl1 = global_cij_x * flux0_prova + global_cij_y * flux1_prova;

    if (i_prova == 0)
        vecprova2 = conv_global;

    if (i_prova == 1) {
//std::cout<<"---> prova0_fl = "<<'\n'<<prova0_fl - vecprovabis7 <<std::endl;
//std::cout<<"------> prova0_fl_somma phi_tilde convolution = "<<'\n'<<vecprova2 - conv_global - vecprovabis7  <<std::endl;
        std::cout << "------> CHECK CONVOLUTION +0.5 = " << '\n' << prova0_fl1 - vecprova2 << std::endl;
    }
//if(i_prova == 0)//{
//vecprovabis7 = prova0_fl ;
//}
//if(i_prova == 1)
//std::cout<<"--------->   conv_global = "<<'\n'<<conv_global - vecprova2 <<std::endl;


// TERM d_ij
    SparseMatrix <T> dij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        T sum_row = 0.0;
        for (auto &elem: row_i) {
            T value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            T value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            T value = std::max(value0, value1);

            T value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            T value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            T value_adj = std::max(value_adj0, value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row, elem);
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row, elem);

            T val_dij = std::max(lambda_max, lambda_max_adj);

            if (counter_row == elem)
                val_dij = 0.0;

            sum_row += val_dij;


            if (counter_row != elem) {
                triplets_dij.push_back(Triplet<T>(counter_row, elem, val_dij));
                term_dij_no_entropy(counter_row) += val_dij * (phi_FEM(elem) - phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back(Triplet<T>(counter_row, counter_row, -sum_row));
        counter_row++;

    }

    dij.setFromTriplets(triplets_dij.begin(), triplets_dij.end());
    triplets_dij.clear();


    tc_case00.toc();
    std::cout << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if (dt_old != dt) {
        dt = floorf(CFL_numb * 0.98 * 1000) / 1000;
        std::cout << yellow << bold << "ATTENTION CHANGIN dt!!! ----> " << reset << "dt is " << dt_old
                  << " and dt CFL is " << dt << " !" << std::endl;
//exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

    if (i_prova == 1)
//  std::cout<<"global_lumped_mass = "<<'\n'<<global_lumped_mass - vecprova0 <<std::endl;
        if (i_prova == 0)
            vecprova0 = global_lumped_mass;

    if (i_prova == 1)
//  std::cout<<"term_dij_no_entropy = "<<'\n'<<term_dij_no_entropy - vecprova1 <<std::endl;
        if (i_prova == 0)
            vecprova1 = term_dij_no_entropy;



// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


    if (i_prova == 1)
//   std::cout<<"phi_FEM = "<<'\n'<<phi_FEM - phi2 <<std::endl;

        if (i_prova == 0)
            phi2 = phi_FEM;


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L;
    phi.converting_into_HHO_formulation(phi_L);


    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
//postprocess_output<double> postoutput5;
//auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



/*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;



//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename FiniteSpace, typename T = typename Mesh::coordinate_type>
void
run_FEM_BERNSTEIN_CORRECT(const Mesh &msh, const FiniteSpace &fe_data, Fonction &phi, Vel_Field &u, T &dt) {
// Starting time for FE calculation
    std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM -----------" << reset << std::endl;
//std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE;
//size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof; // local degrees of freedom
    auto S_i = fe_data.S_i;

// TOLTO PER ORA IL MAPPING NON SERVE NEL CASO BASE

    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1


/// PLOT ---> PHI MAPPED INTO 0-1
    postprocess_output<double> postoutput4;
    auto test_phi_mapped = std::make_shared < gnuplot_output_object < double > > ("phi_mapped.dat");
    for (auto cl: msh.cells) {
        auto pts = points(msh, cl);
        for (auto pt: pts) {
            T value = phi(pt, msh, cl);
            test_phi_mapped->add_data(pt, value);
        }
    }
    postoutput4.add_object(test_phi_mapped);
    postoutput4.write();


// SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM;
    auto u0 = u.sol_FEM.first;
    auto u1 = u.sol_FEM.second;
//u.set_max_vel(); // UPLOADING MAX VELOCITY OF u -> Bernstein Basis

//std::cout<<"CONSTANT VELOCITY: u0 is "<<u0<<" and u1 is "<<u1<<std::endl;

// NON LINEAR ENTROPY INITIALISATION
    const T eps = 1e-14; //constant into entropy
    non_linear_entropy<T, Fonction, Mesh> E(eps, phi, msh);
//SONOQUA1
// PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection<T, Mesh, FiniteSpace>(fe_data, msh);

//L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );

/// ENTROPY PLOT
/*
    postprocess_output<double> postoutput6;
    auto cut_entropy = std::make_shared< gnuplot_output_object<double> >("entropy.dat");
    for (auto& cl:msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto& pt:pts)
        {
            T value = E(pt,cl);
            cut_entropy->add_data(pt,value);
        }
    }
    postoutput6.add_object(cut_entropy);
    postoutput6.write();
    */



// SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x;
    auto global_cij_y = phi.Global_c_term_y;
    auto local_vandermonde = phi.local_vandermonde;

// THE GLOBAL MATRIX c_ij varies each time: dependes on u -> c_ij = int(u*b_i*grad(b_j))
/*
    SparseMatrix<T>                 global_cij_x = SparseMatrix<T>( dim, dim );
    SparseMatrix<T>                 global_cij_y = SparseMatrix<T>( dim, dim );
    std::vector< Triplet<T> >       triplets_c_term_x;
    std::vector< Triplet<T> >       triplets_c_term_y;
    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;


        // Local c_ij = u(x)*b_i* grad(b_j)
        auto local_cij = make_bernstein_local_cij_matrix_with_velocity(msh, cl, degree, u );

        for (size_t i = 0; i < local_ndof; i++)
        {
            auto asm_map_i = phi.connectivity_matrix[cell_offset][i].first ;
            for (size_t j = 0; j < local_ndof; j++)
            {
                auto asm_map_j = phi.connectivity_matrix[cell_offset][j].first ;
                triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i,j) ) );
                triplets_c_term_y.push_back( Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i,j) ) );
           }

        }
    }
    // FINALISATION c_ij GLOBAL ASSEMBLING
    global_cij_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
    triplets_c_term_x.clear();
    global_cij_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
    triplets_c_term_y.clear();
    */



// INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
//ConjugateGradient<SparseMatrix<T> > solver_global_mass;

    timecounter tc1;
    tc1.tic();

    SimplicialLLT <SparseMatrix<T>> solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER 0->phi_tilde" << std::endl;
        exit(1);
    }

    tc1.toc();
    std::cout << bold << yellow << "Inversion of the mass matrix: " << tc1 << " seconds" << reset << std::endl;

/*
    SparseLU<SparseMatrix<T>, AMDOrdering<int> > solver2 ;
    solver2.compute(global_mass);
    if(solver2.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }
    */

/// CHECKING OF MASS MATRICES' PROPERTIES
/*
    std::cout<<"First checking: Lumped Mass"<<std::endl;
    for(size_t i = 0; i<global_lumped_mass.rows();i++)
        if(global_lumped_mass(i)<0)
            std::cout<<"PROBLEM into lumped mass"<<std::endl;

    Matrix<T, Dynamic, Dynamic> mass_check = - global_mass;
    for(size_t i = 0 ; i < mass_check.rows() ; i++){
        mass_check(i,i) += global_lumped_mass(i);
        std::cout<<(mass_check.row(i)).sum()<<std::endl;
    }

    /// CHECK OF THE SUM PROPERTY OF CIJ
     Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);
     Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i=0; i<global_cij_y.rows(); i++) {
         std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }



    for(size_t counter_sum = 0 ; counter_sum < global_cij_x.rows() ; counter_sum++ )
    {
        for(size_t counter_col = 0 ; counter_col < global_cij_x.cols() ; counter_col++)
        {

           if(counter_col==counter_sum)
               std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0 = "<<global_cij_x.coeff( counter_sum , counter_col )<<" and c1 = "<<global_cij_y.coeff( counter_sum , counter_col )<<std::endl;
           else
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0_ij + c^0_ji = "<<global_cij_x.coeff( counter_sum , counter_col ) + global_cij_x.coeff( counter_col , counter_sum )<<" and c^1_ij + c^1_ji = "<<global_cij_y.coeff( counter_sum , counter_col ) + global_cij_y.coeff( counter_col , counter_sum ) <<std::endl;
        }
    }

 */

// FLUX TERM
/*
    Matrix<T, Dynamic, 1>  RHS_flux0 =  Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1>  RHS_flux1 =  Matrix<T, Dynamic, 1>::Zero(dim) ;
    size_t counter_flux = 0 ;
    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto local_flux = make_bernstein_local_RHS_FLUX( msh , cl , degree , u , phi ) ;
        //std::cout<<"flux_loc0  "<<'\n'<<flux_loc.first<<std::endl;
        //std::cout<<"flux_loc1  "<<'\n'<<flux_loc.second<<std::endl;
        for (size_t i = 0; i < local_ndof ; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[counter_flux][i].first ;
            RHS_flux0(asm_map) += local_flux.first(i) ;
            RHS_flux1(asm_map) += local_flux.second(i) ;
        }
        counter_flux++;
    }
    Matrix<T, Dynamic, 1> flux0 = solver_global_mass.solve(RHS_flux0);
    Matrix<T, Dynamic, 1> flux1 = solver_global_mass.solve(RHS_flux1);
     */


// ALTERNATIVE VANDERMONDE MATRIX

//Matrix<T, Dynamic, 1> flux0 = u0.cwiseProduct( phi_FEM ) ;
//Matrix<T, Dynamic, 1> flux1 = u1.cwiseProduct( phi_FEM );

    size_t i_fl = 0;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof);

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim);
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim);

//Matrix<T, Dynamic, Dynamic> local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_ndof , local_ndof) ;


//T error0_L2 = 0.0 , error1_L2 = 0.0 ;

    CompleteOrthogonalDecomposition <Matrix<T, Dynamic, Dynamic>> cod(local_vandermonde);


    for (auto &cl: msh.cells) {
// FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
//cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);
        for (size_t i = 0; i < local_ndof; i++) {
            flux0_loc(i) = u(pts[i], msh, cl).first * phi(pts[i], msh, cl);
            flux1_loc(i) = u(pts[i], msh, cl).second * phi(pts[i], msh, cl);
// LOCAL VANDERMONDE MATRIX -> è uguale penso basti farla tra [0,1] e riportarla qua
//local_vandermonde.block(i,0,1,local_ndof) = (cb.eval_basis(pts[i])).transpose() ;

//size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;

        }

//std::cout<<'\n'<<'\n'<<"local_vandermonde "<<local_vandermonde<<'\n'<<std::endl;
//CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod( local_vandermonde );
        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
//std::cout<<"flux0_loc -sol0"<<'\n'<<flux0_loc-sol0<<'\n'<<std::endl;
//if (cod.info() != Success)
//{
//    std::cout<<"Not positive"<<std::endl;
//    assert(0);
//}



        for (size_t i = 0; i < local_ndof; i++) {

            size_t asm_map = phi.connectivity_matrix[i_fl][i].first;
            flux0(asm_map) = sol0(i);
            flux1(asm_map) = sol1(i);

        }


        i_fl++;
    }




//std::cout<<"flux0_bis:"<<'\n'<<flux0_bis <<'\n' <<std::endl;
//std::cout<<"flux0:"<<'\n'<< flux0<<'\n' <<std::endl;
/*
    T sum0 = 0.0 , sum1 = 0.0 ;
    for (int ii = 0 ; ii < dim ; ii++ )
    {
        sum0 += pow( (flux0_bis(ii) - flux0(ii)) , 2 );
        sum1 += pow( (flux1_bis(ii) - flux1(ii)) , 2 );
    }

    error0_L2 = sqrt( 1.0/dim * sum0 );
    error1_L2 = sqrt( 1.0/dim * sum1 );
    std::cout<<"ERRORE L2 (flux0_bis - flux0):"<<'\n'<<error0_L2<<'\n' <<std::endl;
    std::cout<<"ERRORE L2 (flux1_bis - flux1):"<<'\n'<<error1_L2<<'\n' <<std::endl;
*/


// RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM; // USEFUL ALSO FOR HO PHI_H
//std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

// CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0 + global_cij_y * flux1;
//Matrix<T, Dynamic, 1> conv_global = global_cij_x * phi_FEM  + global_cij_y * phi_FEM ;
/*
    Matrix<T, Dynamic, 1> flux0 = 10 * phi_FEM ;
    Matrix<T, Dynamic, 1> flux1 = 0 * phi_FEM ;
    Matrix<T, Dynamic, 1> conv_global2 = phi.Global_c_term_x * flux0  + phi.Global_c_term_y * flux1 ;
    std::cout<<"CHECK cij conv_global  "<<'\n'<<conv_global-conv_global2<<std::endl;
    */






// NORM of c_ij
    SparseMatrix <T> cij_norm = (global_cij_x.cwiseProduct(global_cij_x) +
                                 global_cij_y.cwiseProduct(global_cij_y)).cwiseSqrt();
//std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

// MATRIX n_ij
    SparseMatrix <T> nij0 = global_cij_x.cwiseQuotient(cij_norm);
    SparseMatrix <T> nij1 = global_cij_y.cwiseQuotient(cij_norm);

//std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


// MATRIX c_ji
    SparseMatrix <T> cji_x = global_cij_x.adjoint();
    SparseMatrix <T> cji_y = global_cij_y.adjoint();

// NORM of c_ji -> i.e. c_ij transposed
    SparseMatrix <T> cji_norm = (cji_x.cwiseProduct(cji_x) + cji_y.cwiseProduct(cji_y)).cwiseSqrt();

// MATRIX n_ij (TRANSPOSED)
    SparseMatrix <T> nji0 = cji_x.cwiseQuotient(cji_norm);
    SparseMatrix <T> nji1 = cji_y.cwiseQuotient(cji_norm);


// NORMAL VELOCITY
    SparseMatrix <T> normal_vel = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets;

// NORMAL VELOCITY TRANSPOSED
    SparseMatrix <T> normal_vel_adj = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_adj;
/*
    // NORMAL VELOCITY
    SparseMatrix<T> normal_vel_bis = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets0_bis;

    // NORMAL VELOCITY TRANSPOSED
    SparseMatrix<T> normal_vel_bis_adj = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets1_bis ;
    */
    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            auto value0 = std::abs(
                    u0(counter_row) * nij0.coeff(counter_row, elem) + u1(counter_row) * nij1.coeff(counter_row, elem));
            auto value1 = std::abs(u0(elem) * nij0.coeff(counter_row, elem) + u1(elem) * nij1.coeff(counter_row, elem));
            auto value = std::max(value0, value1);

            auto value_adj0 = std::abs(
                    u0(counter_row) * nji0.coeff(counter_row, elem) + u1(counter_row) * nji1.coeff(counter_row, elem));
            auto value_adj1 = std::abs(
                    u0(elem) * nji0.coeff(counter_row, elem) + u1(elem) * nji1.coeff(counter_row, elem));
            auto value_adj = std::max(value_adj0, value_adj1);

            triplets.push_back(Triplet<T>(counter_row, elem, value));
            triplets_adj.push_back(Triplet<T>(counter_row, elem, value_adj));


// CHECK IT
/*
            auto value0_bis = std::max( u0(counter_row) , u0(elem) );
            auto value1_bis = std::max( u1(counter_row) , u1(elem) );
            auto val = value0_bis * nij0.coeff(counter_row,elem) + value1_bis * nij1.coeff(counter_row,elem) ;
            auto val_adj = value0_bis * nji0.coeff(counter_row,elem) + value1_bis * nji1.coeff(counter_row,elem) ;

            triplets0_bis.push_back( Triplet<T>(counter_row, elem, val ) );
            triplets1_bis.push_back( Triplet<T>(counter_row, elem, val_adj ) );
            */


        }
        counter_row++;
    }

    normal_vel.setFromTriplets(triplets.begin(), triplets.end());
    triplets.clear();
    normal_vel_adj.setFromTriplets(triplets_adj.begin(), triplets_adj.end());
    triplets_adj.clear();

/*
    normal_vel_bis.setFromTriplets( triplets0_bis.begin(), triplets0_bis.end() );
    triplets0_bis.clear();
    normal_vel_bis_adj.setFromTriplets( triplets1_bis.begin(), triplets1_bis.end() );
    triplets1_bis.clear();
    SparseMatrix<T> normal_vel_abs_bis = normal_vel_bis.cwiseAbs() ;  // o lambda_max=normal_vel ?
    SparseMatrix<T> normal_vel_abs_adj_bis = normal_vel_bis_adj.cwiseAbs();
    */
// CHECKING NEW METHOD NORMAL VEL
/*
    for(size_t i = 0 ; i < normal_vel_abs_bis.rows() ; i++)
    {
        for(size_t j = 0 ; j < normal_vel_abs_bis.cols() ; j++){
            if(std::abs(normal_vel.coeff(i,j)-normal_vel_abs_bis.coeff(i,j))>1e-5)
                std::cout<<"In ("<<i<<" , "<<j<<" ), normal vel OLD is "<<normal_vel_abs_bis.coeff(i,j)<<" , normal vel NEW is "<<normal_vel.coeff(i,j)<<std::endl;

            if(std::abs(normal_vel_adj.coeff(i,j)-normal_vel_abs_adj_bis.coeff(i,j))>1e-5)
                std::cout<<"In ("<<i<<" , "<<j<<" ), normal vel ADJ OLD is "<<normal_vel_abs_adj_bis.coeff(i,j)<<" , normal vel  ADJ NEW is "<<normal_vel_adj.coeff(i,j)<<std::endl;

        }
    }
    */
//SparseMatrix<T> normal_vel2 = u0 * nij0 + u1 * nij1 ;
//SparseMatrix<T> normal_vel_adj2 = u0 * nji0 + u1 * nji1 ;

//std::cout<<"normal_vel - nij0"<<'\n'<<normal_vel - nij0<<std::endl;
//std::cout<<"normal_vel_adj - nij0"<<'\n'<<normal_vel_adj - nji0<<std::endl;
//std::cout<<"CHECK normal_vel2  : "<<'\n'<<normal_vel-normal_vel2<<'\n'<<std::endl;
//std::cout<<"CHECK normal_vel_adj2 : "<<'\n'<<normal_vel_adj-normal_vel_adj2<<'\n'<<std::endl;

// MATRIX Dij CALCULATION:
// normval_vel and the adjoint one are already absolute value

//SparseMatrix<T> normal_vel_abs = normal_vel.cwiseAbs() ;  // o lambda_max=normal_vel ?
//SparseMatrix<T> normal_vel_abs_adj = normal_vel_adj.cwiseAbs();// o lambda_max=normal_vel?


/// POSSO SCEGLIERE SE METTERE normal_vel_abs_bis O normal_vel !!!!!!!!!!!!!!!!
//std::cout<<bold<<yellow<<"--->  sto usando normal_vel_abs_bis, i.e. con max su u(pt)!!"<<reset<<std::endl;
    std::cout << bold << yellow << "--->  sto usando normal_vel, i.e. con max su u*n !!" << reset << std::endl;


//SparseMatrix<T> lambda_max = normal_vel_abs_bis.cwiseProduct( cij_norm );
//SparseMatrix<T> lambda_max_adj = normal_vel_abs_adj_bis.cwiseProduct( cji_norm );
    SparseMatrix <T> lambda_max = normal_vel.cwiseProduct(cij_norm);
    SparseMatrix <T> lambda_max_adj = normal_vel_adj.cwiseProduct(cji_norm);


    SparseMatrix <T> dij = lambda_max.cwiseMax(lambda_max_adj);
//SparseMatrix<T> dij2 = lambda_max.cwiseMax(lambda_max_adj);

    for (size_t i = 0; i < dij.rows(); i++) {
        dij.coeffRef(i, i) = 0;
        dij.coeffRef(i, i) = -dij.row(i).sum();
    }
//std::cout<<"dij-dij2"<<'\n'<<dij-dij2<<std::endl;

// CHECK TIME STEP dt
    T dt_old = dt;
    std::cout << bold << yellow << "---> COND IN TEMPO CFL, ALEXANDRE BOOK" << reset << std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW(dij.diagonal(), global_lumped_mass, fe_data.Dirichlet_boundary, dt);

//T nu_max0 = CFL_numb/fe_data.hx;
//T nu0 = dt_old/fe_data.hx;
//T nu1 = dt/fe_data.hx;

//std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;
//T nu_max = dt/fe_data.hx;
//std::cout<<"VALID FOR u = (1,0). nu_max = "<<nu_max<<std::endl;
    if (dt_old != dt) {
        std::cout << "dt is " << dt_old << " and dt CFL is " << dt << " . STOP!" << std::endl;
        exit(10);
    }




// CONSTANT TERM (PHI TILDE PROBLEM)
//Matrix<T,Dynamic,1> vec2 = Matrix<T, Dynamic, 1>::Zero(dim) ;
//averaged_sum_Si_SPARSE(S_i , global_cij_x , flux0 , vec2);
//averaged_sum_Si_SPARSE(S_i , global_cij_y , flux1 , vec2);

//std::cout<<"CHECK phi TILDE "<<'\n'<<conv_global-vec2<<'\n'<<"FINE PHI TILDE CHECKING"<<std::endl;
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt * conv_global.cwiseQuotient(global_lumped_mass);
//std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

// RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection

//auto prova_phi_tilde = solver2.solve(b);
//std::cout<<"phi_tilde.sol_FEM  "<<'\n'<<phi_tilde.sol_FEM <<std::endl;

//std::cout<<"phi_tilde.sol_FEM - prova_phi_tilde "<<'\n'<<phi_tilde.sol_FEM - prova_phi_tilde <<std::endl;


    if (solver_global_mass.info() != Success) {
        std::cout << "FAILED SOLVER 1->phi_tilde" << std::endl;
        exit(1);
    }

// SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout << "CONVERTING phi_tilde" << std::endl;
    phi_tilde.converting_into_HHO_formulation(phi_tilde.sol_FEM);



// TERM R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for (auto &cl: msh.cells)
        r_i_calculator_Bernstein(msh, cl, E, phi_tilde, phi, dt, u, Emax_global, Emin_global, R_i);

// R_i FINALISATION:
//std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
//std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i = R_i.cwiseQuotient(Emax_global - Emin_global);
//std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
//std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;



// ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    SparseMatrix <T> dE_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_dE_ij;
    SparseMatrix <T> phi_ij = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_phi_ij;


    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {

            if (elem != counter) {
                auto R_i_j = c_e * std::max(std::abs(R_i(counter)), std::abs(R_i(elem)));
                auto value = std::min(dij.coeff(counter, elem), R_i_j);
                triplets_dE_ij.push_back(Triplet<T>(counter, elem, value));
//dE_ij( counter_row , elem ) = std::min( dij( counter_row , elem ), R_i_j );
//std::cout<<"R_i_j "<<R_i_j<<" and dij"<<dij( counter_row , elem )<<std::endl;
            }
            auto value_bis = 0.5 * (phi_FEM(counter) + phi_FEM(elem));
            triplets_phi_ij.push_back(Triplet<T>(counter, elem, value_bis));


        }
        counter++;
    }

//std::cout<<"term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy<<std::endl;

    dE_ij.setFromTriplets(triplets_dE_ij.begin(), triplets_dE_ij.end());
    triplets_dE_ij.clear();
    phi_ij.setFromTriplets(triplets_phi_ij.begin(), triplets_phi_ij.end());
    triplets_phi_ij.clear();

//std::cout<<"dE_ij: "<<'\n'<<dE_ij<<std::endl;

// MATRIX d^C_ij

    T c_comp = 1.0;
    SparseMatrix <T> tmp0 = phi_ij - phi_ij.cwiseProduct(phi_ij);
//std::cout<<"tmp0 "<<'\n'<<tmp0<<std::endl;
    positive_part_SPARSE(tmp0);
//std::cout<<"tmp0 POSITIVE "<<'\n'<<tmp0<<std::endl;

    SparseMatrix <T> tmp_dC1 = SparseMatrix<T>(dim, dim);
    std::vector <Triplet<T>> triplets_tmp_dC1;
    SparseMatrix <T> Mat_One = SparseMatrix<T>(dim, dim);
//Matrix<T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones( dim, dim );
    std::vector <Triplet<T>> triplets_1;

    size_t counter_tmp = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
// std::cout<<"In ("<<counter<<" , "<<elem<<") tmp_dC0 = "<<tmp_dC0(counter,elem)<<" and phi.ver diff "<<std::abs(phi.vertices(counter) - phi.vertices(elem))<<std::endl;
            if (std::abs(phi_FEM(counter_tmp) - phi_FEM(elem)) > 1e-15) {
                auto value = tmp0.coeff(counter_tmp, elem) / (std::abs(phi_FEM(counter_tmp) - phi_FEM(elem)));
                triplets_tmp_dC1.push_back(Triplet<T>(counter_tmp, elem, value));
                triplets_1.push_back(Triplet<T>(counter_tmp, elem, 1.0));
            }
//tmp_dC1(counter_tmp,elem) = tmp0(counter_tmp,elem)/( std::abs(sol_FEM(counter_tmp) - sol_FEM(elem)) );
        }
        counter_tmp++;
    }
    tmp_dC1.setFromTriplets(triplets_tmp_dC1.begin(), triplets_tmp_dC1.end());
    triplets_tmp_dC1.clear();


    Mat_One.setFromTriplets(triplets_1.begin(), triplets_1.end());


    Matrix <T, Dynamic, Dynamic> Mat1 = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(dim, dim);
    Matrix <T, Dynamic, Dynamic> tmp1_bis = Mat1 - c_comp * tmp_dC1;
    positive_part(tmp1_bis);
    Matrix <T, Dynamic, Dynamic> dC_ij_bis = dE_ij.cwiseProduct(tmp1_bis);



//std::cout<<'\n'<<"tmp_dC1: "<<'\n'<<tmp_dC1<<std::endl;
    SparseMatrix <T> tmp1 = Mat_One - c_comp * tmp_dC1;

//Matrix<T, Dynamic, Dynamic> tmp1 = Mat_One - c_comp*tmp_dC1;
//positive_part( tmp1  );
//SparseMatrix<T> dC_ij = SparseMatrix<T>( dim , dim );
//size_t counter_prova = 0;
//for(auto& row_i:S_i)
//{
//   for(auto& elem:row_i)
//   {
//       dC_ij.coeffRef(counter_prova,elem) += ( dE_ij.coeff(counter_prova,elem)*tmp1(counter_prova,elem) );
//   }
//  counter_prova++;
//}



//std::cout<<'\n'<<"tmp1: "<<'\n'<<tmp1<<std::endl;
    positive_part_SPARSE(tmp1);

    SparseMatrix <T> dC_ij = dE_ij.cwiseProduct(tmp1);

/*
    SparseMatrix<T> dC_ij_prova = dC_ij ;
    // NON SONO SICURO SERVA STA COSA
    std::cout<<"CHECK IF SERVE L'IMPOSIZIONE PER L'ELEMENTO DIAGONALE = SOMMA RIGA PER VARI d^I_ij!!!!"<<std::endl;
    for(size_t i = 0 ; i < dC_ij.rows() ; i++)
    {
        dC_ij.coeffRef(i,i) = 0.;
        dij.coeffRef(i,i) = 0.;
        dC_ij.coeffRef(i,i) = -dC_ij.row(i).sum();
        dij.coeffRef(i,i) = -dij.row(i).sum();
    }

    std::cout<<'\n'<<"dC_ij_prova - dC_ij: "<<'\n'<<dC_ij_prova - dC_ij<<std::endl;
    */

// ARTIFICIAL VISCOSITY TERM d_ij * (phi_j-phi_i)

    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij_E = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

//Matrix<T, Dynamic, 1> term_dij_bis =  Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_dij = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
// TERM d_ij * (phi_j-phi_i)
            term_dij_no_entropy(counter_dij) += dij.coeff(counter_dij, elem) * (phi_FEM(elem) - phi_FEM(counter_dij));
// TERM dC_ij * (phi_j-phi_i)
            term_dij(counter_dij) += dC_ij.coeff(counter_dij, elem) * (phi_FEM(elem) - phi_FEM(counter_dij));
            term_dij_E(counter_dij) += dE_ij.coeff(counter_dij, elem) * (phi_FEM(elem) - phi_FEM(counter_dij));

//term_dij_bis(counter_dij) += dC_ij_bis.coeff(counter_dij,elem)*(phi_FEM(elem)-phi_FEM(counter_dij));
        }
        counter_dij++;
    }

//std::cout<<"term_dij_bis - term_dij"<<'\n'<<term_dij_bis - term_dij<<std::endl;

// FOR CHECKING
//std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij<<std::endl;

//std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij_no_entropy2<<std::endl;

//Matrix<T, Dynamic, 1> term_dij_no_entropy2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1 );
//term_dij_no_entropy2 = dij * phi_FEM ;

//Matrix<T, Dynamic, 1> term_dij2 = dC_ij * phi_FEM ;
//std::cout<<"CHECK term_dij2 : "<<'\n'<<term_dij2 - term_dij<<std::endl;

//std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij_no_entropy2<<std::endl;



/// MATRIX D_IJ CHECKING
/*
     //The  error is < 1e-15, at max
    std::cout<<"D_ij check: "<<std::endl;
    for(size_t i = 0; i<lambda_max.rows();i++){
        for(size_t j = i+1; j<lambda_max.rows();j++){
            if(std::abs(dij.coeff(i,j)-dij.coeff(j,i))>1e-15)
            std::cout<<dij.coeff(i,j)-dij.coeff(j,i);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;


     std::cout<<'\n'<<"dij: "<<'\n'<<dij<<std::endl;

    std::cout<<"D_ij check symmetry "<<std::endl;
    for(size_t counter_row = 0 ; counter_row < global_cij_x.rows() ; counter_row++ )
    {

        for(size_t elem = 0 ; elem < global_cij_x.cols() ; elem++)
        {
            std::cout<<dij.coeff(counter_row,elem) - dij.coeff(elem,counter_row)<<std::endl;
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */

/// TERM D_IJ*(PHI_J-PHI_I)  CHECKING
/*
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    for(size_t i = 0 ; i < dij.rows() ; i++)
    {
        for(size_t j = 0 ; j < dij.cols() ; j++)
        {
            term_dij_no_entropy.coeffRef(i) += dij.coeff(i,j) * ( phi_FEM(j)-phi_FEM(i) ) ;
        }
    }
    */

///********* RESOLUTION OF THE SYSTEM: **********//


// RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass) +
                                  dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

//std::cout<<'\n'<<"phi_L : "<<'\n'<<phi_L<<std::endl;


// RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    Matrix<T, Dynamic, 1> b_phiE = mass_phi_old - dt * conv_global + dt * term_dij_E;
    Matrix<T, Dynamic, 1> phi_E = solver_global_mass.solve(b_phiE);


// CHECKING OF phi_h AND phi_l
//Matrix<T, Dynamic, 1> check0 = global_lumped_mass.cwiseProduct( (phi_L - phi_FEM)/dt ) + conv_global - term_dij_no_entropy;
//std::cout<<'\n'<<"CHECK phi_L is "<<'\n'<<check0<<std::endl;

//Matrix<T, Dynamic, 1> check1 = global_mass*( (phi_H - phi_FEM)/dt ) + conv_global - term_dij;
//std::cout<<'\n'<<"CHECK phi_H is "<<'\n'<<check1<<std::endl;


// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;
//std::cout<<'\n'<<"delta_phi "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi_FEM,
                                                    S_i);

// CHECKING PHI
/*
    auto check_phi = phi_H - phi_L - f_i.cwiseQuotient(global_lumped_mass) ;//+dt*Vec_One ;

    Matrix<T, Dynamic, 1>  phi_H2 = phi_L + f_i.cwiseQuotient(global_lumped_mass);

    std::cout<<'\n'<<"check phi "<<'\n'<<check_phi<<std::endl;
    std::cout<<'\n'<<"check phi_h: "<<'\n'<<phi_H - phi_H2<<std::endl;
    */


// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE(global_lumped_mass, global_mass, delta_phi, phi_L, dt,
                                                                  dij, dC_ij, phi_FEM, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




// IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0;
    for (const auto &dir_elem: fe_data.Dirichlet_boundary) {
        if (dir_elem) {
            phi_L(counter_dir) = phi_FEM(counter_dir);
            phi_H(counter_dir) = phi_FEM(counter_dir);
            phi_new(counter_dir) = phi_FEM(counter_dir);
            phi_E(counter_dir) = phi_FEM(counter_dir);
        }
        counter_dir++;
    }


//std::cout<<"phi_L - phi_H"<<'\n'<<phi_L - phi_H<<'\n'<<'\n'<<'\n'<<std::endl;
//std::cout<<"phi_L - phi_new"<<'\n'<<phi_L - phi_new<<'\n'<<'\n'<<'\n'<<std::endl;
//std::cout<<"phi_H - phi_new"<<'\n'<<phi_H - phi_new<<'\n'<<'\n'<<'\n'<<std::endl;



    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;





/// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    postprocess_output<double> postoutput5;
    auto test_phi_h = std::make_shared < gnuplot_output_object < double > > ("phi_h.dat");
    auto test_phi_l = std::make_shared < gnuplot_output_object < double > > ("phi_l.dat");
    auto test_phi_new = std::make_shared < gnuplot_output_object < double > > ("phi_new.dat");

// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set

/*


    phi.sol_FEM = phi_L ;

    std::cout<<"USING LOW ORDER SOLUTION PHI_L. Also vertices uploading."<<std::endl;
    //phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_L);
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    phi.coefficients_inverse_mapping();
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_l->add_data( pt ,phi(pt, msh , cl ) );
        }
    }

     */

/*



    phi.sol_FEM = phi_E ;

    std::cout<<"CONVERTING phi_E in HHO formulation. Also vertices uploading."<<std::endl;
    phi.converting_into_HHO_formulation(phi_E);


    phi.coefficients_inverse_mapping();
    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM





    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_H ;


    std::cout<<"CONVERTING phi_L in HHO formulation. Also vertices uploading."<<std::endl;
    //phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_H);


    phi.coefficients_inverse_mapping();
    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM

    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_h->add_data( pt ,phi(pt, msh , cl ) );
        }
    }


     */


// SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new;

    std::cout << "USING HIGH ORDER SOLUTION PHI_HP. Also vertices uploading." << std::endl;
//phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_new);


    phi.coefficients_inverse_mapping();
//phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM




    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (auto pt: pts) {
//std::cout<<pt<<std::endl;
//test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data(pt, phi(pt, msh, cl));
        }
    }



/// PLOTTING SOLUTION (GNUPLOT)
/*
    postprocess_output<double> postoutput5;
    auto test_phi_h = std::make_shared< gnuplot_output_object<double> >("phi_h.dat");
    auto test_phi_l = std::make_shared< gnuplot_output_object<double> >("phi_l.dat");
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");

    size_t counter_cl = 0;
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        size_t iii = 0;
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_l->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            iii++;
        }
        counter_cl++;
    }
     */
    postoutput5.add_object(test_phi_h);
    postoutput5.add_object(test_phi_l);
    postoutput5.add_object(test_phi_new);
    postoutput5.write();

    std::cout << yellow << bold << "----------- FINE TRANSPORT PROBLEM -----------" << reset << std::endl;

//return phi_tilde;

}


template<typename Fonction, typename Mesh, typename Vel_Field, typename T = typename Mesh::coordinate_type>
void run_FEM_levelset(const Mesh &msh, size_t degree, Fonction &phi, const Vel_Field &u, const T &dt,
                      const mesh_init_params <T> &params) {
    timecounter tc;
    tc.tic();
//size_t ndof = ( degree+1 ) * ( degree+1 ) ; // degrees of freedom
    const T eps = 1e-14; //constant into entropy

// LOCAL MASS MATRIX ==> CHECK DEGREE == 1!!!
    assert(degree == 1);


    mapping_phi(phi, phi.phi_max, phi.phi_min); // mapping of phi to  have a phi between 0 and 1
/// PHI MAPPED INTO 0-1 PLOT
/*
    postprocess_output<double> postoutput4;
    auto test_phi_mapped = std::make_shared< gnuplot_output_object<double> >("phi_mapped.dat");
    for (auto cl:msh.cells) {
        auto pts = points(msh,cl) ;
        for (auto pt:pts) {
            T value = phi(pt,msh,cl);
            test_phi_mapped->add_data(pt,value);
        }
    }
    postoutput4.add_object(test_phi_mapped);
    postoutput4.write();
    */

// ENTROPY -> for phi with codomain in (0,1)
    non_linear_entropy<T, Fonction, Mesh> E(eps, phi, msh);
    auto phi_tilde = projection<T, Mesh>(msh, degree, params);

/// ENTROPY PLOT
/*
    postprocess_output<double> postoutput6;
    auto cut_entropy = std::make_shared< gnuplot_output_object<double> >("entropy.dat");
    for (auto cl:msh.cells) {
        auto pts = points(msh,cl) ;
        for (auto pt:pts) {
            T value = E(pt,cl);
            cut_entropy->add_data(pt,value);
        }
    }
    postoutput6.add_object(cut_entropy);
    postoutput6.write();
    */

// Global Matrix and Global Vector Definitions:
    size_t dim = msh.nodes.size();
// Lumped mass vector
    Matrix<T, Dynamic, 1> global_lumped_mass = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
// Mass matrix
    Matrix <T, Dynamic, Dynamic> global_mass = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
// C_ij,1 matrix
    Matrix <T, Dynamic, Dynamic> global_cij_x = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
// C_ij,2 matrix
    Matrix <T, Dynamic, Dynamic> global_cij_y = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
// Convection term (vector)
    Matrix<T, Dynamic, 1> conv_global = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
// D_ij term (vector)
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
// N_ij matrix
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>> nij = std::make_pair(
            Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim), Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim));
// N_ji matrix
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>> nij_transpose = std::make_pair(
            Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim), Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim));
// ||c_ij||^2
    Matrix <T, Dynamic, Dynamic> cij_square = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
// ||c_ji||^2
    Matrix <T, Dynamic, Dynamic> cji_square = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);

// One vector
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
// One matrix
    Matrix <T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(dim, dim);


// Boundary Nodes = Vertices (in Q1)
    auto bdry_nodes = boundary_nodes_function(phi.Nx, phi.Ny);


// The Support of Global Shape Function: list of neighborood nodes for each node i
    std::vector <std::set<size_t>> S_i(dim);
    timecounter tc1;
    tc1.tic();
    for (auto cl: msh.cells) {


        auto nodes_position = nodes(msh, cl); // node_pos.ptid to have just the number

// In basis (mesh creation) the order is
/// 2 - - 3
/// |       |
/// 0 - - 1

// In nodes position instead the order is
/// 3 - - 2
/// |       |
/// 0 - - 1
// I swap last two elements to have the first ordering
        iter_swap(nodes_position.end() - 1, nodes_position.end() - 2);

// Support of global shape function: list of close nodes for each node i
        supporting_nodes(S_i, nodes_position);

/*
        // CALCULATION OF THE SIZE + PLOTTING
        size_t size_supp_nodes = 0;
        std::cout<<"Supporting nodes:"<<std::endl;
        size_t jjjj = 0;
        for (auto& i:S_i) {
            size_supp_nodes+=i.size();
            std::cout <<"Node "<<jjjj<<":";
            for (auto it=i.begin(); it != i.end(); ++it)
                std::cout << ' ' << *it;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
        std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
        */


// Local mass matrix
        Matrix <T, Dynamic, Dynamic> mass = make_lagrange_local_mass_matrix(msh, cl, degree);

// Assembling into global matrix
//global_update2( mass , global_mass , nodes_position2 );
        global_update(mass, global_mass, nodes_position);

// Local c_ij = b_i nabla(b_j)
        auto cij = make_local_cij_matrix(msh, cl, degree);

// Assembling into global matrix
        global_update(cij.first, global_cij_x, nodes_position);
        global_update(cij.second, global_cij_y, nodes_position);

// USEFUL COMMAND FOR NORMS of a Eigen::matrix A:
// A.template lpNorm<2>()
// A.norm()

    }

// LUMPED MASS VECTOR (i.e. vector = diagonal of a matrix)
    sum_Si(S_i, global_mass, Vec_One, global_lumped_mass);



// CHECKING OF MASS MATRICES' PROPERTIES-> OK, perfect precision 1e-19
/*
    std::cout<<"First checking: Lumped Mass"<<std::endl;
    for(size_t i = 0; i<global_lumped_mass.rows();i++)
        if(global_lumped_mass(i)<0)
            std::cout<<"PROBLEM into lumped mass"<<std::endl;

    Matrix<T, Dynamic, Dynamic> mass_check = - global_mass;
    for(size_t i = 0 ; i < mass_check.rows() ; i++){
        mass_check(i,i) += global_lumped_mass(i);
        std::cout<<(mass_check.row(i)).sum()<<std::endl;
    }
    */



/// CHECK OF THE SUM PROPERTY OF CIJ
/*
     Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);
     Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i=0; i<global_cij_y.rows(); i++) {
         std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }

    size_t counter_sum = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
           sum0( counter_sum ) += global_cij_x( counter_sum , elem );
           sum1( counter_sum ) += global_cij_y( counter_sum , elem );
           if(elem==counter_sum)
               std::cout<<"In ("<<counter_sum<<" , "<<elem<<" ), c^0 = "<<global_cij_x( counter_sum , elem )<<" and c1 = "<<global_cij_y( counter_sum , elem )<<std::endl;
           else
                std::cout<<"In ("<<counter_sum<<" , "<<elem<<" ), c^0_ij + c^0_ji = "<<global_cij_x( counter_sum , elem ) + global_cij_x( elem , counter_sum )<<" and c^1_ij + c^1_ji = "<<global_cij_y( counter_sum , elem ) + global_cij_y( elem , counter_sum ) <<std::endl;
        }
        counter_sum++;
    }
    //std::cout<<"The sum0 is "<<'\n'<<sum0<<" and sum1 "<<'\n'<<sum1<<std::endl;
    */



// FLUX TERM
    Matrix<T, Dynamic, 1> flux0 = (u.vertices.first).cwiseProduct(phi.vertices);
    Matrix<T, Dynamic, 1> flux1 = (u.vertices.second).cwiseProduct(phi.vertices);



// RESOLUTION OF phi_tilde GLOBALE     ( with cij(phi_j - phi_i) )

    Matrix<T, Dynamic, 1> vec1 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    sum_Si(S_i, global_mass, phi.vertices, vec1);

    Matrix<T, Dynamic, 1> vec2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
//Matrix<T, Dynamic, 1> vec2_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    averaged_sum_Si(S_i, global_cij_x, flux0, vec2);
    averaged_sum_Si(S_i, global_cij_y, flux1, vec2);
//sum_Si(S_i , global_cij_x , flux0 , vec2_bis);
//sum_Si(S_i , global_cij_y , flux1 , vec2_bis);
//std::cout<<"diff vec 2 = "<<'\n'<<vec2-vec2_bis<<std::endl;
/// THERE IS A DIFFERENCE OF  <1E-18 DEPENDING IF I CONSIDER OR NOT THE AVERAGED SUM

    Matrix<T, Dynamic, 1> b = vec1 - dt * vec2.cwiseQuotient(global_lumped_mass);

/// OLD IMPLEMENTATION
//Matrix<T, Dynamic, 1> prova_FAST = global_mass.completeOrthogonalDecomposition().solve(b);
//phi_tilde.vertices = global_mass.HouseholderQR().solve(b);
    timecounter tc00;
    tc00.tic();
    LLT <Matrix<T, Dynamic, Dynamic>> llt(global_mass);
    phi_tilde.vertices = llt.solve(b);
    tc00.toc();


    if (llt.info() != Success) {
        std::cout << "not positive" << std::endl;
        assert(0);
    }
//std::cout<<"ERRORE FAST= "<<'\n'<<phi_tilde.vertices - prova_FAST <<std::endl;

    phi_tilde.converting_into_HHO_formulation(phi_tilde.vertices);
    std::cout << bold << yellow << "LLT RESOLUTION TIME: " << tc00 << " seconds" << reset << std::endl;


//std::cout<<"phi_tilde= "<<'\n'<<phi_tilde.vertices<<std::endl;
/*
    postprocess_output<double> postoutput3;
    typedef typename Mesh::point_type       point_type;
    point<double,2> node;
    auto test_phi_tilde = std::make_shared< gnuplot_output_object<double> >("phi_tilde.dat");
    for (size_t i = 0; i<phi_tilde.vertices.rows(); i++) {
        node = msh.points.at(i);
        test_phi_tilde->add_data(node,phi_tilde.vertices(i));
    }
    postoutput3.add_object(test_phi_tilde);
    postoutput3.write();
    */


// Term R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    for (auto &cl: msh.cells) {
        r_i_calculator(msh, cl, E, phi_tilde, phi, dt, u, S_i, Emax_global, Emin_global, R_i);
    }
//std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    R_i = R_i.cwiseQuotient(Emax_global - Emin_global);
//std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;



// CONVOLUTION TERM
//sum_Si(S_i, global_cij_x , flux0 , conv_global );
//sum_Si(S_i, global_cij_y , flux1 , conv_global );
    averaged_sum_Si(S_i, global_cij_x, flux0, conv_global);
    averaged_sum_Si(S_i, global_cij_y, flux1, conv_global);
// OLD IMPLEMENTATION
//auto conv_global2 = global_cij_x*( flux0 ) + global_cij_y*( flux1 ) ;

// Norm of c_ij
    moltiplication_Si(S_i, global_cij_x, global_cij_x, cij_square);
    moltiplication_Si(S_i, global_cij_y, global_cij_y, cij_square);
    Matrix <T, Dynamic, Dynamic> cij_norm = cij_square.cwiseSqrt();

// Matrix n_ij
    division_Si(S_i, global_cij_x, cij_norm, nij.first);
    division_Si(S_i, global_cij_y, cij_norm, nij.second);
// OLD IMPLEMENTATION
//auto nij2 = std::make_pair( global_cij_x.cwiseQuotient(cij_norm) , (global_cij_y).cwiseQuotient( cij_norm ) ) ;

// NOTICE:
/// Normal Velocity calculation IS EQUIVALENT TO f', that is EQUIVALENT to lambda_r , lambda_l.  Moreover I don't need the calculation of the normal flux. Since then it has to be derived, it is enough to calculate f' = u dot n

// Normal velocity
    Matrix <T, Dynamic, Dynamic> normal_vel = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    size_t counter_row = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            auto u_max_0 = std::max(u.vertices.first(counter_row), u.vertices.first(elem));
            auto u_max_1 = std::max(u.vertices.second(counter_row), u.vertices.second(elem));
            normal_vel(counter_row, elem) =
                    u_max_0 * nij.first(counter_row, elem) + u_max_1 * nij.second(counter_row, elem);
        }
        counter_row++;
    }




// C_ji matrix
    std::pair <Matrix<T, Dynamic, Dynamic>, Matrix<T, Dynamic, Dynamic>> cji_global = std::make_pair(
            global_cij_x.adjoint(), global_cij_y.adjoint());

// Norm of c_ji -> i.e. c_ij transposed
    moltiplication_Si(S_i, cji_global.first, cji_global.first, cji_square);
    moltiplication_Si(S_i, cji_global.second, cji_global.second, cji_square);
// CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
//moltiplication_Si_T( S_i , cji_global.first , cji_global.first , cji_square );
//moltiplication_Si_T( S_i , cji_global.second , cji_global.second , cji_square );

//C_ji Norm
    Matrix <T, Dynamic, Dynamic> cji_norm = cji_square.cwiseSqrt();
//auto cji_square2 = (cji_global.first).cwiseProduct(cji_global.first) + (cji_global.second).cwiseProduct(cji_global.second);
//Matrix<T, Dynamic, Dynamic> cji_norm2 = cji_square2.cwiseSqrt();


// Matrix n_ij (TRANSPOSED)
    division_Si(S_i, cji_global.first, cji_norm, nij_transpose.first);
    division_Si(S_i, cji_global.second, cji_norm, nij_transpose.second);
// CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
//division_Si_T( S_i , cji_global.first , cji_norm , nij_transpose.first );
//division_Si_T( S_i , cji_global.second , cji_norm , nij_transpose.second );
//auto  nij_transposex2 = cji_global.first.cwiseQuotient( cji_norm2 );
//auto  nij_transposey2 = cji_global.second.cwiseQuotient( cji_norm2 );

// Normal velocity (TRANSPOSED)
    Matrix <T, Dynamic, Dynamic> normal_vel_adj = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
//Matrix<T, Dynamic, Dynamic> normal_vel_adj2 = Eigen::Matrix<T,Dynamic,Dynamic>::Zero(dim, dim);
/*
    for(size_t i = 0 ; i< normal_vel_adj2.rows() ; i++)
    {
        for(size_t j = 0 ; j< normal_vel_adj2.cols() ; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            //normal_vel(counter_row,elem) = u_max_0 * nij.first(counter_row,elem) + u_max_1*nij.second(counter_row,elem);
            // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
            normal_vel_adj2(i,j) = u_max_0 * nij_transposex2(i,j) + u_max_1*nij_transposey2(i,j);
        }
    }

    */

    counter_row = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            auto u_max_0 = std::max(u.vertices.first(elem), u.vertices.first(counter_row));
            auto u_max_1 = std::max(u.vertices.second(elem), u.vertices.second(counter_row));
//normal_vel_adj(elem,counter_row) = u_max_0 * nij.first(elem,counter_row) + u_max_1*nij.second(elem,counter_row);
// CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
            normal_vel_adj(counter_row, elem) = u_max_0 * nij_transpose.first(counter_row, elem) +
                                                u_max_1 * nij_transpose.second(counter_row, elem);
        }
        counter_row++;
    }


// Matrix Dij calculation
    Matrix <T, Dynamic, Dynamic> lambda_max = normal_vel.cwiseAbs();  // o lambda_max=normal_vel ?
    Matrix <T, Dynamic, Dynamic> tmp = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    moltiplication_Si(S_i, lambda_max, cij_norm, tmp);

    Matrix <T, Dynamic, Dynamic> lambda_max_adj = normal_vel_adj.cwiseAbs();// o lambda_max=normal_vel?
    Matrix <T, Dynamic, Dynamic> tmp_adj = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    moltiplication_Si(S_i, lambda_max_adj, cji_norm, tmp_adj);
// CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
//moltiplication_Si_T( S_i , lambda_max_adj , cji_norm , tmp_adj );
//Matrix<T, Dynamic, Dynamic> lambda_max_adj2=normal_vel_adj2.cwiseAbs();
//auto tmp_adj2 = lambda_max_adj.cwiseProduct( cji_norm2 ) ;

    Matrix <T, Dynamic, Dynamic> dij = tmp.cwiseMax(tmp_adj);

//Matrix<T, Dynamic, Dynamic> dij2 = tmp.cwiseMax(tmp_adj2);

//std::cout<<"Dij: "<<'\n'<<dij<<std::endl;

/*
      /// The  error is < 1e-15, at max
    std::cout<<"D_ij check: "<<std::endl;
    for(size_t i = 0; i<tmp.rows();i++){
        for(size_t j = i+1; j<tmp.rows();j++){
            if(std::abs(dij(i,j)-dij(j,i))>1e-15)
            std::cout<<dij(i,j)-dij(j,i);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */


    tc1.toc();
    std::cout << bold << yellow << "Solving time method original: " << tc1 << " seconds" << reset << std::endl;

    timecounter tc2;
    tc2.tic();




// Minimum between d_ij and R_i
    T c_e = 1.;
    Matrix <T, Dynamic, Dynamic> dE_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    Matrix <T, Dynamic, Dynamic> phi_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    counter_row = 0;

    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
            if (elem != counter_row) {
                auto R_i_j = c_e * std::max(std::abs(R_i(counter_row)), std::abs(R_i(elem)));
                dE_ij(counter_row, elem) = std::min(dij(counter_row, elem), R_i_j);
//std::cout<<"R_i_j "<<R_i_j<<" and dij"<<dij( counter_row , elem )<<std::endl;
            }
            phi_ij(counter_row, elem) = 0.5 * (phi.vertices(counter_row) + phi.vertices(elem));
        }
        counter_row++;
    }
//std::cout<<"dE_ij: "<<'\n'<<dE_ij<<std::endl;
//std::cout<<"phi_ij"<<'\n'<<phi_ij<<std::endl;
    T c_comp = 1.;
    Matrix <T, Dynamic, Dynamic> dC_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    Matrix <T, Dynamic, Dynamic> tmp0 = phi_ij - phi_ij.cwiseProduct(phi_ij);
//Matrix<T, Dynamic, Dynamic> tmp0 = (phi_ij-phi.phi_min*Mat_One).cwiseProduct(phi.phi_max*Mat_One-phi_ij);
//std::cout<<"tmp0: "<<'\n'<<tmp0<<std::endl;
    positive_part(tmp0);


// Matrix<T, Dynamic, Dynamic> tmp_dC0 = positive_part( tmp0 );


    Matrix <T, Dynamic, Dynamic> tmp_dC1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);

    size_t counter = 0;
    for (auto &row_i: S_i) {
        for (auto &elem: row_i) {
// std::cout<<"In ("<<counter<<" , "<<elem<<") tmp_dC0 = "<<tmp_dC0(counter,elem)<<" and phi.ver diff "<<std::abs(phi.vertices(counter) - phi.vertices(elem))<<std::endl;
            if (std::abs(phi.vertices(counter) - phi.vertices(elem)) > 1e-15)
                tmp_dC1(counter, elem) = tmp0(counter, elem) / (std::abs(phi.vertices(counter) - phi.vertices(elem)));
        }
        counter++;
    }
//std::cout<<'\n'<<"tmp_dC1: "<<'\n'<<tmp_dC1<<std::endl;
    Matrix <T, Dynamic, Dynamic> tmp1 = Mat_One - c_comp * tmp_dC1;

//std::cout<<'\n'<<"tmp1: "<<'\n'<<tmp1<<std::endl;
    positive_part(tmp1);
//std::cout<<'\n'<<"tmp1 POSTIVIVE: "<<'\n'<<tmp1<<std::endl;

    moltiplication_Si(S_i, dE_ij, tmp1, dC_ij);


    for (size_t i = 0; i < dC_ij.rows(); i++) {
        dC_ij(i, i) = 0;
        dij(i, i) = 0;
        dC_ij(i, i) = -dC_ij.row(i).sum();
        dij(i, i) = -dij.row(i).sum();
    }
//dC_ij = dE_ij.cwiseProduct( positive_part( tmp1  ) );
//   std::cout<<'\n'<<"dC_ij: "<<'\n'<<dC_ij<<std::endl;
//   std::cout<<'\n'<<"dij: "<<'\n'<<dij<<std::endl;


//std::cout<<"dC_ij: "<<'\n'<<dC_ij<<std::endl;


/*
    counter_row = 0;
    std::cout<<"DC_ij check symmetry: "<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<dC_ij(counter_row,elem) - dC_ij(elem,counter_row)<<std::endl;
        }
        counter_row++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;


    counter_row = 0;
    std::cout<<"D_ij check symmetry "<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<dij(counter_row,elem) - dij(elem,counter_row)<<std::endl;
        }
        counter_row++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */


// Term D_ij(phi_j - phi_i )
    averaged_sum_Si(S_i, dC_ij, phi.vertices, term_dij);
//std::cout<<"term_dij : "<<'\n'<<term_dij<<std::endl;


//averaged_sum_Si(S_i, dE_ij , phi.vertices , term_dij );
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
// VERSION WITHOUT ENTROPY CORRECTION
    averaged_sum_Si(S_i, dij, phi.vertices, term_dij_no_entropy);

//std::cout<<"term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy<<std::endl;

// M*phi^n
    Matrix<T, Dynamic, 1> mass_phi_old = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    sum_Si(S_i, global_mass, phi.vertices, mass_phi_old);



/*
    // **************** OLD IMPLEMENTATION **************** //

   for (size_t i = 0; i<global_lumped_mass.rows(); i++) {
          global_lumped_mass(i) = global_mass.row(i).sum() ;
      }


    Matrix<T, Dynamic, Dynamic> normal_vel2 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim1, dim2);
    Matrix<T, Dynamic, Dynamic> normal_vel_adj2 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim2, dim1);

    //normal velocity
    for (size_t i = 0; i < dim1; i++)
    {
        for (size_t j = 0; j < dim2; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            normal_vel2( i , j ) = u_max_0 * nij.first(i,j) + u_max_1*nij.second(i,j);
            //}
        }

    }

     //normal velocity (transposed)
    auto nij_transpose2 = std::make_pair( ( global_cij_x.transpose() ).cwiseQuotient(cji_norm) ,                                    ( global_cij_y. transpose() ).cwiseQuotient( cji_norm ) ) ;

    for (size_t i = 0; i < dim2; i++)
    {
        for (size_t j = 0; j < dim1; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            normal_vel_adj2( i , j ) = u_max_0 * nij_transpose2.first(i,j) + u_max_1*nij_transpose2.second(i,j);
        }
    }

    Matrix<T, Dynamic, Dynamic> lambda_max2 = normal_vel2.cwiseAbs() ;  // o lambda_max=normal_vel ?
    auto tmp2 = lambda_max2.cwiseProduct( cij_norm ) ;

    Matrix<T, Dynamic, Dynamic> lambda_max_adj2 = normal_vel_adj2.cwiseAbs() ;
    auto tmp_adj2 = lambda_max_adj2.cwiseProduct( cji_norm ) ;

    auto dij2 = tmp2.cwiseMax(tmp_adj2);
    Matrix<T, Dynamic, 1> term_dij2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim2, 1);
    /// CHECK OUT THE FUNCTION: make_dij_vector
    // auto phi_old = (phi.values_bis).col(counter);
    // auto last_term = make_dij_vector(msh , dij, phi_old );

    for (size_t i = 0; i<dij.rows(); i++)
    {
        auto diff =  phi.vertices - phi.vertices(i)*Vec_One;
        term_dij2(i) = ( dij2.row(i) ).dot( diff )  ;
    }
    std::cout<<"diff term dij: "<<term_dij-term_dij2<<std::endl;

    // ****************END OF OLD IMPLEMENTATION **************** //

 */

    tc2.toc();
    std::cout << bold << yellow << "Solving time method2: " << tc2 << " seconds" << reset << std::endl;


    timecounter tc3;
    tc3.tic();

///********* RESOLUTION OF THE SYSTEM: **********//
//tc.tic();
    Matrix<T, Dynamic, 1> phi_L = solveFEM(global_lumped_mass, conv_global, term_dij_no_entropy, phi.vertices, dt,
                                           bdry_nodes); // VERSION WITHOUT ENTROPY CORRECTION
    tc3.toc();
    std::cout << bold << yellow << "Solving time ORIGINAL METHOD: " << tc3 << " seconds" << reset << std::endl;

    timecounter tc4;
    tc4.tic();

    Matrix<T, Dynamic, 1> phi_H = solveFEM_Entropic_FAST(llt, conv_global, term_dij, mass_phi_old, dt);

//Matrix<T, Dynamic, 1> phi_H = solveFEM_Entropic(global_mass , conv_global , term_dij , mass_phi_old , dt );
//std::cout<<'\n'<<"phi_H -phi_H_fast : "<<'\n'<<phi_H-phi_H_prova<<std::endl;
    tc4.toc();

    std::cout << bold << yellow << "Solving time CORRECTED METHOD: " << tc4 << " seconds" << reset << std::endl;



// std::cout<<'\n'<<"phi_L : "<<'\n'<<phi_L<<std::endl;


// CHECKING phi_h and phi_l
    Matrix<T, Dynamic, 1> zero_vec = Eigen::Matrix<T, Dynamic, 1>::Zero(phi.vertices.rows(), 1);
// checking_phi_l( global_lumped_mass , global_cij_x , global_cij_y ,dij , phi.vertices ,phi_L,dt, S_i); // NO, DA MODIFICARE

//checking_phi_lBIS( global_lumped_mass , conv_global , term_dij_no_entropy , phi.vertices , phi_L , dt );

//checking_phi_h( global_mass , global_cij_x , global_cij_y , dC_ij , phi.vertices  , phi_H ,dt,S_i); // NO, DA MODIFICARE

//checking_phi_hBIS( global_mass , conv_global , term_dij , phi.vertices , phi_H , dt );






// EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi.vertices;
//std::cout<<'\n'<<"delta_phi "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator(global_lumped_mass, global_mass, delta_phi, dt, dij, dC_ij, phi.vertices,
                                             S_i);

// CHECKING PHI
    auto check_phi = phi_H - phi_L - f_i.cwiseQuotient(global_lumped_mass);//+dt*Vec_One ;
    Matrix<T, Dynamic, 1> phi_H2 = phi_L + f_i.cwiseQuotient(global_lumped_mass);
//std::cout<<'\n'<<"check phi "<<'\n'<<check_phi<<std::endl;
// std::cout<<'\n'<<"check phi_h: "<<'\n'<<phi_H - phi_H2<<std::endl;

// CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator(global_lumped_mass, global_mass, delta_phi, phi_L, dt, dij,
                                                           dC_ij, phi.vertices, S_i);
    Matrix<T, Dynamic, 1> phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

//T check_phi2 = ((phi_new - phi_L).cwiseProduct(global_lumped_mass)).sum();
// std::cout<<'\n'<<"check PHI_NEW - PHI_L = "<<check_phi2<<std::endl;

//T check_phi3 = ((phi_new - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
// std::cout<<'\n'<<"check PHI_NEW - PHI_OLD = "<<check_phi3<<std::endl;

// T check_phi4 = ((phi_L - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
// std::cout<<'\n'<<"check PHI_L - PHI_OLD = "<<check_phi4<<std::endl;

//T check_phi5 = ((phi_H - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
//std::cout<<'\n'<<"check PHI_H - PHI_OLD = "<<check_phi5<<std::endl;

//T check_phi6 = ((phi_H - phi_L).cwiseProduct(global_lumped_mass)).sum();
//std::cout<<'\n'<<"check PHI_H - PHI_L = "<<check_phi6<<std::endl;



// BOUNDARY CONDITION IMPOSITION -->   NO ENTROPY
    for (auto &j: bdry_nodes)
        phi_L(j) = phi.vertices(j);

// BOUNDARY CONDITION IMPOSITION -> ENTROPIC SOLUTION
    for (auto &j: bdry_nodes)
        phi_H(j) = phi.vertices(j);

// BOUNDARY CONDITION IMPOSITION -> ENTROPIC AND MAX PRESERVING SOLUTION
    for (auto &j: bdry_nodes)
        phi_new(j) = phi.vertices(j);


// SAVING AND UPLOAD phi_new  INTO CLASS projected_level_set
    phi.converting_into_HHO_formulation(phi_new);
    phi.vertices = phi_new;

// INVERSE MAPPING BACK [0,1] --> [PHI_MIN,PHI_MAX]
    inverse_mapping_phi(phi, phi.phi_max, phi.phi_min);
    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;

/// PLOTTING SOLUTION (GNUPLOT)
/*
    postprocess_output<double> postoutput5;
    // auto test_phi_h = std::make_shared< gnuplot_output_object<double> >("phi_h.dat");
    // auto test_phi_l = std::make_shared< gnuplot_output_object<double> >("phi_l.dat");
    auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");

    size_t iii = 0;
    for (auto pt : msh.points) {
      //  test_phi_h->add_data(pt,phi_H(iii) );
      //  test_phi_l->add_data(pt,phi_L(iii) );
        test_phi_new->add_data(pt,phi_new(iii) );
        iii++;
    }
    //   postoutput5.add_object(test_phi_h);
    //  postoutput5.add_object(test_phi_l);
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */

    std::cout << bold << yellow << "!!ATTENCTION: I'M COMPUTING BOTH phi AND phi_entropic!!" << reset << std::endl;



/// COUT OF PHI IN CELLWISE NOTATION
/*
    for (size_t i = 0; i<phi.values_bis.rows(); i++) {
        for (size_t j = 0; j<phi.values_bis.cols(); j++) {
            std::cout<<phi.values_bis(i,j);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
*/



}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type, typename VEC>
void Lp_space_Tfin_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                             size_t degree, double p, VEC &error) {
    T errorLp = 0.;
    for (auto &cl: msh.cells) {
        auto qps = integrate(msh, cl, 2 * degree + 2);
        for (auto &qp: qps) {
            auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
            errorLp += qp.second * pow(diff_val, p);
        }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
//std::cout<<"The L^"<<p<<" error is "<< pow (errorLp , 1.0/p )<<std::endl;
    error.push_back(pow(errorLp, 1.0 / p));
}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
void Lp_space_Tfin_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                             size_t degree, double p) {
    T errorLp = 0.;
    for (auto &cl: msh.cells) {
        auto qps = integrate(msh, cl, 2 * degree + 2);
        for (auto &qp: qps) {
            auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
            errorLp += qp.second * pow(diff_val, p);
        }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    std::cout << "The L^" << p << " error is " << pow(errorLp, 1.0 / p) << std::endl;
}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T
Linf_error_FEM_new(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
    T errorLinf = ((level_set_final.sol_HHO - level_set_initial.sol_HHO).cwiseAbs()).maxCoeff();
    return errorLinf;

}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T W1inf_error_FEM_new(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh,
                      size_t degree) {
    T errorLinf0 = 0.0, errorLinf1 = 0.0;

    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
//auto pts = points(msh,cl);
        for (auto &pt: pts) {
            auto diff_val0 = std::abs(
                    level_set_final.gradient(pt, msh, cl)(0) - level_set_initial.gradient(pt, msh, cl)(0));
            errorLinf0 = std::max(errorLinf0, diff_val0);
            auto diff_val1 = std::abs(
                    level_set_final.gradient(pt, msh, cl)(1) - level_set_initial.gradient(pt, msh, cl)(1));
            errorLinf1 = std::max(errorLinf1, diff_val1);
        }

    }
    return errorLinf0 + errorLinf1;

}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T Lp_space_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree,
                     double p) {
// L^p in space ; l^q in time
    T errorLp = 0.;
    for (auto &cl: msh.cells) {
        auto qps = integrate(msh, cl, 2 * degree + 2); // what orders?
        for (auto &qp: qps) {
            auto diff_val = std::abs(level_set_final(qp.first, msh, cl) - level_set_initial(qp.first, msh, cl));
            errorLp += qp.second * pow(diff_val, p);
        }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    errorLp = pow(errorLp, 1.0 / p);
//std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
    return errorLp;
}

template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T W1p_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree,
                double p) {
    T errorH1 = 0.;
    for (auto &cl: msh.cells) {
        auto qps = integrate(msh, cl, 2 * degree + 2); // what orders?
        for (auto &qp: qps) {
            auto diff_val0 = std::abs(
                    level_set_final.gradient(qp.first, msh, cl)(0) - level_set_initial.gradient(qp.first, msh, cl)(0));
            auto diff_val1 = std::abs(
                    level_set_final.gradient(qp.first, msh, cl)(1) - level_set_initial.gradient(qp.first, msh, cl)(1));
            errorH1 += qp.second * (pow(diff_val0, p) + pow(diff_val1, p));
        }
//std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    errorH1 = pow(errorH1, 1.0 / p);
//std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
    return errorH1;
}


template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T Linf_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
    T errorLinf = ((level_set_final.vertices - level_set_initial.vertices).cwiseAbs()).maxCoeff();
    return errorLinf;

}

template<typename Mesh, typename Fonction, typename T = typename Mesh::coordinate_type>
T W1inf_error_FEM(const Fonction &level_set_final, const Fonction &level_set_initial, const Mesh &msh, size_t degree) {
    T errorLinf0 = 0, errorLinf1 = 0;

    for (auto &cl: msh.cells) {
        auto pts = points(msh, cl);
        for (auto &pt: pts) {
            auto diff_val0 = std::abs(
                    level_set_final.gradient(pt, msh, cl)(0) - level_set_initial.gradient(pt, msh, cl)(0));
            errorLinf0 = std::max(errorLinf0, diff_val0);
            auto diff_val1 = std::abs(
                    level_set_final.gradient(pt, msh, cl)(1) - level_set_initial.gradient(pt, msh, cl)(1));
            errorLinf1 = std::max(errorLinf1, diff_val1);
        }

    }
    return errorLinf0 + errorLinf1;

}


template<typename T, typename VeloField>
T time_step_CFL(const VeloField &u, const mesh_init_params <T> &mip, T eps) {

    auto h_max = std::max(mip.hx(), mip.hy());
    auto u_max = u.values_bis.first.template lpNorm<Infinity>() + u.values_bis.second.
            template lpNorm<Infinity>();
    if (std::abs(u_max) < 1e-15)
        return 1e-8;
    else
        return eps * h_max / u_max;
}

template<typename T, typename VeloField>
T time_step_CFL_new(const VeloField &u, const mesh_init_params <T> &mip, T eps) {

    auto h_max = std::max(mip.hx(), mip.hy());
    auto u_max = u.sol_FEM.first.template lpNorm<Infinity>() + u.sol_FEM.second.
            template lpNorm<Infinity>();
    if (std::abs(u_max) < 1e-15)
        return 1e-8;
    else
        return eps * h_max / (std::abs(u_max));
}


template<typename Mesh, typename T, typename VeloField>
T time_step_CFL_u_Gamma(const Mesh &msh, VeloField &u, const mesh_init_params <T> &mip, T eps) {
    auto h_max = std::max(mip.hx(), mip.hy());
    size_t degree_velocity = u.degree_FEM;
    T u_max = -1.0;
    for (auto &cl: msh.cells) {
        if (cl.user_data.location == element_location::ON_INTERFACE) {
            u.cell_assignment(cl);

            auto qps = integrate_interface(msh, cl, degree_velocity, element_location::ON_INTERFACE);
            for (auto &qp: qps) {
                auto u_pt = u(qp.first);
                u_max = std::max(u_max, std::abs(u_pt.first) + std::abs(u_pt.second));

            }

        }


    }
    if (std::abs(u_max) < 1e-15)
        return 1e-8;
    else
        return eps * h_max / (std::abs(u_max));
}


template<typename Mesh, typename T, typename VeloField>
T time_step_CFL_new_ANALYTIC_VEL(const Mesh &msh, const VeloField &u, size_t degree, const mesh_init_params <T> &mip,
                                 T eps) {

    auto h_max = std::max(mip.hx(), mip.hy());
    T u_max0 = -10.0;
    T u_max1 = -10.0;
    for (auto &cl: msh.cells) {
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, degree);
        for (auto &pt: pts) {
            u_max0 = std::max(u_max0, std::abs(u(pt)[0]));
            u_max1 = std::max(u_max1, std::abs(u(pt)[1]));
        }
    }
    T u_max = u_max0 + u_max1;

    if (std::abs(u_max) < 1e-15)
        return 1e-8;
    else
        return eps * h_max / (std::abs(u_max));
}

template<typename T>
T time_step_STK(T eta, T gamma, const mesh_init_params <T> &mip, T c2) {

    auto h_max = std::max(mip.hx(), mip.hy());
    return c2 * eta / gamma * h_max;


}















/*****************************************************************************
*   PREVIOUS CODE STOKES HHO
*****************************************************************************/



///////////////////////   FICTITIOUS DOMAIN METHODS  ///////////////////////////

template<typename T, size_t ET, typename testType>
class stokes_fictdom_method {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_fictdom_method(bool sym)
            : sym_grad(sym) {
    }

    virtual std::pair <std::pair<Mat, Mat>, std::pair<Vect, Vect>>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi,
                     const element_location where = element_location::IN_NEGATIVE_SIDE,
                     const params <T> &parms = params<T>()) {
    }

public:
    std::pair <std::pair<Mat, Mat>, std::pair<Vect, Vect>>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info hdi, const testType test_case) {
        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = gr2 + stab;
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Vect f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);
        Vect p_rhs = Vect::Zero(dr.first.rows());
        return std::make_pair(std::make_pair(lc, dr.second), std::make_pair(f, p_rhs));
    }


    std::pair <std::pair<Mat, Mat>, std::pair<Vect, Vect>>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType test_case, const hho_degree_info hdi,
                 const element_location where = element_location::IN_NEGATIVE_SIDE,
                 const params <T> &parms = params<T>()) {
        if (location(msh, cl) == where)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else if (location(msh, cl) != element_location::ON_INTERFACE) {
            Mat lc;
            Vect f;
            return std::make_pair(std::make_pair(lc, lc), std::make_pair(f, f));
        } else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi, where, parms);
    }
};

/////////////////////////  GRADREC_FICTITIOUS_METHOD

template<typename T, size_t ET, typename testType>
class gradrec_stokes_fictdom_method :
        public stokes_fictdom_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta;

    gradrec_stokes_fictdom_method(T eta_, bool sym)
            : stokes_fictdom_method<T, ET, testType>(sym), eta(eta_) {
    }

    std::pair <std::pair<Mat, Mat>, std::pair<Vect, Vect>>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi,
                     const element_location where = element_location::IN_NEGATIVE_SIDE,
                     const params <T> &parms = params<T>()) {
// LHS
        Mat gr1, gr2;
        if (this->sym_grad) {
            auto gr = make_hho_gradrec_sym_matrix(msh, cl, test_case.level_set_, hdi, where, 1.0);
            gr1 = gr.first;
            gr2 = gr.second;
        } else {
            auto gr = make_hho_gradrec_matrix(msh, cl, test_case.level_set_, hdi, where, 1.0);
            gr1 = gr.first;
            gr2 = gr.second;
        }
        Mat stab = make_hho_vector_cut_stabilization(msh, cl, hdi, where)
                   + make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta);
        Mat lc = gr2 + stab;
        auto dr = make_hho_divergence_reconstruction(msh, cl, test_case.level_set_,
                                                     hdi, where, 1.0);

// RHS
        auto celdeg = hdi.cell_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);

        Vect f = Vect::Zero(lc.rows());
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun, where);
        f.block(0, 0, cbs, 1) += make_vector_rhs_penalty(msh, cl, celdeg, test_case.bcs_vel, eta);
        f += make_vector_GR_rhs(msh, cl, celdeg, test_case.bcs_vel, test_case.level_set_,
                                gr1, this->sym_grad);
        auto p_rhs = make_pressure_rhs(msh, cl, hdi.face_degree(), where,
                                       test_case.level_set_, test_case.bcs_vel);

        return std::make_pair(std::make_pair(lc, dr.second), std::make_pair(f, p_rhs));
    }
};


template<typename T, size_t ET, typename testType>
auto make_gradrec_stokes_fictdom_method(const cuthho_mesh <T, ET> &msh, const T eta_,
                                        const testType test_case, bool sym) {
    return gradrec_stokes_fictdom_method<T, ET, testType>(eta_, sym);
}

///////////////////////////

template<typename Mesh, typename testType>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_fictdom(const Mesh &msh, size_t degree, testType test_case) {
    using RealType = typename Mesh::coordinate_type;

    auto level_set_function = test_case.level_set_;

    auto sol_vel = test_case.sol_vel;
    auto vel_grad = test_case.vel_grad;
    auto bcs_fun = test_case.bcs_vel;


/************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_fictdom.silo");
    silo.add_mesh(msh, "mesh");

/************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector <RealType> cut_cell_markers;
    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            cut_cell_markers.push_back(1.0);
        else if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            cut_cell_markers.push_back(-1.0);
        else if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

/************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector <RealType> level_set_vals;
    for (auto &pt: msh.points)
        level_set_vals.push_back(level_set_function(pt));
    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

/************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector <RealType> node_pos;
    for (auto &n: msh.nodes)
        node_pos.push_back(location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0);
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);


    timecounter tc;

    bool sc = true; // static condensation

/************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree + 1, degree);
//    std::cout<<"HHO degree k both cells and faces."<<std::endl;
//    hho_degree_info hdi(degree, degree);

    element_location where = element_location::IN_NEGATIVE_SIDE;

    tc.tic();
    auto assembler = make_stokes_fict_assembler(msh, bcs_fun, hdi, where);
    auto assembler_sc = make_stokes_fict_condensed_assembler(msh, bcs_fun, hdi, where);

// method with gradient reconstruction (penalty-free)
    bool sym = true; // true
    auto class_meth = make_gradrec_stokes_fictdom_method(msh, 1.0, test_case, sym);

    for (auto &cl: msh.cells) {
        if (!(location(msh, cl) == element_location::ON_INTERFACE || location(msh, cl) == where))
            continue;
        auto contrib = class_meth.make_contrib(msh, cl, test_case, hdi,
                                               element_location::IN_NEGATIVE_SIDE);
        auto lc_A = contrib.first.first;
        auto lc_B = -contrib.first.second;
        auto rhs_A = contrib.second.first;
        auto rhs_B = -contrib.second.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc_A, lc_B, rhs_A, rhs_B);
        else
            assembler.assemble(msh, cl, lc_A, lc_B, rhs_A, rhs_B);


    }

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;


/************** SOLVE **************/
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

/************** POSTPROCESS **************/



    postprocess_output <RealType> postoutput;

    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("fictdom_uT_norm.dat");
    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("fictdom_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("fictdom_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("fictdom_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    for (auto &cl: msh.cells) {
        RealType L2_pressure_error_cell = 0.0;
        bool hide_fict_dom = true; // hide the fictitious domain in the gnuplot outputs


        if (hide_fict_dom && location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            continue;

        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis <cuthho_poly_mesh<RealType>, RealType> s_cb(msh, cl, hdi.face_degree());

        auto cbs = cb.size();

        Matrix<RealType, Dynamic, 1> locdata_vel, locdata_p;
        if (sc) {
            locdata_vel = assembler_sc.take_velocity(msh, cl, sol);
            locdata_p = assembler_sc.take_pressure(msh, cl, sol);
        } else {
            locdata_vel = assembler.take_velocity(msh, cl, sol);
            locdata_p = assembler.take_pressure(msh, cl, sol);
        }

        Matrix<RealType, Dynamic, 1> cell_v_dofs = locdata_vel.head(cbs);

//auto bar = barycenter(msh, cl, element_location::IN_NEGATIVE_SIDE);

        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE ||
            location(msh, cl) == element_location::ON_INTERFACE) {
//Matrix<RealType, 1, 2> real_grad_int = Matrix<RealType, 1, 2>::Zero();
//Matrix<RealType, 1, 2> comp_grad_int = Matrix<RealType, 1, 2>::Zero();
            auto qps = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 0; i < cbs; i++)
                    grad += cell_v_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;

                H1_error += qp.second * inner_product(grad_diff, grad_diff);


/* L2 - error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * cell_v_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto s_cphi = s_cb.eval_basis(qp.first);
                RealType p_num = s_cphi.dot(locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error_cell += qp.second * p_diff * p_diff;
                p_gp->add_data(qp.first, p_num);

            }
            std::cout << "L2_pressure_error_cell" << L2_pressure_error_cell << std::endl;
        }

    }

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2 - pressure - error:                " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT_l2_gp);
    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();

    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
    if (sc)
        Mat = assembler_sc.LHS;
    else
        Mat = assembler.LHS;


// Add by Stefano
    Eigen::BDCSVD <Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
    double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size() - 1);
    std::cout << "cond_numb = " << cond << std::endl;

    return TI;
}



//////////////////////////////  INTERFACE METHODS  ///////////////////////////

template<typename T, size_t ET, typename testType>
class stokes_interface_method {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method(bool sym)
            : sym_grad(sym) {
    }

    stokes_interface_method(stokes_interface_method &other) {
        sym_grad = other.sym_grad;

    }

    stokes_interface_method(const stokes_interface_method &other) {
        sym_grad = other.sym_grad;

    }

    virtual std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info &hdi) {
    }

public:
    std::pair <Mat, Vect>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info &hdi, const testType &test_case) {
        T kappa;
        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero(loc_size, loc_size);
        Vect rhs = Vect::Zero(loc_size);

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair <Mat, Vect>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType &test_case, const hho_degree_info &hdi) {
        if (location(msh, cl) != element_location::ON_INTERFACE)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};


template<typename T, size_t ET, typename testType>
class stokes_interface_method_ref_pts {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method_ref_pts(bool sym)
            : sym_grad(sym) {
    }

    virtual std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
    }

public:
    std::pair <Mat, Vect>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info hdi, const testType &test_case) {
        T kappa;
        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero(loc_size, loc_size);
        Vect rhs = Vect::Zero(loc_size);

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair <Mat, Vect>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType &test_case, const hho_degree_info hdi) {
        if (location(msh, cl) != element_location::ON_INTERFACE)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};


template<typename T, size_t ET, typename testType>
class stokes_interface_method_ref_pts_cont {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method_ref_pts_cont(bool sym)
            : sym_grad(sym) {
    }

    virtual std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
    }

public:
    std::pair <Mat, Vect>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info hdi, const testType &test_case) {
        T kappa;
        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero(loc_size, loc_size);
        Vect rhs = Vect::Zero(loc_size);

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair <Mat, Vect>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType &test_case, const hho_degree_info hdi) {
        if (location(msh, cl) != element_location::ON_INTERFACE)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};



////////////////////////  SYMMETRIC GRADREC INTERFACE METHOD


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method :
        public stokes_interface_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method(T eta_, T gamma_, bool sym)
            : stokes_interface_method<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info &hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                   test_case.neumann_jump); // 0.5*

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                                               test_case.neumann_jump); // 0.5 *


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method(const cuthho_mesh <T, ET> &msh, const T eta_,
                                              const T gamma_, testType &test_case, bool sym) {
    return Sym_gradrec_stokes_interface_method<T, ET, testType>(eta_, gamma_, sym);
}


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_alfai :
        public stokes_interface_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;


public:
    T eta, gamma_0;
    T alfa1, alfa2;


    Sym_gradrec_stokes_interface_method_alfai(Sym_gradrec_stokes_interface_method_alfai &other)
            : stokes_interface_method<T, ET, testType>(other) {
        eta = other.eta;
        gamma_0 = other.gamma_0;
        alfa1 = other.alfa1;
        alfa2 = other.alfa2;
    }

    Sym_gradrec_stokes_interface_method_alfai(const Sym_gradrec_stokes_interface_method_alfai &other)
            : stokes_interface_method<T, ET, testType>(other) {
        eta = other.eta;
        gamma_0 = other.gamma_0;
        alfa1 = other.alfa1;
        alfa2 = other.alfa2;
    }


    Sym_gradrec_stokes_interface_method_alfai(T eta_, T gamma_, bool sym, T alfa1_, T alfa2_)
            : stokes_interface_method<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_), alfa1(alfa1_), alfa2(alfa2_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info &hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, alfa1).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, alfa2).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, alfa1).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, alfa2).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);

// It should be k_i s.t. k_i <= k_j
        auto k_min = std::min(parms.kappa_1, parms.kappa_2);
        auto k_arm = 2.0 / (1.0 / parms.kappa_1 + 1.0 / parms.kappa_2);
        auto k_penalty = k_arm;
        stab.block(0, 0, cbs, cbs) += k_penalty * penalty;
        stab.block(0, cbs, cbs, cbs) -= k_penalty * penalty;
        stab.block(cbs, 0, cbs, cbs) -= k_penalty * penalty;
        stab.block(cbs, cbs, cbs, cbs) += k_penalty * penalty;

//        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
//        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
//        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
//        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;


// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE,
                 alfa1);//0.5); // Modified by Stefano
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE,
                 alfa2);// 0.5);  // Modified by Stefano


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += alfa2 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                     test_case.neumann_jump); // 0.5*

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += alfa1 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                                                 test_case.neumann_jump); // 0.5 *


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};


template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_alfai(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                    const T gamma_, testType &test_case, bool sym, T alfa1, T alfa2) {
    return Sym_gradrec_stokes_interface_method_alfai<T, ET, testType>(eta_, gamma_, sym, alfa1, alfa2);
}


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_ref_pts :
        public stokes_interface_method_ref_pts<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_ref_pts(T eta_, T gamma_, bool sym)
            : stokes_interface_method_ref_pts<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface_ref_pts
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface_ref_pts
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
// ANCORA DA MODIFICAREEEEEE
            std::cout << "STILL TO BE MODIFIED WITH parametric curve" << std::endl;
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface_ref_pts
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface_ref_pts
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization_ref_pts(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5 * make_vector_flux_jump_reference_pts(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                                 test_case.neumann_jump);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump_reference_pts(msh, cl, celdeg,
                                                                             element_location::IN_POSITIVE_SIDE,
                                                                             test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS_ref_pts
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_ref_pts(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                      const T gamma_, testType &test_case, bool sym) {
    return Sym_gradrec_stokes_interface_method_ref_pts<T, ET, testType>(eta_, gamma_, sym);
}


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_ref_pts_cont :
        public stokes_interface_method_ref_pts_cont<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_ref_pts_cont(T eta_, T gamma_, bool sym)
            : stokes_interface_method_ref_pts_cont<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto parametric_interface = test_case.parametric_interface;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                    (msh, cl, parametric_interface, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                    (msh, cl, parametric_interface, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
// ANCORA DA MODIFICAREEEEEE
            std::cout << "STILL TO BE MODIFIED WITH parametric curve" << std::endl;
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization_ref_pts_cont(msh, cl, hdi, parametric_interface);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5 *
                       make_vector_flux_jump_reference_pts_cont(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                                test_case.neumann_jump, parametric_interface);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump_reference_pts_cont(msh, cl, celdeg,
                                                                                  element_location::IN_POSITIVE_SIDE,
                                                                                  test_case.neumann_jump,
                                                                                  parametric_interface);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS_ref_pts_cont
                (msh, cl, hdi, parametric_interface, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_ref_pts_cont(const cuthho_mesh <T, ET> &msh, const T eta_, const T gamma_,
                                                           testType &test_case, bool sym) {
    return Sym_gradrec_stokes_interface_method_ref_pts_cont<T, ET, testType>(eta_, gamma_, sym);
}


// ------------------------ METHOD UNSTEADY STOKES -------------------

template<typename T, size_t ET, typename testType>
class unsteady_stokes_interface_method_ref_pts_cont {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;
    T dt;
    T rho;

    unsteady_stokes_interface_method_ref_pts_cont(bool sym, T dt, T rho)
            : sym_grad(sym), dt(dt), rho(rho) {
    }

    virtual std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
    }

public:
    std::pair <Mat, Vect>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info hdi, const testType &test_case) {
        T kappa;
        std::cout << "dt = " << dt << " and rho = " << rho << std::endl;
        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;

        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = dt * kappa * (gr2 + stab); // ----> ADDED dt
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = dt * make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero(loc_size, loc_size);
        Vect rhs = Vect::Zero(loc_size);

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair <Mat, Vect>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType &test_case, const hho_degree_info hdi) {
        if (location(msh, cl) != element_location::ON_INTERFACE)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};

template<typename T, size_t ET, typename testType>
class Sym_gradrec_unsteady_stokes_interface_method_ref_pts_cont :
        public unsteady_stokes_interface_method_ref_pts_cont<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;
    T dt, rho;

    Sym_gradrec_unsteady_stokes_interface_method_ref_pts_cont(T eta_, T gamma_, bool sym, T dt, T rho)
            : unsteady_stokes_interface_method_ref_pts_cont<T, ET, testType>(sym, dt, rho), eta(eta_), gamma_0(gamma_),
              dt(dt), rho(rho) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {

        std::cout << "CUT : dt = " << dt << " and rho = " << rho << std::endl;
        auto parms = test_case.parms;
        auto parametric_interface = test_case.parametric_interface;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                    (msh, cl, parametric_interface, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                    (msh, cl, parametric_interface, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
// ANCORA DA MODIFICAREEEEEE
            std::cout << "STILL TO BE MODIFIED WITH parametric curve" << std::endl;
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = dt * (stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p); // ---- ADDED dt

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization_ref_pts_cont(msh, cl, hdi, parametric_interface);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += dt * make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                      element_location::IN_NEGATIVE_SIDE); // -- ADDED dt
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5 *
                       make_vector_flux_jump_reference_pts_cont(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                                test_case.neumann_jump, parametric_interface);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump_reference_pts_cont(msh, cl, celdeg,
                                                                                  element_location::IN_POSITIVE_SIDE,
                                                                                  test_case.neumann_jump,
                                                                                  parametric_interface);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS_ref_pts_cont
                (msh, cl, hdi, parametric_interface, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};


template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_unsteady_stokes_interface_method_ref_pts_cont(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                                    const T gamma_, testType &test_case, bool sym, T dt,
                                                                    T rho) {
    return Sym_gradrec_unsteady_stokes_interface_method_ref_pts_cont<T, ET, testType>(eta_, gamma_, sym, dt, rho);
}


template<typename T, size_t ET, typename testType>
class stokes_interface_method_old {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method_old(bool sym)
            : sym_grad(sym) {
    }

    virtual std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi) {
    }

public:
    std::pair <Mat, Vect>
    make_contrib_uncut(const Mesh &msh, const typename Mesh::cell_type &cl,
                       const hho_degree_info hdi, const testType test_case) {
        T kappa;
        if (location(msh, cl) == element_location::IN_NEGATIVE_SIDE)
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if (sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero(loc_size, loc_size);
        Vect rhs = Vect::Zero(loc_size);

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair <Mat, Vect>
    make_contrib(const Mesh &msh, const typename Mesh::cell_type &cl,
                 const testType test_case, const hho_degree_info hdi) {
        if (location(msh, cl) != element_location::ON_INTERFACE)
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};

template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_old :
        public stokes_interface_method_old<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_old(T eta_, T gamma_, bool sym)
            : stokes_interface_method_old<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;

///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);

        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;

        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
        f.head(cbs) += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                   test_case.neumann_jump);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
        f.block(cbs, 0, cbs, 1)
                += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                               test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_old(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                  const T gamma_, testType test_case, bool sym) {
    return Sym_gradrec_stokes_interface_method_old<T, ET, testType>(eta_, gamma_, sym);
}




////////////////////////  GRADREC INTERFACE METHOD BIS (same with kappa_1 > kappa_2)
// the roles of kappa_1 and kappa_2 are reversed

template<typename T, size_t ET, typename testType>
class gradrec_stokes_interface_method_bis :
        public stokes_interface_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    gradrec_stokes_interface_method_bis(T eta_, T gamma_, bool sym)
            : stokes_interface_method<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;

///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);

        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;

        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        T coeff_stab = gamma_0 / parms.kappa_1;
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= coeff_stab * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);


////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
        f.block(0, 0, cbs, 1)
                += make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                         test_case.neumann_jump);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);

        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= coeff_stab * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= coeff_stab * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_gradrec_stokes_interface_method_bis(const cuthho_mesh <T, ET> &msh, const T eta_,
                                              const T gamma_, testType &test_case, bool sym) {
    if (test_case.parms.kappa_1 < test_case.parms.kappa_2)
        std::cout << "WARNING : kappa_1 < kappa_2 used with method_bis" << std::endl;

    return gradrec_stokes_interface_method_bis<T, ET, testType>(eta_, gamma_, sym);
}


template<typename T, size_t ET, typename testType>
class gradrec_stokes_interface_method_bis_old :
        public stokes_interface_method_old<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    gradrec_stokes_interface_method_bis_old(T eta_, T gamma_, bool sym)
            : stokes_interface_method_old<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;

///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);

        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;

        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.0);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 1.0);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        T coeff_stab = gamma_0 / parms.kappa_1;
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= coeff_stab * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);


////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
        f.block(0, 0, cbs, 1)
                += make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                         test_case.neumann_jump);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);

        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= coeff_stab * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= coeff_stab * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_gradrec_stokes_interface_method_bis_old(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                  const T gamma_, testType test_case, bool sym) {
    if (test_case.parms.kappa_1 < test_case.parms.kappa_2)
        std::cout << "WARNING : kappa_1 < kappa_2 used with method_bis" << std::endl;

    return gradrec_stokes_interface_method_bis_old<T, ET, testType>(eta_, gamma_, sym);
}


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_analytic :
        public stokes_interface_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;


    Sym_gradrec_stokes_interface_method_analytic(Sym_gradrec_stokes_interface_method_analytic &other)
            : stokes_interface_method<T, ET, testType>(other) {
        eta = other.eta;
        gamma_0 = other.gamma_0;
    }

    Sym_gradrec_stokes_interface_method_analytic(const Sym_gradrec_stokes_interface_method_analytic &other)
            : stokes_interface_method<T, ET, testType>(other) {
        eta = other.eta;
        gamma_0 = other.gamma_0;
    }


    Sym_gradrec_stokes_interface_method_analytic(T eta_, T gamma_, bool sym)
            : stokes_interface_method<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType &test_case, const hho_degree_info &hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
// ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

// 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
/// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
/// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);
// Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
// This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR : Penalty divided:
// (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
// (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= gamma_0 * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs) -= gamma_0 * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs) -= gamma_0 * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= gamma_0 * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
        f.head(cbs) += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_NEGATIVE_SIDE,
                                                   test_case.neumann_jump);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
        f.block(cbs, 0, cbs, 1)
                += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                               test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= gamma_0 * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= gamma_0 * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};


template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_analytic(const cuthho_mesh <T, ET> &msh, const T eta_,
                                                       const T gamma_, testType &test_case, bool sym) {
    return Sym_gradrec_stokes_interface_method_analytic<T, ET, testType>(eta_, gamma_, sym);
}


////////////////////////  GRADREC INTERFACE METHOD (method used in the article)


template<typename T, size_t ET, typename testType>
class gradrec_stokes_interface_method :
        public stokes_interface_method<T, ET, testType> {
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    gradrec_stokes_interface_method(T eta_, T gamma_, bool sym)
            : stokes_interface_method<T, ET, testType>(sym), eta(eta_), gamma_0(gamma_) {
    }

    std::pair <Mat, Vect>
    make_contrib_cut(const Mesh &msh, const typename Mesh::cell_type &cl,
                     const testType test_case, const hho_degree_info hdi) {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;

///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
        auto pbs = cell_basis<Mesh, T>::size(pdeg);

// GR
        Mat gr2_n, gr2_p;
        if (this->sym_grad) {
            gr2_n = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 1.0).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.0).second;
        } else {
            gr2_n = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 1.0).second;
            gr2_p = make_hho_gradrec_matrix_interface
                    (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.0).second;
        }

// stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi, parms);

        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0, 0, cbs, cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_1 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_1 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_1 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_1 * penalty;

        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

// DR
        auto dr_n = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 1.0);
        auto dr_p = make_hho_divergence_reconstruction_interface
                (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.0);


        Mat lhs = Mat::Zero(lc.rows() + 2 * pbs, lc.rows() + 2 * pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


// stokes stabilization terms
        T coeff_stab = gamma_0 / parms.kappa_2;
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2 * cbs, 2 * cbs) -= coeff_stab * stokes_stab.block(0, 0, 2 * cbs, 2 * cbs);
        lhs.block(0, lc.rows(), 2 * cbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(0, 2 * cbs, 2 * cbs, 2 * pbs);
        lhs.block(lc.rows(), 0, 2 * pbs, 2 * cbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 0, 2 * pbs, 2 * cbs);
        lhs.block(lc.rows(), lc.rows(), 2 * pbs, 2 * pbs)
                -= coeff_stab * stokes_stab.block(2 * cbs, 2 * cbs, 2 * pbs, 2 * pbs);



////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
// neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);

// pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
        f.block(cbs, 0, cbs, 1)
                += make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                         test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2 * pbs);
        rhs.head(lc.rows()) = f;

// stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
                (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2 * cbs) -= coeff_stab * stab_rhs.head(2 * cbs);
        rhs.tail(2 * pbs) -= coeff_stab * stab_rhs.tail(2 * pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_gradrec_stokes_interface_method(const cuthho_mesh <T, ET> &msh, const T eta_,
                                          const T gamma_, testType test_case, bool sym) {
    if (test_case.parms.kappa_1 > test_case.parms.kappa_2)
        std::cout << "WARNING : kappa_1 < kappa_2 used with main method" << std::endl;
    return gradrec_stokes_interface_method<T, ET, testType>(eta_, gamma_, sym);
}



///////////////////////////////////////

// OLd (taken from unsteady case to debug) -> it can be deleted afterwards
template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity, typename T, typename Velocity_HHO, typename Finite_Element>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_prova_time(const Mesh &msh, size_t degree, meth method, testType test_case,
                                         Fonction &level_set_function, Velocity &velocity, bool sym_grad, T dt,
                                         Velocity_HHO &vel_old, const Finite_Element &fe_data) {
    using RealType = typename Mesh::coordinate_type;
    using Mat = Matrix<RealType, Dynamic, Dynamic>;
//auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface;
    std::cout << "Interface isovalue = " << iso_val_interface << std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
//timecounter tc_bis2 ;

    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
//std::cout<<yellow<<bold<<"assembler_sc.set_dir_func ---> INTO the CELLS' LOOP." <<reset<<std::endl;


    test_case.test_case_mesh_assignment(msh);


    for (auto &cl: msh.cells) {
// ADD BY STE
//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//timecounter tc_bis ;
//tc_bis.tic();
//level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
//auto prm = params<RealType>();
//prm.kappa_1 = 1.0;
//prm.kappa_2 = 1.0;
//auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        test_case.test_case_cell_assignment(cl);
        test_case.refresh_lambdas(level_set_function, parms, sym_grad);

//std::cout<<"test_case.cl = "<<offset(msh,test_case.cl)<<std::endl;
//std::cout<<"test_case.i = "<<test_case.i <<std::endl;
// std::cout<<"-------> TIME STOKES 0 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
//auto rhs_fun = test_case_cell.rhs_fun;
//auto sol_vel = test_case_cell.sol_vel;
//auto sol_p = test_case_cell.sol_p;
//auto vel_grad = test_case_cell.vel_grad;
///---> QUESTO NO auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!
//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 1 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

// ADD TIME CONTRIBUTION
        Mat mass_matrix;
        Mat mass_matrix_p, mass_matrix_n;

        Mat term_rhs_R;
        Mat term_rhs_R_p, term_rhs_R_n;

        lc *= dt;
        f *= dt;


//std::cout<<"ATTENZIONE ALLE AGGLOMERATED CELLS!! QUESTO VA SOLO SENZA DIREI"<<std::endl;
//vel_old.col(0) = velocity.sol_HHO.first.col(offset(msh,cl)) ;
//vel_old.col(1) = velocity.sol_HHO.second.col(offset(msh,cl)) ;

        if (location(msh, cl) != element_location::ON_INTERFACE) {
            mass_matrix = make_mass_matrix(msh, cl, hdi);
            size_t m_size = mass_matrix.rows();
            lc.block(0, 0, m_size, m_size) += mass_matrix;


            term_rhs_R = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old);

            f.block(0, 0, m_size, 1) += term_rhs_R; //mass_matrix*vel_cell_old;

// DEVO MODIFICARE ANCHE TERMINE NOTO f!!!! ADD TERM M*u^n
        } else { // on interface
            mass_matrix_n = make_mass_matrix(msh, cl, hdi, element_location::IN_NEGATIVE_SIDE);
            mass_matrix_p = make_mass_matrix(msh, cl, hdi, element_location::IN_POSITIVE_SIDE);
            size_t m_size = mass_matrix_n.rows();
            lc.block(0, 0, m_size, m_size) += mass_matrix_n;

            lc.block(m_size, m_size, m_size, m_size) += mass_matrix_p;

            term_rhs_R_n = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old, element_location::IN_NEGATIVE_SIDE);
//auto vel_cell_old_n = vel_old.vel_global_n.col(offset(msh,cl)) ;
            f.block(0, 0, m_size, 1) += term_rhs_R_n;

            term_rhs_R_p = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old, element_location::IN_POSITIVE_SIDE);
//auto vel_cell_old_p = vel_old.vel_global_p.col(offset(msh,cl)) ;
            f.block(m_size, 0, m_size, 1) += term_rhs_R_p;
// DEVO MODIFICARE ANCHE TERMINE NOTO f!!!! ADD TERM M*u^n
        }


//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 2 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 3 , time = "<<tc_bis<<std::endl;
    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;

    std::cout << "Inizio Post-processing + saving of velocity." << std::endl;
    size_t i_global = 0; // ADD BY STE


    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//auto pbs = pb.size();


// ADD BY STE
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

//auto prm = params<RealType>();
//prm.kappa_1 = 1.0;
//prm.kappa_2 = 1.0;
//auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        test_case.test_case_cell_assignment(cl);
        test_case.refresh_lambdas(level_set_function, parms, sym_grad);
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
//auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);
//            std::cout<<"OFFSTE cl = "<<offset(msh,cl)<<std::endl;
            vel_old.vel_global_n.col(offset(msh, cl)) = vel_cell_dofs_n;
            vel_old.vel_global_p.col(offset(msh, cl)) = vel_cell_dofs_p;

// Uploading velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    std::cout << "offset_old = " << offset_old << std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
//std::cout<<"phi_HHO.transpose() "<<'\n'<<phi_HHO.transpose() <<std::endl;
//std::cout<<"vel_cell_dofs_p"<<'\n'<<vel_cell_dofs_p<<std::endl;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);
            vel_old.vel_global.col(offset(msh, cl)) = vel_cell_dofs;
//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity_p"<<'\n'<<vel_old.vel_global_p<<std::endl;
//std::cout<<"velocity_n"<<'\n'<<vel_old.vel_global_n<<std::endl;
//std::cout<<"velocity"<<'\n'<<vel_old.vel_global<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

// OLd (taken from unsteady case to debug) -> it can be deleted afterwards
template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity, typename T, typename Velocity_HHO>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_prova(const Mesh &msh, size_t degree, meth method, testType test_case,
                                    Fonction &level_set_function, Velocity &velocity, bool sym_grad, T time,
                                    Velocity_HHO &vel_old) {
    using RealType = typename Mesh::coordinate_type;

//auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface;
//std::cout<<"Interface isovalue = "<<iso_val_interface<<std::endl;
    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;
//std::cout<<"WARNING: check integration points: it seems there is a repetition in agglomerated cells."<<std::endl; // FALSE, the weights are null.
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
//timecounter tc_bis2 ;

    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
//std::cout<<"assembler_sc.set_dir_func ---> INTO the CELLS' LOOP." <<std::endl;


    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {
// ADD BY STE
//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//timecounter tc_bis ;
//tc_bis.tic();
//level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
//auto prm = params<RealType>();
//prm.kappa_1 = 1.0;
//prm.kappa_2 = 1.0;
//auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        test_case.test_case_cell_assignment(cl);
        test_case.refresh_lambdas(level_set_function, parms, sym_grad);

//std::cout<<"test_case.cl = "<<offset(msh,test_case.cl)<<std::endl;
//std::cout<<"test_case.i = "<<test_case.i <<std::endl;
// std::cout<<"-------> TIME STOKES 0 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
//auto rhs_fun = test_case_cell.rhs_fun;
//auto sol_vel = test_case_cell.sol_vel;
//auto sol_p = test_case_cell.sol_p;
//auto vel_grad = test_case_cell.vel_grad;
///---> QUESTO NO auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!
//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 1 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 2 , time = "<<tc_bis<<std::endl;
//tc_bis.tic();
        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

//tc_bis.toc();
//std::cout<<"-------> TIME STOKES 3 , time = "<<tc_bis<<std::endl;
    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > (filename_pressure);

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;


    size_t i_global = 0; // ADD BY STE
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//auto pbs = pb.size();


// ADD BY STE
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

//auto prm = params<RealType>();
//prm.kappa_1 = 1.0;
//prm.kappa_2 = 1.0;
//auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        test_case.test_case_cell_assignment(cl);
        test_case.refresh_lambdas(level_set_function, parms, sym_grad);
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
//auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

            vel_old.vel_global_n.col(offset(msh, cl)) = vel_cell_dofs_n;
            vel_old.vel_global_p.col(offset(msh, cl)) = vel_cell_dofs_p;

// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
            if (1) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);


            vel_old.vel_global.col(offset(msh, cl)) = vel_cell_dofs;
//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (false) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity, typename RealType>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_analytic(const Mesh &msh, size_t degree, meth method, testType test_case,
                                       Fonction &level_set_function, Velocity &velocity, bool sym_grad,
                                       RealType radius) {
//using RealType = typename Mesh::coordinate_type;

//auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface;
    std::cout << "Interface isovalue = " << iso_val_interface << std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    timecounter tc_bis2;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout << "-------> TIME assembler , time = " << tc_bis2 << std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout << "-------> TIME assembler_sc , time = " << tc_bis2 << std::endl;
    for (auto &cl: msh.cells) {
// ADD BY STE
        timecounter tc_bis;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_analytic(msh, level_set_function, prm, sym_grad, radius);

//auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);
        tc_bis.toc();
        std::cout << "-------> TIME STOKES PARTE 0 , time = " << tc_bis << std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout << "-------> TIME STOKES PARTE 1 , time = " << tc_bis << std::endl;
        tc_bis.tic();
        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
        tc_bis.toc();
        std::cout << "-------> TIME STOKES PARTE 2 , time = " << tc_bis << std::endl;
    }


    tc_bis2.tic();
    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout << "-------> TIME STOKES PARTE 3 , time = " << tc_bis2 << std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;

    std::cout << "sono qua 0.0" << std::endl;
    size_t i_global = 0; // ADD BY STE
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


// ADD BY STE
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_analytic(msh, level_set_function, prm, sym_grad, radius);
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    std::cout << "offset_old = " << offset_old << std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout << "Local error pressure (NEGATIVE CUT) = " << qp.second * p_diff * p_diff << std::endl;
                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout << "Local error pressure (POSITIVE CUT) = " << qp.second * p_diff * p_diff << std::endl;
                p_gp->add_data(qp.first, p_num);
            }
        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    std::cout << "offset_old = " << offset_old << std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout << "Local error pressure (UNCUT) = " << qp.second * p_diff * p_diff << std::endl;
                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity(const Mesh &msh, size_t degree, meth method, testType test_case,
                              Fonction &level_set_function, Velocity &velocity, bool sym_grad) {
    using RealType = typename Mesh::coordinate_type;

//auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface;
    std::cout << "Interface isovalue = " << iso_val_interface << std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    timecounter tc_bis2;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout << "-------> TIME assembler , time = " << tc_bis2 << std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout << "-------> TIME assembler_sc , time = " << tc_bis2 << std::endl;
    for (auto &cl: msh.cells) {
// ADD BY STE
        timecounter tc_bis;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        tc_bis.toc();
        std::cout << "-------> TIME STOKES 0 , time = " << tc_bis << std::endl;
        tc_bis.tic();
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
//auto rhs_fun = test_case_cell.rhs_fun;
//auto sol_vel = test_case_cell.sol_vel;
//auto sol_p = test_case_cell.sol_p;
//auto vel_grad = test_case_cell.vel_grad;
///---> QUESTO NO auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);
        tc_bis.toc();
        std::cout << "-------> TIME STOKES 1 , time = " << tc_bis << std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout << "-------> TIME STOKES 2 , time = " << tc_bis << std::endl;
        tc_bis.tic();
        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

        tc_bis.toc();
        std::cout << "-------> TIME STOKES 3 , time = " << tc_bis << std::endl;
    }
    tc_bis2.tic();

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout << "------------------> TIME STOKES 4 , time = " << tc_bis2 << std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;

    std::cout << "sono qua 0.0" << std::endl;
    size_t i_global = 0; // ADD BY STE
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


// ADD BY STE
        level_set_function.cell_assignment(cl);
//auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
//auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
//This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    std::cout << "offset_old = " << offset_old << std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    std::cout << "offset_old = " << offset_old << std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p(qp.first) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_prova(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                    Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;

    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;

    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
        test_case.test_case_cell_assignment(cl);
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
//    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;


    size_t i_global = 0;
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//auto pbs = pb.size();


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl);

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
//assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
            if (1) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity, typename Velocity_HHO>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_initial_time(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                           Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time,
                                           Velocity_HHO &vel_old) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;

    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;

    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT_norm.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;


    size_t i_global = 0;
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//auto pbs = pb.size();


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl);

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA??


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

            vel_old.vel_global_n.col(offset(msh, cl)) = vel_cell_dofs_n;
            vel_old.vel_global_p.col(offset(msh, cl)) = vel_cell_dofs_p;


// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                auto p_prova = test_case.sol_p(qp.first);
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;
                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;

                p_gp->add_data(qp.first, p_num);
            }
            if (1) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);
            vel_old.vel_global.col(offset(msh, cl)) = vel_cell_dofs;

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.add_object(uT_l2_gp);

    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


////////////////////////  UNSTEADY INTERFACE METHOD ///////////////////////////////

template<typename Mesh>
Matrix<typename Mesh::coordinate_type, Dynamic, Dynamic>
make_mass_matrix
        (const Mesh &msh, const typename Mesh::cell_type &cl, const hho_degree_info &di) {
    using T = typename Mesh::coordinate_type;
    typedef Matrix <T, Dynamic, Dynamic> matrix_type;
//typedef Matrix<T, Dynamic, 1>       vector_type;

    const auto celdeg = di.cell_degree();
//const auto facdeg  = di.face_degree();
//const auto graddeg = di.grad_degree();

    vector_cell_basis <Mesh, T> cb(msh, cl, celdeg);
//sym_matrix_cell_basis<Mesh,T>     gb(msh, cl, graddeg);

    auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);
//auto fbs = vector_face_basis<Mesh,T>::size(facdeg);
//auto gbs = sym_matrix_cell_basis<Mesh,T>::size(graddeg);

//const auto num_faces = faces(msh, cl).size();
    matrix_type mass_mat = matrix_type::Zero(cbs, cbs);
//matrix_type         gr_lhs = matrix_type::Zero(gbs, gbs);
//matrix_type         gr_rhs = matrix_type::Zero(gbs, cbs + num_faces * fbs);

    if (celdeg > 0) {
        const auto qps = integrate(msh, cl, 2 * celdeg); // - 1 + facdeg); //HO ANCHE ADD 2*
        for (auto &qp: qps) {
//const auto c_dphi = cb.eval_gradients(qp.first);
//const auto g_phi  = gb.eval_basis(qp.first);
            const auto c_phi = cb.eval_basis(qp.first);
            mass_mat.block(0, 0, cbs, cbs) += qp.second * c_phi * c_phi.transpose();
//gr_lhs.block(0, 0, gbs, gbs) += qp.second * inner_product(g_phi, g_phi);
// we use here the symmetry of the basis gb
//gr_rhs.block(0, 0, gbs, cbs) += qp.second * inner_product(g_phi, c_dphi);
        }
    }


    return mass_mat;
}

template<typename T, size_t ET>
Matrix<typename cuthho_mesh<T, ET>::coordinate_type, Dynamic, Dynamic>
make_mass_matrix
        (const cuthho_mesh <T, ET> &msh, const typename cuthho_mesh<T, ET>::cell_type &cl,
         const hho_degree_info &di, element_location where) {
    if (!is_cut(msh, cl))
        return make_mass_matrix(msh, cl, di);

    typedef Matrix <T, Dynamic, Dynamic> matrix_type;
//typedef Matrix<T, Dynamic, 1>       vector_type;

    const auto celdeg = di.cell_degree();

    vector_cell_basis <cuthho_mesh<T, ET>, T> cb(msh, cl, celdeg);


    auto cbs = vector_cell_basis < cuthho_mesh < T, ET>, T > ::size(celdeg);

    matrix_type mass_mat = matrix_type::Zero(cbs, cbs);


    const auto qps = integrate(msh, cl, 2 * celdeg, where);
    for (auto &qp: qps) {
        const auto c_phi = cb.eval_basis(qp.first);


        mass_mat.block(0, 0, cbs, cbs) += qp.second * c_phi * c_phi.transpose();
    }


    return mass_mat;
}


template<typename Mesh, typename Finite_Element, typename Velocity_HHO>
Matrix<typename Mesh::coordinate_type, Dynamic, 1>
make_term_rhs_time
        (const Mesh &msh, const typename Mesh::cell_type &cl, const hho_degree_info &di, const Finite_Element &fe_data,
         Velocity_HHO &vel_old) {
// msh = msh t^{N+1}
// msh_n = msh t^N
// msh_orig = msh t^0

    using T = typename Mesh::coordinate_type;
    typedef Matrix <T, Dynamic, Dynamic> matrix_type;

    typedef Matrix<T, Dynamic, 1> vector_type;

    const auto celdeg = di.cell_degree();
    auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);


    vector_type ret = matrix_type::Zero(cbs, 1);


    Mesh msh_orig = fe_data.msh;
    Mesh msh_n = fe_data.msh_last;
    auto cl_n_offsets = fe_data.mapping_S(cl);


//    std::cout<<"k^{n+1} = "<<offset(msh,cl)<<" -> S(k^{n+1}): "<<std::endl;
//    for(auto& i : cl_n_offsets)
//        std::cout<<" ( K^n = "<<i.first <<" , K^0 = "<<i.second<<" ) --";
//    std::cout<<std::endl;


//auto cl_n_prova = fe_data.mapping_S_prova( cl ) ;
//std::cout<<"cl_n_prova = "<<std::endl;
//for(auto& i : cl_n_prova)
//    std::cout<<" ("<<i.first <<" , "<<i.second<<" ) --";
//std::cout<<std::endl;


    for (auto &i: cl_n_offsets) {
        matrix_type mass_mat = matrix_type::Zero(cbs, cbs);

        auto i_cl_n = i.first;
        auto vel_cell_old = vel_old.vel_global.col(i_cl_n);
        auto cl_n = msh_n.cells[i_cl_n];
        vector_cell_basis <Mesh, T> cb_n(msh, cl_n, celdeg);
        vector_cell_basis <Mesh, T> cb(msh, cl, celdeg);

//for(auto& i_integration: cl_n.user_data.offset_subcells )
//{
        auto cl_integration = msh_orig.cells[i.second]; // [i_integration]


        if (celdeg > 0) {
//std::cout<<"Potrebbe mancare un ciclo di integrazione qua sulle sottocelle! capire se ci va"<<std::endl;
            const auto qps = integrate(msh_orig, cl_integration, 2 * celdeg);
//It was celdeg-1 + facdeg,  I ADDED 2*
            for (auto &qp: qps) {
//const auto c_dphi = cb.eval_gradients(qp.first);
//const auto g_phi  = gb.eval_basis(qp.first);
                const auto c_phi = cb.eval_basis(qp.first);
                const auto c_phiR = cb_n.eval_basis(qp.first);
                mass_mat.block(0, 0, cbs, cbs) += qp.second * c_phi * c_phiR.transpose();
//gr_lhs.block(0, 0, gbs, gbs) += qp.second * inner_product(g_phi, g_phi);
// we use here the symmetry of the basis gb
//gr_rhs.block(0, 0, gbs, cbs) += qp.second * inner_product(g_phi, c_dphi);
            }
        }

//}

        ret += mass_mat * vel_cell_old;


    }


    return ret;
}

template<typename Mesh, typename Finite_Element, typename Velocity_HHO>
Matrix<typename Mesh::coordinate_type, Dynamic, 1>
make_term_rhs_time
        (const Mesh &msh, const typename Mesh::cell_type &cl, const hho_degree_info &di, const Finite_Element &fe_data,
         Velocity_HHO &vel_old, element_location where) {
// msh = msh t^{N+1}
// msh_n = msh t^N
// msh_orig = msh t^0
    if (!is_cut(msh, cl))
        return make_term_rhs_time(msh, cl, di, fe_data, vel_old);


    using T = typename Mesh::coordinate_type;
    typedef Matrix <T, Dynamic, Dynamic> matrix_type;

    typedef Matrix<T, Dynamic, 1> vector_type;

    const auto celdeg = di.cell_degree();
    auto cbs = vector_cell_basis<Mesh, T>::size(celdeg);

    matrix_type mass_mat = matrix_type::Zero(cbs, cbs);
    vector_type ret = matrix_type::Zero(cbs, 1);
    vector_type vel_cell_old = matrix_type::Zero(cbs, 1);

    Mesh msh_orig = fe_data.msh;
    Mesh msh_n = fe_data.msh_last;
    auto cl_n_offsets = fe_data.mapping_S(cl);

//    std::cout<<"k^{n+1} = "<<offset(msh,cl)<<" -> S(k^{n+1}): "<<std::endl;
//    for(auto& i : cl_n_offsets)
//        std::cout<<" ( K^n = "<<i.first <<" , K^0 = "<<i.second<<" ) --";
//    std::cout<<std::endl;

//auto cl_n_prova = fe_data.mapping_S_prova( cl ) ;
//std::cout<<"cl_n_prova = "<<std::endl;
//for(auto& i : cl_n_prova)
//    std::cout<<" ("<<i.first <<" , "<<i.second<<" ) --";
//std::cout<<std::endl;


    for (auto &i: cl_n_offsets) {
        auto i_cl_n = i.first;

        if (where == element_location::IN_NEGATIVE_SIDE)
            vel_cell_old = vel_old.vel_global_n.col(i_cl_n);
        else
            vel_cell_old = vel_old.vel_global_p.col(i_cl_n);

        auto cl_n = msh_n.cells[i_cl_n];
        vector_cell_basis <Mesh, T> cb_n(msh, cl_n, celdeg);

        auto cl_integration = msh_orig.cells[i.second];

        vector_cell_basis <Mesh, T> cb(msh, cl, celdeg);

        if (celdeg > 0) {
//const auto qps = integrate( msh_orig , cl_integration , 2*celdeg ) ;
            const auto qps = integrate(msh_orig, cl_integration, 2 * celdeg, where);
//It was celdeg-1 + facdeg,  I ADDED 2*
            for (auto &qp: qps) {
//const auto c_dphi = cb.eval_gradients(qp.first);
//const auto g_phi  = gb.eval_basis(qp.first);
                const auto c_phi = cb.eval_basis(qp.first);
                const auto c_phiR = cb_n.eval_basis(qp.first);
                mass_mat.block(0, 0, cbs, cbs) += qp.second * c_phi * c_phiR.transpose();
//gr_lhs.block(0, 0, gbs, gbs) += qp.second * inner_product(g_phi, g_phi);
// we use here the symmetry of the basis gb
//gr_rhs.block(0, 0, gbs, cbs) += qp.second * inner_product(g_phi, c_dphi);
            }


        }
        ret += mass_mat * vel_cell_old;


    }


    return ret;
}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity, typename Velocity_HHO, typename T, typename Finite_Element>
stokes_test_info<typename Mesh::coordinate_type>
run_unsteady_cuthho_interface_velocity(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                       Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time,
                                       T dt, Velocity_HHO &vel_old, const Finite_Element &fe_data, T rho) {
    using RealType = typename Mesh::coordinate_type;
    using Mat = Matrix<RealType, Dynamic, Dynamic>;
    auto iso_val_interface = level_set_function.iso_val_interface;

    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;

    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

// ADD TIME CONTRIBUTION
        Mat mass_matrix;
        Mat mass_matrix_p, mass_matrix_n;

        Mat term_rhs_R;
        Mat term_rhs_R_p, term_rhs_R_n;

//         lc *= dt ;
//         f *= dt ;
//        std::cout<<"lc = "<<'\n'<<lc<<std::endl;
//        std::cout<<"f = "<<'\n'<<lc<<std::endl;
        if (location(msh, cl) != element_location::ON_INTERFACE) {
            mass_matrix = make_mass_matrix(msh, cl, hdi);
            size_t m_size = mass_matrix.rows();
            lc.block(0, 0, m_size, m_size) += rho * mass_matrix / dt;
//            std::cout<<"m_size = "<<'\n'<<m_size<<std::endl;
//            std::cout<<"mass_matrix = "<<'\n'<<mass_matrix<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
//            std::cout<<"f = "<<'\n'<<lc<<std::endl;

//            if(time == 9 )
//                std::cout<<"CHECK S!!!!"<<std::endl;

            term_rhs_R = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old);
//            std::cout<<"term_rhs_R = "<<'\n'<<term_rhs_R<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
            f.block(0, 0, m_size, 1) += rho * term_rhs_R / dt; //mass_matrix^{n+1}_n*vel_cell_old;

        } else { // on interface
            mass_matrix_n = make_mass_matrix(msh, cl, hdi, element_location::IN_NEGATIVE_SIDE);
            mass_matrix_p = make_mass_matrix(msh, cl, hdi, element_location::IN_POSITIVE_SIDE);
            size_t m_size = mass_matrix_n.rows();
            lc.block(0, 0, m_size, m_size) += rho * mass_matrix_n / dt;

            lc.block(m_size, m_size, m_size, m_size) += rho * mass_matrix_p / dt;
//            std::cout<<"mass_matrix_n = "<<'\n'<<mass_matrix_n<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
//            std::cout<<"mass_matrix_p = "<<'\n'<<mass_matrix_p<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
            term_rhs_R_n = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old, element_location::IN_NEGATIVE_SIDE);
//auto vel_cell_old_n = vel_old.vel_global_n.col(offset(msh,cl)) ;
            f.block(0, 0, m_size, 1) += rho * term_rhs_R_n / dt;

            term_rhs_R_p = make_term_rhs_time(msh, cl, hdi, fe_data, vel_old, element_location::IN_POSITIVE_SIDE);
//auto vel_cell_old_p = vel_old.vel_global_p.col(offset(msh,cl)) ;
//            std::cout<<"term_rhs_R_n = "<<'\n'<<term_rhs_R_n<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
//            std::cout<<"term_rhs_R_p = "<<'\n'<<term_rhs_R_p<<std::endl;
//            std::cout<<'\n'<<'\n'<<std::endl;
            f.block(m_size, 0, m_size, 1) += rho * term_rhs_R_p / dt;

        }

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        std::cout << "----> CHECK: maybe change preconditioner !!!" << std::endl;
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;

    vel_old.set_agglo_mesh(msh); // Update size of u_HHO with mesh_{n+1} and delete old u_HHO

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT_norm.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;


    size_t i_global = 0;
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//auto pbs = pb.size();


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl);

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA??


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);
//            std::cout<<"OFFSTE cl = "<<offset(msh,cl)<<std::endl;
            vel_old.vel_global_n.col(offset(msh, cl)) = vel_cell_dofs_n;
            vel_old.vel_global_p.col(offset(msh, cl)) = vel_cell_dofs_p;


// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
                auto p_prova = test_case.sol_p(qp.first);
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;
                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;

                p_gp->add_data(qp.first, p_num);
            }
            if (1) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);
            vel_old.vel_global.col(offset(msh, cl)) = vel_cell_dofs;

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

                p_gp->add_data(qp.first, p_num);
            }
        }

        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;
//    std::cout<<"velocity_p"<<'\n'<<vel_old.vel_global_p<<std::endl;
//    std::cout<<"velocity_n"<<'\n'<<vel_old.vel_global_n<<std::endl;
//    std::cout<<"velocity"<<'\n'<<vel_old.vel_global<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.add_object(uT_l2_gp);

    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_complete(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                       Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time,
                                       int time_gap, std::string &path) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;


    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
        test_case.test_case_cell_assignment(cl);
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        std::cout << "First step: analyze pattern... " << std::endl;
        solver.analyzePattern(assembler_sc.LHS);
        std::cout << "Pattern ok. Second step: assembling... " << std::endl;
        solver.factorize(assembler_sc.LHS);
        std::cout << "Assembling ok. Third step: solving... " << std::endl;
        sol = solver.solve(assembler_sc.RHS);
        std::cout << "..problem solved. " << std::endl;
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
//        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);


        ConjugateGradient < SparseMatrix < RealType > , Lower | Upper > cg;
        cg.compute(assembler_sc.LHS);
        sol = cg.solve(assembler_sc.RHS);
        std::cout << "#iterations:     " << cg.iterations() << std::endl;
        std::cout << "estimated error: " << cg.error() << std::endl;
// conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);

    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;
    std::string filename_interface_uT = path + "interface_uT_" + std::to_string(time) + ".3D";
    std::ofstream interface_file(filename_interface_uT, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > >
                  (path + "interface_uT1_" + std::to_string(time) + ".dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > >
                  (path + "interface_uT2_" + std::to_string(time) + ".dat");
//    auto uT_gp  = std::make_shared< gnuplot_output_object_vec<RealType> >("interface_uT.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > >
                (path + "interface_p_" + std::to_string(time) + ".dat");
    auto p1_gp = std::make_shared < gnuplot_output_object < RealType > >
                 (path + "interface_pIN_" + std::to_string(time) + ".dat");
    auto p2_gp = std::make_shared < gnuplot_output_object < RealType > >
                 (path + "interface_pOUT_" + std::to_string(time) + ".dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    std::string filename_gammaH = path + "gamma_H_" + std::to_string(time) + ".dat";
    auto test_gammaH = std::make_shared < gnuplot_output_object < double > > (filename_gammaH);

    std::string filename_press_jump = path + "pressure_jump_" + std::to_string(time) + ".dat";
    auto test_press_jump = std::make_shared < gnuplot_output_object < double > > (filename_press_jump);

    std::string filename_grad_vel_jump = path + "grad_vel_jump_" + std::to_string(time) + ".dat";
    auto test_grad_vel_jump = std::make_shared < gnuplot_output_object < double > > (filename_grad_vel_jump);


    std::string filename_grad_vel_t_n = path + "grad_vel_t_n_" + std::to_string(time) + ".dat";
    auto test_grad_vel_t_n = std::make_shared < gnuplot_output_object < double > > (filename_grad_vel_t_n);

    std::string filename_veln_n = path + "vel_un_n_" + std::to_string(time) + ".dat";
    auto test_veln_n = std::make_shared < gnuplot_output_object < double > > (filename_veln_n);

    std::string filename_veln_t = path + "vel_un_t_" + std::to_string(time) + ".dat";
    auto test_veln_t = std::make_shared < gnuplot_output_object < double > > (filename_veln_t);

    std::string filename_velp_n = path + "vel_up_n_" + std::to_string(time) + ".dat";
    auto test_velp_n = std::make_shared < gnuplot_output_object < double > > (filename_velp_n);

    std::string filename_velp_t = path + "vel_up_t_" + std::to_string(time) + ".dat";
    auto test_velp_t = std::make_shared < gnuplot_output_object < double > > (filename_velp_t);

    RealType pos = 0.0;
    RealType force_pressure_avg = 0.0, force_pressure_max = 0.0;
    RealType force_gradVel_avg = 0.0, force_gradVel_max = 0.0;

    size_t counter_pt_Gamma = 0;


    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;
    RealType distance_pts = 0.0;

    timecounter tc1;
    tc1.tic();
//    size_t i_global = 0 ;
    auto hdi_cell = hdi.cell_degree();
    auto hdi_face = hdi.face_degree();
    auto msh_vel = velocity.msh;
    auto degree_vel = velocity.degree_FEM;


    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
        auto cbs = cb.size();


        level_set_function.cell_assignment(cl); // Useful to pick if a cell is agglo or not
//        test_case.test_case_cell_assignment(cl) ; // ----------------------------> TOGLIERE????


        assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
//        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
            vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
//                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
//                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);


            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;


// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = msh_vel.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;


                velocity.set_weight_area(offset_old, 1.0);

                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                }

            } else // AGGLO CELL
            {

                RealType nOfSubCellsAgglo = level_set_function.agglo_LS_cl.user_data.offset_subcells.size();
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    velocity.set_weight_area(offset_old, nOfSubCellsAgglo);
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = msh_vel.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                    }

                }
            }


        } else {

            vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
//                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

            vel_cell_dofs = vel_locdata.head(cbs);


// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                velocity.set_weight_area(offset_old, 1.0);
                auto cl_old = msh_vel.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                RealType nOfSubCellsAgglo = level_set_function.agglo_LS_cl.user_data.offset_subcells.size();
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    velocity.set_weight_area(offset_old, nOfSubCellsAgglo);
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = msh_vel.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


        }


    }

    tc.toc();
    std::cout << bold << yellow << "HHO velocity postprocessing: " << tc << " seconds" << reset << std::endl;


    timecounter tc_p1;

    tc_p1.tic();

    std::vector <size_t> cut_cell_cointainer, uncut_cell_cointainer;

    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_cointainer.push_back(offset(msh, cl));

        else
            uncut_cell_cointainer.push_back(offset(msh, cl));


    }


    point<RealType, 2> first_point;
    point<RealType, 2> cell_end_point;
    bool first_cut_cell_found = FALSE;

//    size_t deg_size = 2; // ESEMPIOOO
    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;


    size_t cl_i = 0;
    while (cut_cell_cointainer.size() > 0) {
        if (cl_i > cut_cell_cointainer.size() - 1)
            std::cout << "stop: first_pt = " << first_point << " pt_to_find = " << cell_end_point << std::endl;
        size_t k_offset = cut_cell_cointainer[cl_i];
        auto cl = msh.cells[k_offset];
//        auto msh_int = cl.user_data.integration_msh ;

        if (!first_cut_cell_found) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin()); //pop_front();

            post_processing_functionLS_2(msh, cl, hdi_cell, hdi_face, level_set_function, test_case,
                                         assembler_sc, bcs_vel, sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp,
                                         p_gp, interface_file, L2_pressure_error, l1_u_n_error, l2_u_n_error,
                                         linf_u_n_error, counter_interface_pts, degree, force_pressure_avg,
                                         force_pressure_max, counter_pt_Gamma, test_gammaH, test_press_jump,
                                         test_grad_vel_jump, distance_pts, force_gradVel_max, force_gradVel_avg,
                                         test_veln_n,
                                         p1_gp, p2_gp, test_grad_vel_t_n, sol_vel, sol_p, vel_grad, test_veln_t,
                                         test_velp_n, test_velp_t);

            first_cut_cell_found = TRUE;
            first_point = *cl.user_data.interface.begin();
            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;
        } else if (first_cut_cell_found && cell_end_point == *cl.user_data.interface.begin() &&
                   !(first_point == cell_end_point)) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin() + cl_i);
//                cut_cell_cointainer.pop_front();

            post_processing_functionLS_2(msh, cl, hdi_cell, hdi_face, level_set_function, test_case,
                                         assembler_sc, bcs_vel, sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp,
                                         interface_file, L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                         counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                         counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump,
                                         distance_pts,
                                         force_gradVel_max, force_gradVel_avg, test_veln_n,
                                         p1_gp, p2_gp, test_grad_vel_t_n, sol_vel, sol_p, vel_grad, test_veln_t,
                                         test_velp_n, test_velp_t);

            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;

        } else if (first_point == cell_end_point)
            break;
        else
            cl_i++;

    }

    std::cout << "First Point curvilinear variable: " << first_point << std::endl;
    tc_p1.toc();
    std::cout << "Interface_analysis time: " << tc_p1 << std::endl;
    tc_p1.tic();


    for (auto &i_cl: uncut_cell_cointainer) {
        auto cl = msh.cells[i_cl];
        post_processing_functionLS_fast_2(msh, cl, hdi_cell, hdi_face, level_set_function,
                                          test_case, assembler_sc, bcs_vel, sol, velocity, H1_error, L2_error,
                                          uT1_gp, uT2_gp, p_gp, interface_file, L2_pressure_error, l1_u_n_error,
                                          l2_u_n_error, linf_u_n_error, counter_interface_pts, degree,
                                          force_pressure_avg,
                                          force_pressure_max, counter_pt_Gamma, test_gammaH, test_press_jump,
                                          test_grad_vel_jump,
                                          distance_pts, force_gradVel_max, force_gradVel_avg,
                                          p1_gp, p2_gp, sol_vel, sol_p, vel_grad);

    }

    tc_p1.toc();
    std::cout << "Not cut cell analysis time: " << tc_p1 << std::endl;


    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;


    std::cout << bold << green << "AVG force pressure = " << force_pressure_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force pressure = " << force_pressure_max << std::endl;

    std::cout << bold << green << "AVG force grad_s velocity = " << force_gradVel_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force grad_s velocity = " << force_gradVel_max << std::endl;

    if (time % time_gap == 0) {
        postoutput.add_object(uT1_gp);
        postoutput.add_object(uT2_gp);
        postoutput.add_object(p_gp);
        postoutput.add_object(p1_gp);
        postoutput.add_object(p2_gp);

        postoutput.add_object(test_gammaH);
        postoutput.add_object(test_press_jump);
        postoutput.add_object(test_grad_vel_jump);
        postoutput.add_object(test_grad_vel_t_n);
        postoutput.add_object(test_veln_n);
        postoutput.add_object(test_veln_t);
        postoutput.add_object(test_velp_n);
        postoutput.add_object(test_velp_t);


        postoutput.write();
        if (interface_file) {

            interface_file.close();

        }

    }

    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
void
run_cuthho_interface_velocity_fast(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                   Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;


    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


//    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;


        assembler_sc.assemble(msh, cl, lc, f);


    }


    assembler_sc.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;


    std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;


    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    solver.analyzePattern(assembler_sc.LHS);
    solver.factorize(assembler_sc.LHS);
    sol = solver.solve(assembler_sc.RHS);

#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
    cgp.max_iter = assembler_sc.LHS.rows();
    conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);

#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;


//
//    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
//    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
//    auto uT_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT.dat");
//
////    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
//    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");
//    //auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();


    auto hdi_cell = hdi.cell_degree();
    auto hdi_face = hdi.face_degree();
    auto msh_vel = velocity.msh;
    auto degree_vel = velocity.degree_FEM;
    for (auto &cl: msh.cells) {


        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
        auto cbs = cb.size();


        level_set_function.cell_assignment(cl); // Useful to pick if a cell is agglo or not
//        test_case.test_case_cell_assignment(cl) ; // ----------------------------> TOGLIERE????


        assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
//        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
            vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
//                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
//                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);


            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;


// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = msh_vel.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;


                velocity.set_weight_area(offset_old, 1.0);

                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                }

            } else // AGGLO CELL
            {

                RealType nOfSubCellsAgglo = level_set_function.agglo_LS_cl.user_data.offset_subcells.size();
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    velocity.set_weight_area(offset_old, nOfSubCellsAgglo);
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = msh_vel.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                    }

                }
            }


        } else {

            vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
//                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

            vel_cell_dofs = vel_locdata.head(cbs);


// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                velocity.set_weight_area(offset_old, 1.0);
                auto cl_old = msh_vel.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                RealType nOfSubCellsAgglo = level_set_function.agglo_LS_cl.user_data.offset_subcells.size();
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    velocity.set_weight_area(offset_old, nOfSubCellsAgglo);
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = msh_vel.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }


        }


    }


    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_new(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                  Fonction &level_set_function, Velocity &velocity, bool sym_grad, size_t time) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;


    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;
    std::string filename_interface_uT = "interface_uT.3D";
    std::ofstream interface_file(filename_interface_uT, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
//    auto uT_gp  = std::make_shared< gnuplot_output_object_vec<RealType> >("interface_uT.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

//    auto force_pressure    = std::make_shared< gnuplot_output_object<RealType> >("pressure_force.dat");

    RealType pos = 0.0;
    RealType force_pressure_avg = 0.0, force_pressure_max = 0.0;
    size_t counter_pt_Gamma = 0;


    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;


//    timecounter tc1;
//    tc1.tic();
//    size_t i_global = 0 ;
    auto hdi_cell = hdi.cell_degree();
    auto hdi_face = hdi.face_degree();
    auto msh_vel = velocity.msh;
    auto degree_vel = velocity.degree_FEM;


    for (auto &cl: msh.cells) {

//        timecounter tc2;
//        tc2.tic();
        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);


        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
        auto cbs = cb.size();
//auto pbs = pb.size();


        level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
        test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
        assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

//            tc2.toc();
//            std::cout<<"time tc2 4 = "<<tc2<<std::endl;

// Updating velocity field by STE
//std::cout<<"------------>>> CUT CELL"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
//            tc2.tic();
// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            } else // AGGLO CELL
            {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk, cl_old) > iso_val_interface) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }

//            tc2.toc();
//            std::cout<<"time tc2 3 = "<<tc2<<std::endl;
//            tc2.tic();
            auto qps_n = integrate(msh, cl, 2 * hdi_cell, element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
                if (interface_file) {

                    interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1)
                                   << std::endl;

                }

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//                auto p_prova = test_case.sol_p( qp.first ) ;
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;
                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi_cell, element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
                if (interface_file) {

                    interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1)
                                   << std::endl;

                }
// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;

                p_gp->add_data(qp.first, p_num);
            }
            if (1) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }
//            tc2.toc();
//            std::cout<<"time tc2 2 = "<<tc2<<std::endl;

            if (1) // analysis power of pressure
            {
                auto parametric_interface = test_case.parametric_interface;
                auto gamma = test_case.gamma;
                auto msh_int = cl.user_data.integration_msh;
                auto global_cells_i = parametric_interface.get_global_cells_interface(msh, cl);
                size_t degree_curve = msh_int.degree_curve;
//                Interface_parametrisation_mesh1d curve(degree_curve) ;
                degree += 3 * degree_curve - 4; // 2*degree_curve ; // TO BE CHECKED
                auto qps = edge_quadrature<RealType>(degree);
                auto neumann = test_case.neumann_jump;
                for (size_t i_cell = 0; i_cell < msh_int.cells.size(); i_cell++) {
                    auto pts = points(msh_int, msh_int.cells[i_cell]);
                    size_t global_cl_i = global_cells_i[i_cell];
                    for (auto &qp: qps) {
                        auto t = 0.5 * qp.first.x() + 0.5;
                        auto p = parametric_interface(t, pts, degree_curve);
                        point<RealType, 2> pt = typename Mesh::point_type(p(0), p(1));

                        auto p_phi = pb.eval_basis(pt);
                        RealType p_pos = p_phi.dot(P_locdata_p);
                        RealType p_neg = p_phi.dot(P_locdata_n);

                        auto val = std::abs(p_pos - p_neg) /
                                   (std::abs(gamma * parametric_interface.curvature_cont(t, global_cl_i)));
//                        pos +=
//                        force_pressure->add_data( pos, val );
                        force_pressure_avg += val;
                        force_pressure_max = std::max(force_pressure_max, val);
                        counter_pt_Gamma++;

                    }
                }


            }

        } else {
//            tc2.tic();
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

//std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
//std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
/*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

// NOT AGGLO CELL
            if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }
//            tc2.toc();
//            std::cout<<"time tc2 1 = "<<tc2<<std::endl;
//            tc2.tic();
            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
// Compute H1-error //
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
                if (interface_file) {

                    interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1)
                                   << std::endl;

                }

// L2 - pressure - error //
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

                p_gp->add_data(qp.first, p_num);
            }
//            tc2.toc();
//            std::cout<<"time tc2 0 = "<<tc2<<std::endl;
        }

//        i_global++;
    }
//std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
//std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;
//    tc1.toc();
//    std::cout<<"time tc intero = "<<tc1<<std::endl;
    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;


    std::cout << bold << green << "AVG force pressure = " << force_pressure_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force pressure = " << force_pressure_max << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();
    if (interface_file) {

        interface_file.close();

    }


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_new_post_processing(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                                  Fonction &level_set_function, Velocity &velocity, bool sym_grad,
                                                  size_t time) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;


    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************


    postprocess_output <RealType> postoutput;
    std::string filename_interface_uT = "interface_uT.3D";
    std::ofstream interface_file(filename_interface_uT, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
//    auto uT_gp  = std::make_shared< gnuplot_output_object_vec<RealType> >("interface_uT.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
    auto p1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_pIN.dat");
    auto p2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_pOUT.dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    std::string filename_gammaH = "gamma_H_" + std::to_string(time) + ".dat";
    auto test_gammaH = std::make_shared < gnuplot_output_object < double > > (filename_gammaH);

    std::string filename_press_jump = "pressure_jump_" + std::to_string(time) + ".dat";
    auto test_press_jump = std::make_shared < gnuplot_output_object < double > > (filename_press_jump);

    std::string filename_grad_vel_jump = "grad_vel_jump_" + std::to_string(time) + ".dat";
    auto test_grad_vel_jump = std::make_shared < gnuplot_output_object < double > > (filename_grad_vel_jump);

    std::string filename_vel_n = "vel_u_n_" + std::to_string(time) + ".dat";
    auto test_vel_n = std::make_shared < gnuplot_output_object < double > > (filename_vel_n);
//    auto force_pressure    = std::make_shared< gnuplot_output_object<RealType> >("pressure_force.dat");

    RealType pos = 0.0;
    RealType force_pressure_avg = 0.0, force_pressure_max = 0.0;
    RealType force_gradVel_avg = 0.0, force_gradVel_max = 0.0;

    size_t counter_pt_Gamma = 0;


    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;
    RealType distance_pts = 0.0;

//    timecounter tc1;
//    tc1.tic();
//    size_t i_global = 0 ;
    auto hdi_cell = hdi.cell_degree();
    auto hdi_face = hdi.face_degree();
    auto msh_vel = velocity.msh;
    auto degree_vel = velocity.degree_FEM;

    timecounter tc_p1;

    tc_p1.tic();

    std::vector <size_t> cut_cell_cointainer, uncut_cell_cointainer;
    size_t counter_cut_cls = 0;
    size_t counter = 0;
    size_t counter_subcls = 0;
    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::ON_INTERFACE) {
            cut_cell_cointainer.push_back(offset(msh, cl));
            counter_cut_cls++;
            for (size_t i_cell = 0; i_cell < cl.user_data.integration_msh.cells.size(); i_cell++) {
//                   connectivity_cells[counter].push_back(counter_subcls);
                counter_subcls++;
            }

        } else {
            uncut_cell_cointainer.push_back(offset(msh, cl));
        }
        counter++;
    }


    point<RealType, 2> first_point;
    point<RealType, 2> cell_end_point;
    bool first_cut_cell_found = FALSE;

    size_t deg_size = 2; // ESEMPIOOO


    size_t cl_i = 0;
    while (cut_cell_cointainer.size() > 0) {
        if (cl_i > cut_cell_cointainer.size() - 1)
            std::cout << "stop: first_pt = " << first_point << " pt_to_find = " << cell_end_point << std::endl;
        size_t k_offset = cut_cell_cointainer[cl_i];
        auto cl = msh.cells[k_offset];
        auto msh_int = cl.user_data.integration_msh;

        if (!first_cut_cell_found) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin()); //pop_front();

            post_processing_function(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc, bcs_vel,
                                     sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp, interface_file,
                                     L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                     counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                     counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump, distance_pts,
                                     force_gradVel_max, force_gradVel_avg, test_vel_n, p1_gp, p2_gp);

            first_cut_cell_found = TRUE;
            first_point = *cl.user_data.interface.begin();
            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;
        } else if (first_cut_cell_found && cell_end_point == *cl.user_data.interface.begin() &&
                   !(first_point == cell_end_point)) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin() + cl_i);
//                cut_cell_cointainer.pop_front();

            post_processing_function(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc, bcs_vel,
                                     sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp, interface_file,
                                     L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                     counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                     counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump, distance_pts,
                                     force_gradVel_max, force_gradVel_avg, test_vel_n, p1_gp, p2_gp);

            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;

        } else if (first_point == cell_end_point)
            break;
        else
            cl_i++;

    }

    std::cout << "First Point curvilinear variable: " << first_point << std::endl;
    tc_p1.toc();
    std::cout << "Interface_analysis time: " << tc_p1 << std::endl;
    tc_p1.tic();
    for (auto &i_cl: uncut_cell_cointainer) {
        auto cl = msh.cells[i_cl];
        post_processing_function(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc, bcs_vel, sol,
                                 velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp, interface_file, L2_pressure_error,
                                 l1_u_n_error, l2_u_n_error, linf_u_n_error, counter_interface_pts, degree,
                                 force_pressure_avg, force_pressure_max, counter_pt_Gamma, test_gammaH, test_press_jump,
                                 test_grad_vel_jump, distance_pts, force_gradVel_max, force_gradVel_avg, test_vel_n,
                                 p1_gp, p2_gp);

    }

    tc_p1.toc();
    std::cout << "Not cut cell analysis time: " << tc_p1 << std::endl;


    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;


    std::cout << bold << green << "AVG force pressure = " << force_pressure_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force pressure = " << force_pressure_max << std::endl;

    std::cout << bold << green << "AVG force grad_s velocity = " << force_gradVel_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force grad_s velocity = " << force_gradVel_max << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.add_object(p1_gp);
    postoutput.add_object(p2_gp);

    postoutput.add_object(test_gammaH);
    postoutput.add_object(test_press_jump);
    postoutput.add_object(test_grad_vel_jump);
    postoutput.add_object(test_vel_n);


    postoutput.write();
    if (interface_file) {

        interface_file.close();

    }


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename Cell, typename LS, typename TC, typename RealType, typename ASS, typename BDRY, typename SOL, typename VEL, typename PP1, typename PP2>
void
post_processing_function(const Mesh &msh, Cell &cl, size_t hdi_cell, size_t hdi_face, LS &level_set_function,
                         TC &test_case, ASS &assembler_sc, BDRY &bcs_vel, const SOL &sol, VEL &velocity,
                         RealType &H1_error, RealType &L2_error, PP1 &uT1_gp, PP1 &uT2_gp, PP1 &p_gp,
                         PP2 &interface_file, RealType &L2_pressure_error, RealType &l1_u_n_error,
                         RealType &l2_u_n_error, RealType &linf_u_n_error, size_t &counter_interface_pts,
                         size_t &degree, RealType &force_pressure_avg, RealType &force_pressure_max,
                         size_t &counter_pt_Gamma, PP1 &test_gammaH, PP1 &test_press_jump, PP1 &test_grad_vel_jump,
                         RealType &distance_pts, RealType &force_gradVel_max, RealType &force_gradVel_avg,
                         PP1 &test_vel_n, PP1 &p1_gp, PP1 &p2_gp) {


    vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
    RealType kappa_1 = test_case.parms.kappa_1;
    RealType kappa_2 = test_case.parms.kappa_2;

    cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
    auto cbs = cb.size();
//auto pbs = pb.size();


    level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
    test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????

    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
    assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


    Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
    Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
    Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

    if (location(msh, cl) == element_location::ON_INTERFACE) {
        vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);


        vel_cell_dofs_n = vel_locdata_n.head(cbs);
        vel_cell_dofs_p = vel_locdata_p.head(cbs);


// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {

            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                if (level_set_function(ln_Qk, cl_old) > 0.0) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
                } else {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                }
            }

        } else // AGGLO CELL
        {
//for(auto pt:points(msh,cl))
//   std::cout<<"pt = "<<pt<<std::endl;

            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > 0.0) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
        }

//            tc2.toc();
//            std::cout<<"time tc2 3 = "<<tc2<<std::endl;
//            tc2.tic();
        auto qps_n = integrate(msh, cl, 2 * hdi_cell, element_location::IN_NEGATIVE_SIDE);
        for (auto &qp: qps_n) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_n;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_1 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));

            interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;



// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_n);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//                auto p_prova = test_case.sol_p( qp.first ) ;
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_1;
            p_gp->add_data(qp.first, p_num);
            p1_gp->add_data(qp.first, p_num);
        }

        auto qps_p = integrate(msh, cl, 2 * hdi_cell, element_location::IN_POSITIVE_SIDE);
        for (auto &qp: qps_p) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_p;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_2 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }
// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_p);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_2;

            p_gp->add_data(qp.first, p_num);
            p2_gp->add_data(qp.first, p_num);
        }
        if (1) {
            for (auto &interface_point: cl.user_data.interface) {
                auto t_phi = cb.eval_basis(interface_point);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                auto n = level_set_function.normal(interface_point);
                auto v_n = v.dot(n);
                l1_u_n_error += std::abs(v_n);
                l2_u_n_error += pow(v_n, 2.0);
                linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                counter_interface_pts++;
            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 2 = "<<tc2<<std::endl;

        if (1) // analysis power of pressure
        {
            auto parametric_interface = test_case.parametric_interface;
            auto gamma = test_case.gamma;
            auto msh_int = cl.user_data.integration_msh;
            auto global_cells_i = parametric_interface.get_global_cells_interface(msh, cl);
            size_t degree_curve = msh_int.degree_curve;
            RealType tot = 10.0;
//                Interface_parametrisation_mesh1d curve(degree_curve) ;
//            degree += 3*degree_curve -4 ; // 2*degree_curve ; // TO BE CHECKED
//            auto qps = edge_quadrature<RealType>(degree);
            auto neumann = test_case.neumann_jump;
            for (size_t i_cell = 0; i_cell < msh_int.cells.size(); i_cell++) {
                auto pts = points(msh_int, msh_int.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell];
//                auto qp_old = 0.5 *(*(qps.begin())).first.x() + 0.5;
//                auto p = parametric_interface(t , pts , degree_curve ) ;
//                point<RealType,2> pt_old ; //= typename Mesh::point_type( p(0) , p(1) ) ;

                for (RealType i = 0.0; i <= tot; i++) {
                    auto t = 0.0 + i / tot;
                    auto p = parametric_interface(t, pts, degree_curve);
                    point<RealType, 2> pt = typename Mesh::point_type(p(0), p(1));
//                    if( t == 0.0 )
//                        pt_old = pt;
                    auto p_phi = pb.eval_basis(pt);
                    RealType p_pos = p_phi.dot(P_locdata_p);
                    RealType p_neg = p_phi.dot(P_locdata_n);


                    auto phi_HHO = cb.eval_basis(pt);
                    auto t_dphi = cb.eval_gradients(pt);
                    Matrix<RealType, 2, 2> grad_p = Matrix<RealType, 2, 2>::Zero();
                    Matrix<RealType, 2, 2> grad_n = Matrix<RealType, 2, 2>::Zero();

                    for (size_t i = 1; i < cbs; i++) {
                        grad_p += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);
                        grad_n += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                    }
                    Matrix<RealType, 2, 2> grad_sym_p = 0.5 * (grad_p + grad_p.transpose());
                    Matrix<RealType, 2, 2> grad_sym_n = 0.5 * (grad_n + grad_n.transpose());
                    auto vel_n = phi_HHO.transpose() * vel_cell_dofs_n;
                    Matrix<RealType, 2, 1> phi_n = parametric_interface.normal_cont(t, global_cl_i);
                    RealType val_u_n = (vel_n).transpose() * (phi_n);

                    auto val_p = (p_pos - p_neg);
                    RealType val_u =
                            (phi_n.transpose()) * (2.0 * kappa_1 * grad_sym_n - 2.0 * kappa_2 * grad_sym_p) * (phi_n);

//                    RealType val_u ;
//                    if( signbit(phi_n(0)) == signbit(grads_u_n(0)) && signbit(phi_n(1)) == signbit(grads_u_n(1)) )
//                        val_u = grads_u_n.norm();
//                    else
//                        val_u = -grads_u_n.norm();
                    point<RealType, 2> curv_var = typename Mesh::point_type(distance_pts, 0.0);
                    auto val_H = gamma * parametric_interface.curvature_cont(t, global_cl_i);
                    test_press_jump->add_data(curv_var, val_p);
                    test_gammaH->add_data(curv_var, val_H);
                    test_grad_vel_jump->add_data(curv_var, val_u);

                    test_vel_n->add_data(curv_var, val_u_n);

                    force_pressure_avg += val_p / val_H;
                    force_pressure_max = std::max(force_pressure_max, std::abs(val_p / val_H));

                    force_gradVel_avg += val_u / val_H;
                    force_gradVel_max = std::max(force_gradVel_max, std::abs(val_u / val_H));


                    counter_pt_Gamma++;

                    RealType dist;

                    if (t == 1)
                        dist = 0.0;
                    else
                        dist = (parametric_interface(t + 1.0 / tot, pts, degree_curve) - p).norm();

                    distance_pts += dist;

                }
            }


        }

    } else {
//            tc2.tic();
        vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

        vel_cell_dofs = vel_locdata.head(cbs);



// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                auto phi_HHO = cb.eval_basis(ln_Qk);
                auto vel = phi_HHO.transpose() * vel_cell_dofs;
                velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                i_local++;

            }

        } else // AGGLO CELL
        {
            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 1 = "<<tc2<<std::endl;
//            tc2.tic();
        RealType kappa = test_case.parms.kappa_1;
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            kappa = test_case.parms.kappa_2;

        auto qps = integrate(msh, cl, 2 * hdi_cell);
        for (auto &qp: qps) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }

// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa;

            p_gp->add_data(qp.first, p_num);
            if (level_set_function(qp.first, cl) > 0.0)
                p2_gp->add_data(qp.first, p_num);
            else
                p1_gp->add_data(qp.first, p_num);
        }
//            tc2.toc();
//            std::cout<<"time tc2 0 = "<<tc2<<std::endl;
    }


}


template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_new_post_processingLS(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                                    Fonction &level_set_function, Velocity &velocity, bool sym_grad,
                                                    size_t time, int time_gap) {
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface;


    auto bcs_vel = test_case.bcs_vel;


    timecounter tc;

    bool sc = true;  // static condensation


// ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

// IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func(bcs_vel); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh);

    for (auto &cl: msh.cells) {

//std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
        test_case.test_case_cell_assignment(cl);
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

// ************** SOLVE **************
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        std::cout << "First step: analyze pattern... " << std::endl;
        solver.analyzePattern(assembler_sc.LHS);
        std::cout << "Pattern ok. Second step: assembling... " << std::endl;
        solver.factorize(assembler_sc.LHS);
        std::cout << "Assembling ok. Third step: solving... " << std::endl;
        sol = solver.solve(assembler_sc.RHS);
        std::cout << "..problem solved. " << std::endl;
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
//        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);


        ConjugateGradient < SparseMatrix < RealType > , Lower | Upper > cg;
        cg.compute(assembler_sc.LHS);
        sol = cg.solve(assembler_sc.RHS);
        std::cout << "#iterations:     " << cg.iterations() << std::endl;
        std::cout << "estimated error: " << cg.error() << std::endl;
// conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);

    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds" << std::endl;

// ************** POSTPROCESS **************

    std::string path = "simulation_1x1_/";
    postprocess_output <RealType> postoutput;
    std::string filename_interface_uT = path + "interface_uT_" + std::to_string(time) + ".3D";
    std::ofstream interface_file(filename_interface_uT, std::ios::out | std::ios::trunc);

    if (interface_file) {
// instructions
        interface_file << "X   Y   val0   val1" << std::endl;
    } else
        std::cerr << "Interface_file has not been opened" << std::endl;


    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > >
                  (path + "interface_uT1_" + std::to_string(time) + ".dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > >
                  (path + "interface_uT2_" + std::to_string(time) + ".dat");
//    auto uT_gp  = std::make_shared< gnuplot_output_object_vec<RealType> >("interface_uT.dat");

//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > >
                (path + "interface_p_" + std::to_string(time) + ".dat");
    auto p1_gp = std::make_shared < gnuplot_output_object < RealType > >
                 (path + "interface_pIN_" + std::to_string(time) + ".dat");
    auto p2_gp = std::make_shared < gnuplot_output_object < RealType > >
                 (path + "interface_pOUT_" + std::to_string(time) + ".dat");
//auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    std::string filename_gammaH = path + "gamma_H_" + std::to_string(time) + ".dat";
    auto test_gammaH = std::make_shared < gnuplot_output_object < double > > (filename_gammaH);

    std::string filename_press_jump = path + "pressure_jump_" + std::to_string(time) + ".dat";
    auto test_press_jump = std::make_shared < gnuplot_output_object < double > > (filename_press_jump);

    std::string filename_grad_vel_jump = path + "grad_vel_jump_" + std::to_string(time) + ".dat";
    auto test_grad_vel_jump = std::make_shared < gnuplot_output_object < double > > (filename_grad_vel_jump);


    std::string filename_grad_vel_t_n = path + "grad_vel_t_n_" + std::to_string(time) + ".dat";
    auto test_grad_vel_t_n = std::make_shared < gnuplot_output_object < double > > (filename_grad_vel_t_n);

    std::string filename_vel_n = path + "vel_u_n_" + std::to_string(time) + ".dat";
    auto test_vel_n = std::make_shared < gnuplot_output_object < double > > (filename_vel_n);
//    auto force_pressure    = std::make_shared< gnuplot_output_object<RealType> >("pressure_force.dat");

    RealType pos = 0.0;
    RealType force_pressure_avg = 0.0, force_pressure_max = 0.0;
    RealType force_gradVel_avg = 0.0, force_gradVel_max = 0.0;

    size_t counter_pt_Gamma = 0;


    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;
    RealType distance_pts = 0.0;

//    timecounter tc1;
//    tc1.tic();
//    size_t i_global = 0 ;
    auto hdi_cell = hdi.cell_degree();
    auto hdi_face = hdi.face_degree();
    auto msh_vel = velocity.msh;
    auto degree_vel = velocity.degree_FEM;

    timecounter tc_p1;

    tc_p1.tic();

    std::vector <size_t> cut_cell_cointainer, uncut_cell_cointainer;

    for (auto &cl: msh.cells) {
        if (location(msh, cl) == element_location::ON_INTERFACE)
            cut_cell_cointainer.push_back(offset(msh, cl));

        else
            uncut_cell_cointainer.push_back(offset(msh, cl));


    }


    point<RealType, 2> first_point;
    point<RealType, 2> cell_end_point;
    bool first_cut_cell_found = FALSE;

//    size_t deg_size = 2; // ESEMPIOOO
    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;


    size_t cl_i = 0;
    while (cut_cell_cointainer.size() > 0) {
        if (cl_i > cut_cell_cointainer.size() - 1)
            std::cout << "stop: first_pt = " << first_point << " pt_to_find = " << cell_end_point << std::endl;
        size_t k_offset = cut_cell_cointainer[cl_i];
        auto cl = msh.cells[k_offset];
//        auto msh_int = cl.user_data.integration_msh ;

        if (!first_cut_cell_found) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin()); //pop_front();

            post_processing_functionLS(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc,
                                       bcs_vel, sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp, interface_file,
                                       L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                       counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                       counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump, distance_pts,
                                       force_gradVel_max, force_gradVel_avg, test_vel_n, p1_gp, p2_gp,
                                       test_grad_vel_t_n, sol_vel, sol_p, vel_grad);

            first_cut_cell_found = TRUE;
            first_point = *cl.user_data.interface.begin();
            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;
        } else if (first_cut_cell_found && cell_end_point == *cl.user_data.interface.begin() &&
                   !(first_point == cell_end_point)) {
            cut_cell_cointainer.erase(cut_cell_cointainer.begin() + cl_i);
//                cut_cell_cointainer.pop_front();

            post_processing_functionLS(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc,
                                       bcs_vel, sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp, interface_file,
                                       L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                       counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                       counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump, distance_pts,
                                       force_gradVel_max, force_gradVel_avg, test_vel_n, p1_gp, p2_gp,
                                       test_grad_vel_t_n, sol_vel, sol_p, vel_grad);

            cell_end_point = *(cl.user_data.interface.end() - 1);
            cl_i = 0;

        } else if (first_point == cell_end_point)
            break;
        else
            cl_i++;

    }

    std::cout << "First Point curvilinear variable: " << first_point << std::endl;
    tc_p1.toc();
    std::cout << "Interface_analysis time: " << tc_p1 << std::endl;
    tc_p1.tic();


    for (auto &i_cl: uncut_cell_cointainer) {
        auto cl = msh.cells[i_cl];
        post_processing_functionLS_fast(msh, cl, hdi_cell, hdi_face, level_set_function, test_case, assembler_sc,
                                        bcs_vel, sol, velocity, H1_error, L2_error, uT1_gp, uT2_gp, p_gp,
                                        interface_file, L2_pressure_error, l1_u_n_error, l2_u_n_error, linf_u_n_error,
                                        counter_interface_pts, degree, force_pressure_avg, force_pressure_max,
                                        counter_pt_Gamma, test_gammaH, test_press_jump, test_grad_vel_jump,
                                        distance_pts, force_gradVel_max, force_gradVel_avg, test_vel_n, p1_gp, p2_gp,
                                        test_grad_vel_t_n, sol_vel, sol_p, vel_grad);

    }

    tc_p1.toc();
    std::cout << "Not cut cell analysis time: " << tc_p1 << std::endl;


    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error / counter_interface_pts
              << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error / counter_interface_pts)
              << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;


    std::cout << bold << green << "AVG force pressure = " << force_pressure_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force pressure = " << force_pressure_max << std::endl;

    std::cout << bold << green << "AVG force grad_s velocity = " << force_gradVel_avg / counter_pt_Gamma << std::endl;
    std::cout << bold << green << "linf-norm force grad_s velocity = " << force_gradVel_max << std::endl;

    if (time % time_gap == 0) {
        postoutput.add_object(uT1_gp);
        postoutput.add_object(uT2_gp);
        postoutput.add_object(p_gp);
        postoutput.add_object(p1_gp);
        postoutput.add_object(p2_gp);

        postoutput.add_object(test_gammaH);
        postoutput.add_object(test_press_jump);
        postoutput.add_object(test_grad_vel_jump);
        postoutput.add_object(test_vel_n);
        postoutput.add_object(test_grad_vel_t_n);


        postoutput.write();
        if (interface_file) {

            interface_file.close();

        }

    }

    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if (1) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }


    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
            JacobiSVD <MatrixXd> svd(Mat);
            RealType cond = svd.singularValues()(0)
                            / svd.singularValues()(svd.singularValues().size() - 1);
            std::cout << "cond numb = " << cond << std::endl;
        }

        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename Cell, typename LS, typename TC, typename RealType, typename ASS, typename BDRY, typename SOL, typename VEL, typename PP1, typename PP2, typename Function1, typename Function2, typename Function3>
void
post_processing_functionLS(const Mesh &msh, Cell &cl, size_t hdi_cell, size_t hdi_face, LS &level_set_function,
                           TC &test_case, ASS &assembler_sc, BDRY &bcs_vel, const SOL &sol, VEL &velocity,
                           RealType &H1_error, RealType &L2_error, PP1 &uT1_gp, PP1 &uT2_gp, PP1 &p_gp,
                           PP2 &interface_file, RealType &L2_pressure_error, RealType &l1_u_n_error,
                           RealType &l2_u_n_error, RealType &linf_u_n_error, size_t &counter_interface_pts,
                           size_t &degree, RealType &force_pressure_avg, RealType &force_pressure_max,
                           size_t &counter_pt_Gamma, PP1 &test_gammaH, PP1 &test_press_jump, PP1 &test_grad_vel_jump,
                           RealType &distance_pts, RealType &force_gradVel_max, RealType &force_gradVel_avg,
                           PP1 &test_vel_n, PP1 &p1_gp, PP1 &p2_gp, PP1 &test_grad_vel_t_n, Function1 &sol_vel,
                           Function2 &sol_p, Function3 &vel_grad) {


    vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
    RealType kappa_1 = test_case.parms.kappa_1;
    RealType kappa_2 = test_case.parms.kappa_2;

    cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
    auto cbs = cb.size();
//auto pbs = pb.size();
//    auto sol_vel = test_case.sol_vel;
//    auto sol_p = test_case.sol_p;
//    auto vel_grad = test_case.vel_grad;

    level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
    test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????


//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
    assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


    Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
    Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
    Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

    if (location(msh, cl) == element_location::ON_INTERFACE) {
        vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);


        vel_cell_dofs_n = vel_locdata_n.head(cbs);
        vel_cell_dofs_p = vel_locdata_p.head(cbs);


// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {

            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                if (level_set_function(ln_Qk, cl_old) > 0.0) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
                } else {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                }
            }

        } else // AGGLO CELL
        {

            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > 0.0) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
        }

//            tc2.toc();
//            std::cout<<"time tc2 3 = "<<tc2<<std::endl;
//            tc2.tic();
        auto qps_n = integrate(msh, cl, 2 * hdi_cell, element_location::IN_NEGATIVE_SIDE);
        for (auto &qp: qps_n) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_n;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_1 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));

            interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;



// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_n);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//                auto p_prova = test_case.sol_p( qp.first ) ;
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_1;
            p_gp->add_data(qp.first, p_num);
            p1_gp->add_data(qp.first, p_num);
        }

        auto qps_p = integrate(msh, cl, 2 * hdi_cell, element_location::IN_POSITIVE_SIDE);
        for (auto &qp: qps_p) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_p;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_2 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }
// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_p);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_2;

            p_gp->add_data(qp.first, p_num);
            p2_gp->add_data(qp.first, p_num);
        }
        if (1) {
            for (auto &interface_point: cl.user_data.interface) {
                auto t_phi = cb.eval_basis(interface_point);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                auto n = level_set_function.normal(interface_point);
                auto v_n = v.dot(n);
                l1_u_n_error += std::abs(v_n);
                l2_u_n_error += pow(v_n, 2.0);
                linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                counter_interface_pts++;
            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 2 = "<<tc2<<std::endl;

        if (1) // analysis power of pressure
        {
            auto parametric_interface = test_case.parametric_interface;
            auto gamma = test_case.gamma;
            auto msh_int = cl.user_data.integration_msh;
            auto global_cells_i = parametric_interface.get_global_cells_interface(msh, cl);
            Matrix<RealType, 2, 1> phi_t;
            size_t degree_curve = msh_int.degree_curve;
            RealType tot = 10.0;
//                Interface_parametrisation_mesh1d curve(degree_curve) ;
//            degree += 3*degree_curve -4 ; // 2*degree_curve ; // TO BE CHECKED
//            auto qps = edge_quadrature<RealType>(degree);
            auto neumann = test_case.neumann_jump;
            for (size_t i_cell = 0; i_cell < msh_int.cells.size(); i_cell++) {
                auto pts = points(msh_int, msh_int.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell];
//                auto qp_old = 0.5 *(*(qps.begin())).first.x() + 0.5;
//                auto p = parametric_interface(t , pts , degree_curve ) ;
//                point<RealType,2> pt_old ; //= typename Mesh::point_type( p(0) , p(1) ) ;

                for (RealType i = 0.0; i <= tot; i++) {
                    auto t = 0.0 + i / tot;
                    auto p = parametric_interface(t, pts, degree_curve);
                    point<RealType, 2> pt = typename Mesh::point_type(p(0), p(1));
//                    if( t == 0.0 )
//                        pt_old = pt;
                    auto p_phi = pb.eval_basis(pt);
                    RealType p_pos = p_phi.dot(P_locdata_p);
                    RealType p_neg = p_phi.dot(P_locdata_n);


                    auto phi_HHO = cb.eval_basis(pt);
                    auto t_dphi = cb.eval_gradients(pt);
                    Matrix<RealType, 2, 2> grad_p = Matrix<RealType, 2, 2>::Zero();
                    Matrix<RealType, 2, 2> grad_n = Matrix<RealType, 2, 2>::Zero();

                    for (size_t i = 1; i < cbs; i++) {
                        grad_p += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);
                        grad_n += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                    }
                    Matrix<RealType, 2, 2> grad_sym_p = 0.5 * (grad_p + grad_p.transpose());
                    Matrix<RealType, 2, 2> grad_sym_n = 0.5 * (grad_n + grad_n.transpose());
                    auto vel_n = phi_HHO.transpose() * vel_cell_dofs_n;

                    Matrix<RealType, 2, 1> phi_n = level_set_function.normal(pt);
                    RealType val_u_n = (vel_n).transpose() * (phi_n);

                    auto val_p = (p_pos - p_neg);
                    Matrix<RealType, 2, 1> val_grad_u_n =
                            (2.0 * kappa_1 * grad_sym_n - 2.0 * kappa_2 * grad_sym_p) * (phi_n);
                    RealType val_u = (phi_n.transpose()) * val_grad_u_n;
                    phi_t(0) = -phi_n(1);
                    phi_t(1) = phi_n(0);
                    RealType t_val_u_n = (phi_t.transpose()) * val_grad_u_n;
//                    RealType val_u ;
//                    if( signbit(phi_n(0)) == signbit(grads_u_n(0)) && signbit(phi_n(1)) == signbit(grads_u_n(1)) )
//                        val_u = grads_u_n.norm();
//                    else
//                        val_u = -grads_u_n.norm();
                    point<RealType, 2> curv_var = typename Mesh::point_type(distance_pts, 0.0);
                    auto val_H = gamma * level_set_function.divergence(pt);
                    test_press_jump->add_data(curv_var, val_p);
                    test_gammaH->add_data(curv_var, val_H);
                    test_grad_vel_jump->add_data(curv_var, val_u);
                    test_grad_vel_t_n->add_data(curv_var, t_val_u_n);
                    test_vel_n->add_data(curv_var, val_u_n);

                    force_pressure_avg += val_p / val_H;
                    force_pressure_max = std::max(force_pressure_max, std::abs(val_p / val_H));

                    force_gradVel_avg += val_u / val_H;
                    force_gradVel_max = std::max(force_gradVel_max, std::abs(val_u / val_H));


                    counter_pt_Gamma++;

                    RealType dist;

                    if (t == 1)
                        dist = 0.0;
                    else
                        dist = (parametric_interface(t + 1.0 / tot, pts, degree_curve) - p).norm();

                    distance_pts += dist;

                }
            }


        }

    } else {
//            tc2.tic();
        vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

        vel_cell_dofs = vel_locdata.head(cbs);



// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                auto phi_HHO = cb.eval_basis(ln_Qk);
                auto vel = phi_HHO.transpose() * vel_cell_dofs;
                velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                i_local++;

            }

        } else // AGGLO CELL
        {
            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 1 = "<<tc2<<std::endl;
//            tc2.tic();
        RealType kappa = test_case.parms.kappa_1;
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            kappa = test_case.parms.kappa_2;

        auto qps = integrate(msh, cl, 2 * hdi_cell);
        for (auto &qp: qps) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }

// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa;

            p_gp->add_data(qp.first, p_num);
            if (level_set_function(qp.first, cl) > 0.0)
                p2_gp->add_data(qp.first, p_num);
            else
                p1_gp->add_data(qp.first, p_num);
        }
//            tc2.toc();
//            std::cout<<"time tc2 0 = "<<tc2<<std::endl;
    }


}


template<typename Mesh, typename Cell, typename LS, typename TC, typename RealType, typename ASS, typename BDRY, typename SOL, typename VEL, typename PP1, typename PP2, typename Function1, typename Function2, typename Function3>
void
post_processing_functionLS_fast(const Mesh &msh, Cell &cl, size_t hdi_cell, size_t hdi_face, LS &level_set_function,
                                TC &test_case, ASS &assembler_sc, BDRY &bcs_vel, const SOL &sol, VEL &velocity,
                                RealType &H1_error, RealType &L2_error, PP1 &uT1_gp, PP1 &uT2_gp, PP1 &p_gp,
                                PP2 &interface_file, RealType &L2_pressure_error, RealType &l1_u_n_error,
                                RealType &l2_u_n_error, RealType &linf_u_n_error, size_t &counter_interface_pts,
                                size_t &degree, RealType &force_pressure_avg, RealType &force_pressure_max,
                                size_t &counter_pt_Gamma, PP1 &test_gammaH, PP1 &test_press_jump,
                                PP1 &test_grad_vel_jump, RealType &distance_pts, RealType &force_gradVel_max,
                                RealType &force_gradVel_avg, PP1 &test_vel_n, PP1 &p1_gp, PP1 &p2_gp,
                                PP1 &test_grad_vel_t_n, Function1 &sol_vel, Function2 &sol_p, Function3 &vel_grad) {


    vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
    RealType kappa_1 = test_case.parms.kappa_1;
    RealType kappa_2 = test_case.parms.kappa_2;

    cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
    auto cbs = cb.size();
    auto pbs = pb.size();


    level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
    test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????

//    auto sol_vel = test_case.sol_vel;
//    auto sol_p = test_case.sol_p;
//    auto vel_grad = test_case.vel_grad;

    assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


    Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
    Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
    Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;


    vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
    P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

    vel_cell_dofs = vel_locdata.head(cbs);



// NOT AGGLO CELL
    if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
        auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
        auto cl_old = velocity.msh.cells[offset_old];
        auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
        size_t i_local = 0;
        for (const auto &ln_Qk: Lagrange_nodes_Qk) {
            auto phi_HHO = cb.eval_basis(ln_Qk);
            auto vel = phi_HHO.transpose() * vel_cell_dofs;
            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
            velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
            i_local++;

        }

    } else // AGGLO CELL
    {
        for (size_t i_subcell = 0;
             i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                auto phi_HHO = cb.eval_basis(ln_Qk);
                auto vel = phi_HHO.transpose() * vel_cell_dofs;
                velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                velocity.sol_HHO.second(i_local, offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                i_local++;

            }

        }
    }

    RealType kappa = test_case.parms.kappa_1;
    if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
        kappa = test_case.parms.kappa_2;

    auto qps = integrate(msh, cl, 2 * hdi_cell);
    for (auto &qp: qps) {
// Compute H1-error //
        auto t_dphi = cb.eval_gradients(qp.first);
        Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

        for (size_t i = 1; i < cbs; i++)
            grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

        Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
        Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
        H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
        auto t_phi = cb.eval_basis(qp.first);
        auto v = t_phi.transpose() * vel_cell_dofs;
        Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;

        L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

        uT1_gp->add_data(qp.first, v(0));
        uT2_gp->add_data(qp.first, v(1));
        if (interface_file) {

            interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

        }

// L2 - pressure - error //
        auto p_phi = pb.eval_basis(qp.first);
        RealType p_num = p_phi.dot(P_locdata);
        RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE

        L2_pressure_error += qp.second * p_diff * p_diff / kappa;

        p_gp->add_data(qp.first, p_num);
        if (level_set_function(qp.first, cl) > 0.0)
            p2_gp->add_data(qp.first, p_num);
        else
            p1_gp->add_data(qp.first, p_num);
    }


}


template<typename Mesh, typename Cell, typename LS, typename TC, typename RealType, typename ASS, typename BDRY, typename SOL, typename VEL, typename PP1, typename PP2, typename Function1, typename Function2, typename Function3>
void
post_processing_functionLS_2(const Mesh &msh, Cell &cl, size_t hdi_cell, size_t hdi_face,
                             LS &level_set_function, TC &test_case, ASS &assembler_sc, BDRY &bcs_vel,
                             const SOL &sol, VEL &velocity, RealType &H1_error, RealType &L2_error, PP1 &uT1_gp,
                             PP1 &uT2_gp, PP1 &p_gp, PP2 &interface_file, RealType &L2_pressure_error,
                             RealType &l1_u_n_error,
                             RealType &l2_u_n_error, RealType &linf_u_n_error, size_t &counter_interface_pts,
                             size_t &degree,
                             RealType &force_pressure_avg, RealType &force_pressure_max, size_t &counter_pt_Gamma,
                             PP1 &test_gammaH,
                             PP1 &test_press_jump, PP1 &test_grad_vel_jump, RealType &distance_pts,
                             RealType &force_gradVel_max,
                             RealType &force_gradVel_avg, PP1 &test_veln_n, PP1 &p1_gp, PP1 &p2_gp,
                             PP1 &test_grad_vel_t_n,
                             Function1 &sol_vel, Function2 &sol_p, Function3 &vel_grad, PP1 &test_veln_t,
                             PP1 &test_velp_n, PP1 &test_velp_t) {


    vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
    RealType kappa_1 = test_case.parms.kappa_1;
    RealType kappa_2 = test_case.parms.kappa_2;

    cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
    auto cbs = cb.size();
//auto pbs = pb.size();
//    auto sol_vel = test_case.sol_vel;
//    auto sol_p = test_case.sol_p;
//    auto vel_grad = test_case.vel_grad;

    level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
    test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????


//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;
    assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


    Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
    Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
    Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

    if (location(msh, cl) == element_location::ON_INTERFACE) {
        vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
        P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);


        vel_cell_dofs_n = vel_locdata_n.head(cbs);
        vel_cell_dofs_p = vel_locdata_p.head(cbs);


// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {

            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                if (level_set_function(ln_Qk, cl_old) > 0.0) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
                } else {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                }
            }

        } else // AGGLO CELL
        {

            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk, cl_old) > 0.0) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
//  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
//  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
        }

//            tc2.toc();
//            std::cout<<"time tc2 3 = "<<tc2<<std::endl;
//            tc2.tic();
        auto qps_n = integrate(msh, cl, 2 * hdi_cell, element_location::IN_NEGATIVE_SIDE);
        for (auto &qp: qps_n) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_n;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_1 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));

            interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;



// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_n);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//                auto p_prova = test_case.sol_p( qp.first ) ;
//                std::cout<<"In pt = "<<qp.first<<" --> pressure ANAL  = "<<p_prova<<" , pressure NUM = "<< p_num<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_1;
            p_gp->add_data(qp.first, p_num);
            p1_gp->add_data(qp.first, p_num);
        }

        auto qps_p = integrate(msh, cl, 2 * hdi_cell, element_location::IN_POSITIVE_SIDE);
        for (auto &qp: qps_p) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs_p;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa_2 * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }
// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata_p);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa_2;

            p_gp->add_data(qp.first, p_num);
            p2_gp->add_data(qp.first, p_num);
        }
        if (1) {
            for (auto &interface_point: cl.user_data.interface) {
                auto t_phi = cb.eval_basis(interface_point);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                auto n = level_set_function.normal(interface_point);
                auto v_n = v.dot(n);
                l1_u_n_error += std::abs(v_n);
                l2_u_n_error += pow(v_n, 2.0);
                linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                counter_interface_pts++;
            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 2 = "<<tc2<<std::endl;

        if (1) // analysis power of pressure
        {
            auto parametric_interface = test_case.parametric_interface;
            auto gamma = test_case.gamma;
            auto msh_int = cl.user_data.integration_msh;
            auto global_cells_i = parametric_interface.get_global_cells_interface(msh, cl);
            Matrix<RealType, 2, 1> phi_t;
            size_t degree_curve = msh_int.degree_curve;
            RealType tot = 10.0;
//                Interface_parametrisation_mesh1d curve(degree_curve) ;
//            degree += 3*degree_curve -4 ; // 2*degree_curve ; // TO BE CHECKED
//            auto qps = edge_quadrature<RealType>(degree);
            auto neumann = test_case.neumann_jump;
            for (size_t i_cell = 0; i_cell < msh_int.cells.size(); i_cell++) {
                auto pts = points(msh_int, msh_int.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell];
//                auto qp_old = 0.5 *(*(qps.begin())).first.x() + 0.5;
//                auto p = parametric_interface(t , pts , degree_curve ) ;
//                point<RealType,2> pt_old ; //= typename Mesh::point_type( p(0) , p(1) ) ;

                for (RealType i = 0.0; i <= tot; i++) {
                    auto t = 0.0 + i / tot;
                    auto p = parametric_interface(t, pts, degree_curve);
                    point<RealType, 2> pt = typename Mesh::point_type(p(0), p(1));
//                    if( t == 0.0 )
//                        pt_old = pt;
                    auto p_phi = pb.eval_basis(pt);
                    RealType p_pos = p_phi.dot(P_locdata_p);
                    RealType p_neg = p_phi.dot(P_locdata_n);


                    auto phi_HHO = cb.eval_basis(pt);
                    auto t_dphi = cb.eval_gradients(pt);
                    Matrix<RealType, 2, 2> grad_p = Matrix<RealType, 2, 2>::Zero();
                    Matrix<RealType, 2, 2> grad_n = Matrix<RealType, 2, 2>::Zero();

                    for (size_t i = 1; i < cbs; i++) {
                        grad_p += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);
                        grad_n += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                    }
                    Matrix<RealType, 2, 2> grad_sym_p = 0.5 * (grad_p + grad_p.transpose());
                    Matrix<RealType, 2, 2> grad_sym_n = 0.5 * (grad_n + grad_n.transpose());
                    auto vel_n = phi_HHO.transpose() * vel_cell_dofs_n;

                    auto vel_p = phi_HHO.transpose() * vel_cell_dofs_p; // added 26/07/2023

                    Matrix<RealType, 2, 1> phi_n = level_set_function.normal(pt);

                    RealType val_un_n = (vel_n).transpose() * (phi_n);
                    RealType val_up_n = (vel_p).transpose() * (phi_n);


                    auto val_p = (p_pos - p_neg);
                    Matrix<RealType, 2, 1> val_grad_u_n =
                            (2.0 * kappa_1 * grad_sym_n - 2.0 * kappa_2 * grad_sym_p) * (phi_n);
                    RealType val_u = (phi_n.transpose()) * val_grad_u_n;
                    phi_t(0) = -phi_n(1);
                    phi_t(1) = phi_n(0);

                    RealType val_un_t = (vel_n).transpose() * (phi_t);
                    RealType val_up_t = (vel_p).transpose() * (phi_t);

                    RealType t_val_u_n = (phi_t.transpose()) * val_grad_u_n;
//                    RealType val_u ;
//                    if( signbit(phi_n(0)) == signbit(grads_u_n(0)) && signbit(phi_n(1)) == signbit(grads_u_n(1)) )
//                        val_u = grads_u_n.norm();
//                    else
//                        val_u = -grads_u_n.norm();
                    point<RealType, 2> curv_var = typename Mesh::point_type(distance_pts, 0.0);
                    auto val_H = gamma * level_set_function.divergence(pt);
                    test_press_jump->add_data(curv_var, val_p);
                    test_gammaH->add_data(curv_var, val_H);
                    test_grad_vel_jump->add_data(curv_var, val_u);
                    test_grad_vel_t_n->add_data(curv_var, t_val_u_n);

                    test_veln_n->add_data(curv_var, val_un_n);
                    test_veln_t->add_data(curv_var, val_un_t);

                    test_velp_n->add_data(curv_var, val_up_n);
                    test_velp_t->add_data(curv_var, val_up_t);

                    force_pressure_avg += val_p / val_H;
                    force_pressure_max = std::max(force_pressure_max, std::abs(val_p / val_H));

                    force_gradVel_avg += val_u / val_H;
                    force_gradVel_max = std::max(force_gradVel_max, std::abs(val_u / val_H));


                    counter_pt_Gamma++;

                    RealType dist;

                    if (t == 1)
                        dist = 0.0;
                    else
                        dist = (parametric_interface(t + 1.0 / tot, pts, degree_curve) - p).norm();

                    distance_pts += dist;

                }
            }


        }

    } else {
//            tc2.tic();
        vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
        P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

        vel_cell_dofs = vel_locdata.head(cbs);



// NOT AGGLO CELL
        if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                auto phi_HHO = cb.eval_basis(ln_Qk);
                auto vel = phi_HHO.transpose() * vel_cell_dofs;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                i_local++;

            }

        } else // AGGLO CELL
        {
            for (size_t i_subcell = 0;
                 i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
        }
//            tc2.toc();
//            std::cout<<"time tc2 1 = "<<tc2<<std::endl;
//            tc2.tic();
        RealType kappa = test_case.parms.kappa_1;
        if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
            kappa = test_case.parms.kappa_2;

        auto qps = integrate(msh, cl, 2 * hdi_cell);
        for (auto &qp: qps) {
// Compute H1-error //
            auto t_dphi = cb.eval_gradients(qp.first);
            Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

            for (size_t i = 1; i < cbs; i++)
                grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

            Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
            Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
            H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
            auto t_phi = cb.eval_basis(qp.first);
            auto v = t_phi.transpose() * vel_cell_dofs;
            Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
            L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

            uT1_gp->add_data(qp.first, v(0));
            uT2_gp->add_data(qp.first, v(1));
//                uT_gp->add_data( qp.first, std::make_pair(v(0),v(1)) );
            if (interface_file) {

                interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

            }

// L2 - pressure - error //
            auto p_phi = pb.eval_basis(qp.first);
            RealType p_num = p_phi.dot(P_locdata);
            RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE
//auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
            L2_pressure_error += qp.second * p_diff * p_diff / kappa;

            p_gp->add_data(qp.first, p_num);
            if (level_set_function(qp.first, cl) > 0.0)
                p2_gp->add_data(qp.first, p_num);
            else
                p1_gp->add_data(qp.first, p_num);
        }
//            tc2.toc();
//            std::cout<<"time tc2 0 = "<<tc2<<std::endl;
    }


}


template<typename Mesh, typename Cell, typename LS, typename TC, typename RealType, typename ASS, typename BDRY, typename SOL, typename VEL, typename PP1, typename PP2, typename Function1, typename Function2, typename Function3>
void
post_processing_functionLS_fast_2(const Mesh &msh, Cell &cl, size_t hdi_cell, size_t hdi_face,
                                  LS &level_set_function, TC &test_case, ASS &assembler_sc, BDRY &bcs_vel,
                                  const SOL &sol, VEL &velocity, RealType &H1_error, RealType &L2_error, PP1 &uT1_gp,
                                  PP1 &uT2_gp,
                                  PP1 &p_gp, PP2 &interface_file, RealType &L2_pressure_error, RealType &l1_u_n_error,
                                  RealType &l2_u_n_error, RealType &linf_u_n_error, size_t &counter_interface_pts,
                                  size_t &degree,
                                  RealType &force_pressure_avg, RealType &force_pressure_max, size_t &counter_pt_Gamma,
                                  PP1 &test_gammaH,
                                  PP1 &test_press_jump, PP1 &test_grad_vel_jump, RealType &distance_pts,
                                  RealType &force_gradVel_max,
                                  RealType &force_gradVel_avg, PP1 &p1_gp, PP1 &p2_gp,
                                  Function1 &sol_vel, Function2 &sol_p, Function3 &vel_grad) {


    vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi_cell);
    RealType kappa_1 = test_case.parms.kappa_1;
    RealType kappa_2 = test_case.parms.kappa_2;

    cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi_face);
    auto cbs = cb.size();
    auto pbs = pb.size();


    level_set_function.cell_assignment(cl); // ----------------------------> TOGLIERE????
    test_case.test_case_cell_assignment(cl); // ----------------------------> TOGLIERE????

//    auto sol_vel = test_case.sol_vel;
//    auto sol_p = test_case.sol_p;
//    auto vel_grad = test_case.vel_grad;

    assembler_sc.set_dir_func(bcs_vel); // CAMBIA QUALCOSA?? // ----------------------------> TOGLIERE????


    Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
    Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
    Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;


    vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
    P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);

    vel_cell_dofs = vel_locdata.head(cbs);



// NOT AGGLO CELL
    if (level_set_function.subcells.size() < 1) {
//                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
//                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
        auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
        auto cl_old = velocity.msh.cells[offset_old];
        auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
        size_t i_local = 0;
        for (const auto &ln_Qk: Lagrange_nodes_Qk) {
            auto phi_HHO = cb.eval_basis(ln_Qk);
            auto vel = phi_HHO.transpose() * vel_cell_dofs;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
            i_local++;

        }

    } else // AGGLO CELL
    {
        for (size_t i_subcell = 0;
             i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
            auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
//std::cout<<"offset_old = "<<offset_old<<std::endl;
            auto cl_old = velocity.msh.cells[offset_old];
            auto Lagrange_nodes_Qk = cl_old.user_data.Lagrange_nodes_Qk;
//                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
            size_t i_local = 0;
            for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                auto phi_HHO = cb.eval_basis(ln_Qk);
                auto vel = phi_HHO.transpose() * vel_cell_dofs;
// velocity.sol_HHO.first(i_local,offset_old) = vel(0);
// velocity.sol_HHO.second(i_local,offset_old) = vel(1);
//std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                i_local++;

            }

        }
    }

    RealType kappa = test_case.parms.kappa_1;
    if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
        kappa = test_case.parms.kappa_2;

    auto qps = integrate(msh, cl, 2 * hdi_cell);
    for (auto &qp: qps) {
// Compute H1-error //
        auto t_dphi = cb.eval_gradients(qp.first);
        Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

        for (size_t i = 1; i < cbs; i++)
            grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

        Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
        Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
        H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

// Compute L2-error //
        auto t_phi = cb.eval_basis(qp.first);
        auto v = t_phi.transpose() * vel_cell_dofs;
        Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;

        L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

        uT1_gp->add_data(qp.first, v(0));
        uT2_gp->add_data(qp.first, v(1));
        if (interface_file) {

            interface_file << qp.first.x() << "   " << qp.first.y() << "   " << v(0) << "   " << v(1) << std::endl;

        }

// L2 - pressure - error //
        auto p_phi = pb.eval_basis(qp.first);
        RealType p_num = p_phi.dot(P_locdata);
        RealType p_diff = test_case.sol_p(qp.first) - p_num; // era test_case STE

        L2_pressure_error += qp.second * p_diff * p_diff / kappa;

        p_gp->add_data(qp.first, p_num);
        if (level_set_function(qp.first, cl) > 0.0)
            p2_gp->add_data(qp.first, p_num);
        else
            p1_gp->add_data(qp.first, p_num);
    }


}

template<typename Mesh, typename testType, typename meth>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_old(const Mesh &msh, size_t degree, meth method, testType test_case) {
    using RealType = typename Mesh::coordinate_type;

    auto level_set_function = test_case.level_set_;

    auto rhs_fun = test_case.rhs_fun;
    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;
    auto bcs_vel = test_case.bcs_vel;
    auto neumann_jump = test_case.neumann_jump;
    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


/************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    for (auto &cl: msh.cells) {
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

/************** SOLVE **************/
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

/************** POSTPROCESS **************/


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT_norm.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    for (auto &cl: msh.cells) {
        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());

                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);


/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;

                p_gp->add_data(qp.first, p_num);
            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;

                p_gp->add_data(qp.first, p_num);
            }
        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
//                H1_error += qp.second * kappa * inner_product(grad_diff , grad_diff);
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

                p_gp->add_data(qp.first, p_num);
            }
        }

    }

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(uT_l2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

// Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd <RealType> op(Mat);
// Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::LARGEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if (max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


// Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver <RealType, Spectra::SMALLEST_MAGN,
        Spectra::SparseSymMatProd<RealType>> min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if (min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

// compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


/*
template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_parallel(const Mesh& msh, size_t degree, meth method, testType test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad )
{
    using RealType = typename Mesh::coordinate_type;

    //auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"Interface isovalue = "<<iso_val_interface<<std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    timecounter tc_bis2 ;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler , time = "<<tc_bis2<<std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler_sc , time = "<<tc_bis2<<std::endl;
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&] (size_t  cell_ind){
        auto& cl = msh.cells[cell_ind];

    //for (auto& cl : msh.cells)
    //{
        // ADD BY STE
        timecounter tc_bis ;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);

        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 0 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 1 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 2 , time = "<<tc_bis<<std::endl;



    });

    tc_bis2.tic();
    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout<<"-------> TIME STOKES 3 , time = "<<tc_bis2<<std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;

    std::cout<<"sono qua 0.0"<<std::endl;
    size_t i_global = 0 ; // ADD BY STE
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


        // ADD BY STE
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;


            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


*/


template<typename Mesh, typename testType, typename meth>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface(const Mesh &msh, size_t degree, meth &method, testType &test_case, bool normal_analysis = FALSE) {
    using RealType = typename Mesh::coordinate_type;

    auto level_set_function = test_case.level_set_;

    auto rhs_fun = test_case.rhs_fun;
    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;
    auto bcs_vel = test_case.bcs_vel;
    auto neumann_jump = test_case.neumann_jump;
    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


/************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    for (auto &cl: msh.cells) {
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

/************** SOLVE **************/
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

/************** POSTPROCESS **************/


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT_norm.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;

    for (auto &cl: msh.cells) {
        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());

                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);



/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;
                p_gp->add_data(qp.first, p_num);


            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;
                p_gp->add_data(qp.first, p_num);
            }

            if (normal_analysis) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l2_u_n_error += pow(v_n, 2.0);
                    l1_u_n_error += std::abs(v_n);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }
            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_ex = test_case.sol_p(qp.first);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;

//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

                p_gp->add_data(qp.first, p_num);
            }
        }

    }

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

// Stefano: I dont want plots (in the code uTi_gp and p_gp still present). Just commented these.
    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(uT_l2_gp);

    postoutput.add_object(p_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (normal_analysis) {
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.linf_normal_vel = linf_u_n_error;
    }

    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


// Add by Stefano
        Eigen::BDCSVD <Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size() - 1);
        std::cout << "cond_numb = " << cond << std::endl;



// Erased by Stefano
/*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        */
// compute condition number
//RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
//std::cout << "sigma_max = " << sigma_max << "   sigma_min = " << sigma_min << "  cond = " << cond << std::endl;

    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth, typename Fonction>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_numerical_ls(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                  Fonction &level_set_function, bool normal_analysis = FALSE) {
    using RealType = typename Mesh::coordinate_type;

//    bool sym_grad = true ;
//
//    struct params<RealType> parms = test_case.parms;


    auto bcs_vel = test_case.bcs_vel;
    test_case.test_case_mesh_assignment(msh);

    timecounter tc;

    bool sc = true; // static condensation

    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;
//std::cout<<"WARNING: check integration points: it seems there is a repetition in agglomerated cells."<<std::endl; --> NOT TRUE, THE WEIGHTS ARE ZEROS!

/************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
// Dir condition out the for loop -> CHECK IT

    assembler_sc.set_dir_func(bcs_vel);
    for (auto &cl: msh.cells) {

        test_case.test_case_cell_assignment(cl);
//auto level_set_function = test_case.level_set_;
//test_case.refresh_lambdas(level_set_function, parms , sym_grad );

//auto rhs_fun = test_case.rhs_fun;
//auto sol_vel = test_case.sol_vel;
//auto sol_p = test_case.sol_p;
//auto vel_grad = test_case.vel_grad;
//auto bcs_vel = test_case.bcs_vel;
//auto neumann_jump = test_case.neumann_jump;




//std::cout<<"CHECK cl_refresh:"<<'\n'<<"---> CEll loop = "<<offset(msh,cl)<<" , refreshed cell = "<<offset(msh,test_case.upload_cl())<<std::endl;

        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

/************** SOLVE **************/
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

/************** POSTPROCESS **************/


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");
    auto uT_l2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT_norm.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
//    RealType    l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;
    RealType flux_interface = 0.0;
    RealType rise_vel0 = 0.0, rise_vel1 = 0.0, area_fin = 0.0;


    for (auto &cl: msh.cells) {
        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

//auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl);
//test_case.refresh_lambdas(level_set_function, parms , sym_grad );

        auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case.neumann_jump;

//assembler_sc.set_dir_func( bcs_vel);

//std::cout<<"CHECK cl_refresh:"<<'\n'<<"---> CEll loop = "<<offset(msh,cl)<<" , refreshed cell = "<<offset(msh,test_case.upload_cl())<<std::endl;

        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

//             if( cl.user_data.offset_subcells[0] == 83 || cl.user_data.offset_subcells[0] == 163 )
//             {
//                 std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<"cell = "<<offset(msh,cl)<<" , vertices:"<<std::endl;
//                 for(auto& pt:points(msh,cl))
//                     std::cout<<" pt = "<<pt;
//                 std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<'\n'<<"Interface points:"<<std::endl;
//                 for(auto& pt: cl.user_data.integration_msh.points)
//                     std::cout<<" pt = "<<pt;
//                 std::cout<<std::endl;
//             }

            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            RealType local_H1_err_cut_n = 0.;
            for (auto &qp: qps_n) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_1 * inner_product(grad_sym_diff, grad_sym_diff);
                local_H1_err_cut_n += qp.second * inner_product(grad_sym_diff, grad_sym_diff);


/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_1 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_1;
//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (NEGATIVE CUT) = "<<qp.second * p_diff * p_diff<<std::endl;

                p_gp->add_data(qp.first, p_num);


            }

//            std::cout<<"H1 local error (negative cut cell) = "<<local_H1_err_cut_n<<std::endl;
            RealType local_H1_err_cut_p = 0.;
            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);


            for (auto &qp: qps_p) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * test_case.parms.kappa_2 * inner_product(grad_sym_diff, grad_sym_diff);
                local_H1_err_cut_p += qp.second * inner_product(grad_sym_diff, grad_sym_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * test_case.parms.kappa_2 * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / test_case.parms.kappa_2;

//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (POSITIVE CUT) = "<<qp.second * p_diff * p_diff<<std::endl;
                p_gp->add_data(qp.first, p_num);
            }
//            std::cout<<"H1 local error (positive cut cell) = "<<local_H1_err_cut_p<<std::endl;

            if (normal_analysis) {
                auto qps = integrate_interface(msh, cl, level_set_function.level_set.degree_FEM + hdi.cell_degree(),
                                               element_location::ON_INTERFACE);
                for (auto &qp: qps) {
                    auto t_phi = cb.eval_basis(qp.first);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(qp.first);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    flux_interface += qp.second * std::abs(v_n);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;

                }


                auto qps_n = integrate(msh, cl, hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
                RealType partial_area = measure(msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for (auto &qp: qps_n) {
                    auto t_phi = cb.eval_basis(qp.first);
                    auto v = t_phi.transpose() * vel_cell_dofs_n;
                    rise_vel0 += qp.second * v[0];
                    rise_vel1 += qp.second * v[1];
                }


            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            RealType kappa = test_case.parms.kappa_1;
            if (location(msh, cl) == element_location::IN_POSITIVE_SIDE)
                kappa = test_case.parms.kappa_2;

            RealType local_H1_err_uncut = 0.;
            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
//                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                Matrix<RealType, 2, 2> grad_sym_diff = 0.5 * (grad_diff + grad_diff.transpose());
                H1_error += qp.second * kappa * inner_product(grad_sym_diff, grad_sym_diff);

                local_H1_err_uncut += qp.second * inner_product(grad_sym_diff, grad_sym_diff);
/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
//                L2_error += qp.second * sol_diff.dot(sol_diff);
                L2_error += qp.second * kappa * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));
                uT_l2_gp->add_data(qp.first, std::sqrt(v(0) * v(0) + v(1) * v(1)));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
//                L2_pressure_error += qp.second * p_diff * p_diff;
                L2_pressure_error += qp.second * p_diff * p_diff / kappa;

//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (UNCUT) = "<<qp.second * p_diff * p_diff<<std::endl;
                p_gp->add_data(qp.first, p_num);
            }
//            std::cout<<"H1 local error (uncut cell) = "<<local_H1_err_uncut<<std::endl;
            if (normal_analysis) {
                auto qps = integrate(msh, cl, degree + 1);

                RealType partial_area = measure(msh, cl);
                area_fin += partial_area;

                for (auto &qp: qps) {
                    auto t_phi = cb.eval_basis(qp.first);
                    auto v = t_phi.transpose() * vel_cell_dofs;
                    rise_vel0 += qp.second * v[0];
                    rise_vel1 += qp.second * v[1];
                }
            }
        }

    }


    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.add_object(uT_l2_gp);
    postoutput.write();


    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (normal_analysis) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.flux_interface = flux_interface;
        TI.linf_normal_vel = linf_u_n_error;
    }


    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << TI.l1_normal_vel << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << TI.linf_normal_vel << std::endl;
    std::cout << bold << green << "Flux interface:               " << flux_interface << std::endl;
    std::cout << bold << green << "Rise velocity x :               " << rise_vel0 / area_fin << std::endl;
    std::cout << bold << green << "Rise velocity y :               " << rise_vel1 / area_fin << std::endl;
    std::cout << bold << green << "|Rise velocity| :               "
              << std::abs(rise_vel0 / area_fin) + std::abs(rise_vel1 / area_fin) << std::endl;
    std::cout << bold << green << "Rise velocity :               " << rise_vel0 / area_fin + rise_vel1 / area_fin
              << std::endl;

    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


// Add by Stefano
        Eigen::BDCSVD <Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size() - 1);
        std::cout << "cond_numb = " << cond << std::endl;

/*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        */
        TI.cond = cond;
//std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
//         << sigma_min << "  cond = " << cond
//         << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth, typename Fonction, typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_numerical_ls_velocity(const Mesh &msh, size_t degree, meth &method, testType &test_case,
                                           Fonction &level_set_function, Velocity &velocity,
                                           bool normal_analysis = FALSE) {
    using RealType = typename Mesh::coordinate_type;

    bool sym_grad = true;

    struct params<RealType> parms = test_case.parms;


    auto bcs_vel = test_case.bcs_vel;
    test_case.test_case_mesh_assignment(msh);

    timecounter tc;

    bool sc = true; // static condensation

    std::cout
            << "WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."
            << std::endl;


/************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree + 1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
// Dir condition out the for loop -> CHECK IT

    assembler_sc.set_dir_func(bcs_vel);
    for (auto &cl: msh.cells) {

        test_case.test_case_cell_assignment(cl);

        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if (sc)
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if (sc)
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if (sc)
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

/************** SOLVE **************/
    tc.tic();
#if
    1
    SparseLU <SparseMatrix<RealType>> solver;
    Matrix<RealType, Dynamic, 1> sol;

    if (sc) {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    } else {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if
    0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params <RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if (sc) {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    } else {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

/************** POSTPROCESS **************/


    postprocess_output <RealType> postoutput;

    auto uT1_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT1.dat");
    auto uT2_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_uT2.dat");
    auto p_gp = std::make_shared < gnuplot_output_object < RealType > > ("interface_p.dat");

    tc.tic();
    RealType H1_error = 0.0;
    RealType L2_error = 0.0;
    RealType L2_pressure_error = 0.0;
    RealType l1_u_n_error = 0.0;
    RealType l2_u_n_error = 0.0;
    RealType linf_u_n_error = 0.0;
    size_t counter_interface_pts = 0;
    RealType flux_interface = 0.0;
    RealType rise_vel0 = 0.0, rise_vel1 = 0.0, area_fin = 0.0;


    for (auto &cl: msh.cells) {
        vector_cell_basis <cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis <cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl);

        auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case.neumann_jump;

//assembler_sc.set_dir_func( bcs_vel);


        if (location(msh, cl) == element_location::ON_INTERFACE) {
            if (sc) {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

//---------------------- Updating velocity field by STE ----------------------

            if (level_set_function.subcells.size() < 1)  // NOT AGGLO CELL
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    if (level_set_function(ln_Qk) > 0.0) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
                        i_local++;
                    } else {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
                        i_local++;
                    }
                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        if (level_set_function(ln_Qk) > 0.0) {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);

                            i_local++;
                        } else {
                            auto phi_HHO = cb.eval_basis(ln_Qk);
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local, offset_old) = vel(1);

                            i_local++;
                        }
                    }

                } // FINE FOR
            } // FINE ELSE


            auto qps_n = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto &qp: qps_n) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);


/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);


            }

            auto qps_p = integrate(msh, cl, 2 * hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto &qp: qps_p) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            if (normal_analysis) {
                for (auto &interface_point: cl.user_data.interface) {
                    auto t_phi = cb.eval_basis(interface_point);
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal(interface_point);
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n, 2.0);
                    linf_u_n_error = std::max(linf_u_n_error, std::abs(v_n));
                    counter_interface_pts++;
                }

                for (auto interface_point = cl.user_data.interface.begin();
                     interface_point < cl.user_data.interface.end() - 1; interface_point++) {
                    RealType segment = (*(interface_point + 1) - *interface_point).to_vector().norm();
                    auto t_phi0 = cb.eval_basis(*interface_point);
                    auto v0 = t_phi0.transpose() * vel_cell_dofs_p;
                    auto n0 = level_set_function.normal(*interface_point);
                    auto v_n0 = v0.dot(n0);

                    auto t_phi1 = cb.eval_basis(*(interface_point + 1));
                    auto v1 = t_phi1.transpose() * vel_cell_dofs_p;
                    auto n1 = level_set_function.normal(*(interface_point + 1));
                    auto v_n1 = v1.dot(n1);

                    flux_interface += segment * 0.5 * (v_n0 + v_n1);

                }

                auto qps = integrate(msh, cl, degree + 1, element_location::IN_NEGATIVE_SIDE);
                RealType partial_area = measure(msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for (auto &qp: qps) {
                    auto t_phi = cb.eval_basis(qp.first);
                    auto v = t_phi.transpose() * vel_cell_dofs_n;
                    rise_vel0 += qp.second * v[0];
                    rise_vel1 += qp.second * v[1];
                }


            }

        } else {
            if (sc) {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            } else {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);


//---------------------- Updating velocity field by STE ----------------------

            if (level_set_function.subcells.size() < 1) // NOT AGGLO CELL
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells[0] ==
                       level_set_function.agglo_LS_cl.user_data.offset_subcells[1]);
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                           velocity.degree_FEM);
                size_t i_local = 0;
                for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                    auto phi_HHO = cb.eval_basis(ln_Qk);
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local, offset_old) = vel(1);
                    i_local++;

                }

            } else // AGGLO CELL
            {
                for (size_t i_subcell = 0;
                     i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size(); i_subcell++) {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType, Mesh>(velocity.msh, cl_old,
                                                                                               velocity.degree_FEM);
                    size_t i_local = 0;
                    for (const auto &ln_Qk: Lagrange_nodes_Qk) {
                        auto phi_HHO = cb.eval_basis(ln_Qk);
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local, offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local, offset_old) = vel(1);
                        i_local++;

                    }

                }
            }


            auto qps = integrate(msh, cl, 2 * hdi.cell_degree());
            for (auto &qp: qps) {
/* Compute H1-error */
                auto t_dphi = cb.eval_gradients(qp.first);
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++)
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff, grad_diff);

/* Compute L2-error */
                auto t_phi = cb.eval_basis(qp.first);
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data(qp.first, v(0));
                uT2_gp->add_data(qp.first, v(1));

/* L2 - pressure - error */
                auto p_phi = pb.eval_basis(qp.first);
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p(qp.first) - p_num;
                auto p_prova = test_case.sol_p(qp.first);
//std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data(qp.first, p_num);
            }

            if (normal_analysis) {
                auto qps = integrate(msh, cl, degree + 1, element_location::IN_NEGATIVE_SIDE);

                RealType partial_area = measure(msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for (auto &qp: qps) {
                    auto t_phi = cb.eval_basis(qp.first);
                    auto v = t_phi.transpose() * vel_cell_dofs;
                    rise_vel0 += qp.second * v[0];
                    rise_vel1 += qp.second * v[1];
                }
            }
        }

    }



//postoutput.add_object(uT1_gp);
//postoutput.add_object(uT2_gp);
//postoutput.add_object(p_gp);
//postoutput.write();



    stokes_test_info <RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (normal_analysis) {
        TI.l1_normal_vel = l1_u_n_error / counter_interface_pts;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error / counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error;
    }
    std::cout << "Error H1(u) = " << TI.H1_vel << " , error L2(u) = " << TI.L2_vel << " , error L2(p) = " << TI.L2_p
              << "." << '\n' << "Error l2(u*n) = " << TI.l2_normal_vel << " , error linf(u*n) = " << TI.linf_normal_vel
              << "Flux interface = " << flux_interface << std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << TI.l1_normal_vel << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << TI.l2_normal_vel << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << TI.linf_normal_vel << std::endl;
    std::cout << bold << green << "Flux interface:               " << flux_interface << std::endl;
    std::cout << bold << green << "Rise velocity x :               " << rise_vel0 / area_fin << std::endl;
    std::cout << bold << green << "Rise velocity y :               " << rise_vel1 / area_fin << std::endl;
    std::cout << bold << green << "|Rise velocity| :               "
              << std::abs(rise_vel0 / area_fin) + std::abs(rise_vel1 / area_fin) << std::endl;
    std::cout << bold << green << "Rise velocity :               " << rise_vel0 / area_fin + rise_vel1 / area_fin
              << std::endl;

    if (0) {
/////////////// compute condition number
        SparseMatrix <RealType> Mat;
// Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


// Add by Stefano
        Eigen::BDCSVD <Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size() - 1);
        std::cout << "cond_numb = " << cond << std::endl;

/*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        */
        TI.cond = cond;
//std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
//         << sigma_min << "  cond = " << cond
//         << std::endl;
    } else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename T>
void
set_HHO_bdry_condition(Mesh &msh, bool bdry_bottom, bool bdry_right, bool bdry_up, bool bdry_left, T eps) {
    for (auto &fc: msh.faces) {
        if (fc.is_boundary) {

            auto pts = points(msh, fc);
            T pt_x0 = pts[0].x();
            T pt_x1 = pts[1].x();
            T pt_y0 = pts[0].y();
            T pt_y1 = pts[1].y();

            if (!bdry_bottom && (std::abs(pt_y0) < eps) && (std::abs(pt_y1) < eps))
                fc.bndtype = boundary::NEUMANN; // or boundary::NONE
            if (!bdry_right && (std::abs(pt_x0 - 1.0) < eps) && (std::abs(pt_x1 - 1.0) < eps))
                fc.bndtype = boundary::NEUMANN; // or boundary::NONE
            if (!bdry_up && (std::abs(pt_y0 - 1.0) < eps) && (std::abs(pt_y1 - 1.0) < eps))
                fc.bndtype = boundary::NEUMANN; // or boundary::NONE
            if (!bdry_left && (std::abs(pt_x0) < eps) && (std::abs(pt_x1) < eps))
                fc.bndtype = boundary::NEUMANN; // or boundary::NONE
//             else
//                 fc.bndtype = boundary::DIRICHLET; // Default value

        }
    }
}


template<typename FiniteSpace, typename Mesh, typename T>
void check_inlet(const Mesh &msh, FiniteSpace &fe_data, bool bdry_bottom, bool bdry_right, bool bdry_up, bool bdry_left,
                 T eps) {
    std::cout << "Checking inlet boundary condition for transport problem." << std::endl;
    std::vector < std::vector < std::pair < size_t, bool>>> connectivity_matrix = fe_data.connectivity_matrix;


    for (const auto &cl: msh.cells) {
        size_t cell_offset = offset(msh, cl);
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++) {
            auto pt = pts[i];
            size_t asm_map = connectivity_matrix[cell_offset][i].first;
            if (connectivity_matrix[cell_offset][i].second) {
                if (bdry_bottom && (std::abs(pt.y()) < eps))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                else if (bdry_right && (std::abs(pt.x() - 1.0) < eps))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                else if (bdry_up && (std::abs(pt.y() - 1.0) < eps))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                else if (bdry_left && (std::abs(pt.x()) < eps))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                else
                    fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE;

            } else
                fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE;

//            std::cout<<"fe_data.Dirichlet_boundary_inlet[asm_map] = "<<fe_data.Dirichlet_boundary_inlet[asm_map]<<std::endl;

        }
    }

}

template<typename FiniteSpace, typename Mesh, typename Vel_Field, typename T>
void check_inlet(const Mesh &msh, FiniteSpace &fe_data, const Vel_Field &u, T eps) {
    std::cout << "Checking inlet boundary condition for numerical flows." << std::endl;
    std::vector < std::vector < std::pair < size_t, bool>>> connectivity_matrix = fe_data.connectivity_matrix;


    for (const auto &cl: msh.cells) {
        size_t cell_offset = offset(msh, cl);
        auto pts = equidistriduted_nodes_ordered_bis<T, Mesh>(msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++) {
            auto pt = pts[i];
            size_t asm_map = connectivity_matrix[cell_offset][i].first;
            if (connectivity_matrix[cell_offset][i].second) {
                if ((u(pt, msh, cl).second > eps) && (pt.y() == 0.0))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                if ((u(pt, msh, cl).first < -eps) && (pt.x() == 1.0))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                if ((u(pt, msh, cl).second < -eps) && (pt.y() == 1.0))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                if ((u(pt, msh, cl).first > eps) && (pt.x() == 0.0))
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE;
                else
                    fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE;

            } else
                fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE;


        }
    }

}




//////////////////////////////////////////////////////////////////////////////////////////////////     MAIN      ////////////////////////////////////////////////////////////////////////////////////////////////////


// Interface Stokes Problem: Two-fluid problem STATIONARY

#if 0

int main(int argc, char **argv) {
    using RealType = double;
    RealType sizeBox = 2;
    size_t degree = 0;
    size_t int_refsteps = 4;
    size_t degree_FEM = 0;
    size_t degree_curve = 2;
    size_t degree_curvature = 1; // degree_curve -1 ;
    bool dump_debug = false;
    bool solve_interface = false;
    bool solve_fictdom = false;
    bool agglomeration = false;

    bool high_order = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic_mass_consistent = false;
    bool compressed = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params <RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

    mip.min_x = -sizeBox;
    mip.min_y = -sizeBox;
    mip.max_x = sizeBox;
    mip.max_y = sizeBox;
    size_t T_N = 0;
    int ch;
    while ((ch = getopt(argc, argv, "k:q:M:N:r:T:l:p:ifDAdhesgc")) != -1) {
        switch (ch) {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'p':
                degree_curvature = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
                break;

            case 'e':
                entropic = true;
                break;

            case 's':
                entropic_mass_consistent = true;
                break;

            case 'g':
                compressed = true;
                break;

            case 'c':
                cut_off_active = true;
                break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


/************** BUILD MESH **************/

    cuthho_poly_mesh <RealType> msh(mip);
    typedef cuthho_poly_mesh <RealType> Mesh;
    typedef RealType T;
//    typedef typename Mesh::point_type point_type;
    offset_definition(msh);

    std::cout << "Mesh size = " << mip.Nx << "x" << mip.Ny << std::endl;
    std::cout << "Number of refine interface points: r = " << int_refsteps << std::endl;

    if (high_order == true)
        std::cout << bold << green << "Transport problem high order with limiting (no inlet). " << reset << std::endl;
    else if (entropic == true)
        std::cout << bold << green << "Transport problem entropic mass lumped (no inlet). " << reset << std::endl;
    else if (entropic_mass_consistent == true)
        std::cout << bold << green << "Transport problem entropic mass consistent (no inlet). " << reset << std::endl;
    else if (compressed == true)
        std::cout << bold << green << "Transport problem high order compressed with limiting (no inlet). " << reset
                  << std::endl;
    else
        std::cout << bold << green << "Transport problem low order (no inlet).  " << reset << std::endl;

/************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType, Mesh>(msh, degree_FEM, mip);
    typedef Finite_Element<RealType, Mesh> FiniteSpace;
    std::cout << "Level Set (finite element approximation): Bernstein basis in space Q^{k_phi},  k_phi = " << degree_FEM
              << std::endl;

/**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh);
//typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t degree_gradient = degree_FEM;
    size_t degree_div = degree_FEM;
    std::cout << "Finite element space for gradient and divergence of the LS: grad deg = " << degree_gradient
              << " , div deg = " << degree_div << std::endl;

    auto fe_data_gradient = Finite_Element<RealType, Mesh>(msh, degree_gradient, mip);
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh);
    auto fe_data_div = Finite_Element<RealType, Mesh>(msh, degree_div, mip);
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh);


/************** ANALYTIC LEVEL SET FUNCTION  **************/


    bool circle = false, ellipse = true;
    bool flower = false;
    RealType radius_a, radius_b, radius;
    RealType x_centre = 0.0; // 0.5
    RealType y_centre = 0.0;
//T h = std::max( fe_data.hx , fe_data.hy) ;
    if (circle) {
        radius = 1.0 / 6.0; // I ALWAYS USED 1.0/9.0
    }

    if (ellipse) {
        radius = 1.0 / 3.0;
//        radius_a = 1.0/12.0; // 6, 12, 18 varying the domain size (1, x2, x3)
//        radius_b = 1.0/24.0; // 12, 24, 36 varying the domain size (1, x2, x3)
//        radius_a = 1.0/12.0;
//        radius_b = 1.0/24.0;
        radius_a = 1.0 / 3.0;
        radius_b = 1.0 / 6.0;
//        T eps_circ = 1e-4;
//        radius_a = 1.0/3.0-eps_circ;
//        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: " << M_PI * radius_a * radius_b
                  << std::endl;
        radius = sqrt(radius_a * radius_b);
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius << reset << std::endl;
    }




///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

// ------------------------------------ CIRCLE LEVEL SET ------------------------------------
//    std::cout<<"Initial interface: CIRCLE"<<std::endl;
//    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
//    typedef  circle_level_set<T> Fonction;

//    std::cout<<"Initial interface: CIRCLE"<<std::endl;
//    auto level_set_function_anal = circle_level_set_signed_distance<RealType>(radius, x_centre, y_centre , 0.1 ); // , 0.01 --> eps to smooth gradient
//    typedef  circle_level_set_signed_distance<T> Fonction;

// ------------------------------------ FLOWER LEVEL SET ------------------------------------

//    radius = 0.31 ;
//    std::cout<<"Initial interface: FLOWER"<<std::endl;
////    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
////    typedef  flower_level_set<T> Fonction;
//    flower = true ;
//
//    auto level_set_function_anal = flower_level_set_signed_distance<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
//    typedef  flower_level_set_signed_distance<T> Fonction;



// ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    std::cout << "Initial interface: ELLIPSE" << std::endl;
    auto level_set_function_anal = elliptic_level_set<RealType>(radius_a, radius_b, x_centre, y_centre);
    typedef elliptic_level_set <T> Fonction;

// ------------> OLD STUFF IMPLEMENTATION
//auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
//typedef  elliptic_distance_ls<T> Fonction;
//auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
//typedef  circle_distance_ls<T> Fonction;


    T curvature_anal = 1.0 / radius;

/**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t degree_velocity = degree_FEM; // std::max(degree + 1 , degree_FEM) ;


// **************** --------> STORING OF LAGRANGIAN NODES
    nodes_Lagrangian_cell_definition(msh, degree_velocity);


    auto fe_data_Lagrange = Finite_Element<RealType, Mesh>(msh, degree_velocity, mip);

    std::cout << "Velocity field: high order Lagrange basis: degree = " << degree_velocity << std::endl;
    auto u_projected = velocity_high_order<Mesh, FiniteSpace, T>(fe_data_Lagrange, msh);



/************** LEVEL SET FUNCTION DISCRETISATION **************/


//    if(high_order)
//        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
//    else
//        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

//    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;

//-------->  NEW FORMULATION
    auto level_set_function = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(fe_data, level_set_function_anal, msh,
                                                                                 fe_data_gradient, fe_data_div);
    typedef Level_set_berstein<Mesh, Fonction, FiniteSpace, T> Level_Set;
// ------------------  IF GRADIENT CONTINUOUS --------------
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//  ------------------ IF DIVERGENCE CONTINUOUS  ------------------
//    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

//-------->  OLD FORMULATION GRAD CONT
//    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//    level_set_function.gradient_continuous_setting() ;
//    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;


    std::cout << "Parametric interface: degree_curve = " << degree_curve << std::endl;
    auto curve = Interface_parametrisation_mesh1d(degree_curve);
    size_t degree_det_jac_curve = curve.degree_det; // 2*degree_curve INUTILE PER ORA
// integration CUT CELL degree += 2*degree_curve
// integration INTERFACE degree += degree_curve-1

//auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);





/************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh = Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i = crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


/************** INITIAL DATA INITIALISATION (t = 0) **************/
    T dt = 0.;
    T initial_area = 0., initial_mass = 0.;
    T d_a = 0.;
    T perimeter_initial = 0.;
    T centre_mass_x_inital = 0., centre_mass_y_inital = 0.;
    T max_u_n_val_old = 1e+6, max_u_n_val_new = 1e+5;
    T check = 10.0;
    T tot_time = 0.;

/************** BOUNDARY CONDITIONS **************/
    std::cout << yellow << bold << "INLET BDRY: UP AND DOWN FOR DIRCIRCHLET_eps FP" << reset << std::endl;
    bool bdry_bottom = true, bdry_up = true;
    bool bdry_left = false, bdry_right = false;
    check_inlet(msh, fe_data, bdry_bottom, bdry_right, bdry_up, bdry_left, 1e-14);


//************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
//detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration) {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
//detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
        set_integration_mesh(msh_i, degree_curve);
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);

        make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
        set_integration_mesh(msh_i, degree_curve); // TOLTO PER IL MOMENTO SENNO RADDOPPIO


    } else {
        detect_cut_cells3(msh_i, level_set_function);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
        set_integration_mesh(msh_i, degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << '\n' << std::endl;
    std::cout << "Agglomerated amount cells: " << msh_i.cells.size() << std::endl;
//    if (dump_debug)
//    {
//        dump_mesh(msh_i);
//        output_mesh_info(msh_i, level_set_function);
//    }



// IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

/************** UPDATING  LEVEL SET  AND VELOCITY  **************/
//    level_set_function.gradient_continuous_setting() ;
//    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;


// --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\

// IF grad cont -> normal cont -> (divergence disc) -> divergence cont
//auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad cont -> normal cont -> divergence disc
    auto ls_cell = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(level_set_function,
                                                                                                    msh_i);

// IF grad disc -> normal disc -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
// IF grad disc -> normal disc -> divergence disc -> normal and grad cont
//    auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

//-------------------------- OLD CASE LS_CELL --------------------------
//    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i );



    ls_cell.radius = radius;
    u_projected.set_agglo_mesh(msh_i);

    timecounter tc_initial;
    tc_initial.tic();



/************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector <T> max_val_u_n_time_para, L1_err_u_n_time_para, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time;
    std::vector <T> area_time, l1_err_u_n_time, linf_err_u_n_time, time_vec;
    std::vector <T> linf_der_time_interface, eccentricity_vec;
    std::vector <T> max_val_u_n_time, l1_err_curvature_time, linf_err_curvature_time;
    std::vector <T> circularity_time, circularity_time2, flux_interface_time, perimeter_time;
    std::vector <std::pair<T, T>> centre_mass_err_time, rise_velocity_time, min_max_vec;
    T circularity_ref = 0.0, perim_ref = 0.0, area_ref = 0.0;
    T l1_divergence_error = 0., l2_divergence_error = 0.;
    T linf_divergence_error = -10.;
    T L1_divergence_error = 0.;

    check_disc_curvature(msh_i, ls_cell, curvature_anal, degree_FEM);


    check_goal_quantities(msh_i, ls_cell, perimeter_initial, d_a, initial_area, centre_mass_x_inital,
                          centre_mass_y_inital, degree_FEM, initial_mass, flower, l1_divergence_error,
                          l2_divergence_error, linf_divergence_error, radius, L1_divergence_error, ellipse,
                          degree_curve, int_refsteps);



//------------------------ CHECK REFERENCE QUANTITIES ---------------------------//
//    reference_quantities_computation(perim_ref,area_ref,circularity_ref,radius, x_centre, y_centre,fe_data , msh, degree_curve,perimeter_initial , initial_area,int_refsteps , degree_det_jac_curve);

    T perimeter_anal = 2.0 * M_PI * sqrt((radius_a * radius_a + radius_b * radius_b) / 2.0); //   2.0*M_PI*radius ;
    std::cout << "Error( perimetre_anal - perimeter_initial ) = " << perimeter_anal - perimeter_initial << std::endl;
    T area_anal = M_PI * radius_a * radius_b; // M_PI*radius*radius ;
    std::cout << "Error( area_anal - initial_area ) = " << area_anal - initial_area << std::endl;

//    plot_curvature_normal_vs_curv_abscisse(msh_i, ls_cell, degree_curve,int_refsteps , 0 );

    plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, ls_cell, degree_curve, int_refsteps, 0,
                                                      degree_curvature); // NO FILTER


    tc_initial.toc();
//    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    circularity_time.push_back(M_PI * d_a / perimeter_initial);
    circularity_time2.push_back(4.0 * M_PI * initial_area / (perimeter_initial * perimeter_initial));
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(
            std::make_pair(centre_mass_x_inital / initial_area, centre_mass_y_inital / initial_area));
    time_vec.push_back(0);
    area_time.push_back(initial_area);

    min_max_vec.push_back(std::make_pair(level_set_function.phi_min, level_set_function.phi_max));

    l1_err_curvature_time.push_back(l1_divergence_error);
    linf_err_curvature_time.push_back(linf_divergence_error);

    T dt_M;
    T R_phi = radius;

    size_t tot_amount_transport_routine = 0;


    bool l2proj_para = false;

    bool l2proj = true;
    bool avg = false;
    bool disc = false;
    bool filter = false;

    Interface_parametrisation_mesh1d_global <Mesh> para_curve_cont(msh_i, degree_curve, degree_curvature);

// *********************** DERIVATIVE / NORMAL PARA *************************//
//------------- L2 cont curvature from parametric interface  r ---------- //
    para_curve_cont.make_L2_proj_para_derivative(msh_i);

//---------------------------- L2 global Normal from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_normal_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Normal from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_normal_disc(msh_i, ls_cell);
    }


// *********************** CURVATURE PARA *************************//

//------------- L2 cont curvature from parametric interface  r ---------- //
    if (l2proj_para)
        para_curve_cont.make_L2_proj_para_curvature(msh_i);



//---------------------------- L2 global Curvature from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_curvature_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Curvature from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_curvature_disc(msh_i, ls_cell);

    }
    if (filter) {
        std::cout << bold << yellow << "CURVATURE ANALYSIS PRE FILTER:" << '\n';
        para_curvature_error(msh_i, para_curve_cont, curvature_anal);
        para_curve_cont.make_smooth_filter_curvature();
        std::cout << bold << yellow << "CURVATURE ANALYSIS POST FILTER:" << '\n';
        para_curvature_error(msh_i, para_curve_cont, curvature_anal);

    }
    if (!filter) {
        std::cout << bold << yellow << "CURVATURE ANALYSIS PARA:" << '\n';
        para_curvature_error(msh_i, para_curve_cont, curvature_anal);
    }

// ******** TO FASTER THE SIMULATION, ERASED THE PLOTTINGS
    plotting_para_curvature_cont_time_fast(msh_i, para_curve_cont, degree_curve, degree_FEM, radius, 0, int_refsteps);

// output_mesh_info_ls_l_n(msh_i, para_curve_cont);

    T eps_dirichlet_cond = 1.0; //1.0/1.91008 ; // 0.01 -->  0.1


    std::cout << "Dirichlet eps Cond = " << eps_dirichlet_cond << std::endl;

// -----------------------------------------------------------------------------------------
// ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
// -----------------------------------------------------------------------------------------

    bool sym_grad = TRUE;
    auto prm = params<T>();
    prm.kappa_1 = 0.1;
    prm.kappa_2 = 1.0;
    T gamma = 0.0; // 0.05
// kappa_1 is negative domain (inner)
// kappa_2 is positive domain (outer)

    std::cout << "gamma = " << gamma << std::endl;


    std::cout << '\n' << bold << yellow << "HHO flow resolution." << reset << '\n' << std::endl;


// ------------------ OLD VERSIONS ------------------
//auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
// Non serve modificare Gamma = 1/2
//auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
//auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
// ------------- OLD GUILLAUME VERSIONS --------------
// auto test_case = make_test_case_stokes_1(msh, level_set_function);
// auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

// ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
//auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
// PRESSURE SIGN NOT CORRECT
// ---------------------- ESHELBY VERSION LEVEL SET - CORRECT ------------------------
//        auto test_case = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT
// -------------------- ESHELBY VERSION PARAMETRIC (DISC) - CORRECT -------------------
//        auto test_case = make_test_case_eshelby_correct_parametric(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT




// -------------------- ESHELBY VERSION PARAMETRIC (CONT) - CORRECT -------------------
// ---> THE OLD ONE FOR DIRICHLET =0
//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma ); // SIGN OF PRESSURE HAS TO BE CHANGED CONFORMING TO THE CHANGE  OF SIGN OF THE CURVATURE. HERE DONE: CORRECT 25/01/2021

// PARAMETRIC normal and curvature
//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont_DIRICHLET_eps( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond); // SIGN OF PRESSURE HAS TO BE CHANGED CONFORMING TO THE CHANGE  OF SIGN OF THE CURVATURE.

// LS normal and curvature

    auto test_case = make_test_case_eshelby_LS_eps_DIR_domSym(msh_i, ls_cell, para_curve_cont, prm, sym_grad, gamma,
                                                              eps_dirichlet_cond, sizeBox);
// auto test_case = make_test_case_eshelby_LS_eps_DIR( msh_i, ls_cell ,para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond);

// ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
//        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);
    T alfa1 = prm.kappa_2 / (prm.kappa_1 + prm.kappa_2);
    T alfa2 = prm.kappa_1 / (prm.kappa_1 + prm.kappa_2);
// alfa1 is negative domain (inner)
// alfa2 is positive domain (outer)
    auto method = make_sym_gradrec_stokes_interface_method_alfai(msh_i, 1.0, 0.0, test_case, sym_grad, alfa1, alfa2);
// -------------------- HHO METHOD FOR DISC PARAMETRIC INTERFACE  -----------------------
//         auto method = make_sym_gradrec_stokes_interface_method_ref_pts(msh_i, 1.0, 0.0, test_case, sym_grad);

// -------------------- HHO METHOD FOR CONT PARAMETRIC INTERFACE  -----------------------
//        auto method_prova = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh_i, 1.0, 0.0, test_case_prova, sym_grad); // WITH H_p  I use this!!!!




//  ******************** - HHO RESOLUTION - ********************
    if (solve_interface) {
// ----------------- HHO RESOLUTION OLD CASE  --------------------------
//            TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
//            run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

// ----------------- HHO RESOLUTION LS / PARAMETRIC DISC  ---------------------
//            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW

// ----------------- HHO RESOLUTION PARAMETRIC CONT  --------------------------
//             run_cuthho_interface_velocity_new(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
//            run_cuthho_interface_velocity_new_post_processing(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , 0); // FOR PARAMETRIC H_p
//            run_cuthho_interface_velocity_fast(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // CORRECT BUT DOEST NOT COMPUTE ERRORS

        run_cuthho_interface_velocity_new_post_processingLS(msh_i, degree, method, test_case, ls_cell, u_projected,
                                                            sym_grad, 0, 1); // FOR LS H
    }
//        testing_velocity_field(msh , u_projected) ;
/************************************ FEM -  PRE-PROCESSING ******************************************/
// ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
    if (0)
        std::cout << bold << green
                  << "CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"
                  << reset << std::endl;

    if (1) //1 FIRST RESULT WITH THIS
    {
        std::cout << '\n' << "Smoothing operator from velocity HHO to FE (continuity imposed): geometrical average."
                  << std::endl;
        u_projected.smooth_converting_into_FE_formulation(u_projected.sol_HHO);
    }
    if (0) {
        std::cout << '\n' << "------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM." << std::endl;
        u_projected.converting_into_FE_formulation(u_projected.sol_HHO);
    }
    if (0) {
        std::cout << '\n' << "------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM." << std::endl;
        u_projected.L2_proj_into_FE_formulation(level_set_function, msh, method_transport_pb);
    }


//testing_velocity_field(msh , u_projected) ;
//auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
//u_prova.sol_HHO = u_projected.sol_HHO ;
//u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
//testing_velocity_field_L2projected(msh , u_prova) ;

    T rise_vel0 = 0.0, rise_vel1 = 0.0;
    T flux_interface = 0.0;


    T max_u_n_val_initial = 0.0;
    T max_u_n_val_abs_initial = 0.0;
    T l1_normal_interface_status_initial = 0.;

    T L1_normal_interface_status_initial = 0.;

    size_t counter_interface_pts_initial = 0;
    for (auto &cl: msh_i.cells) {
        if (cl.user_data.location == element_location::ON_INTERFACE) {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
            for (auto &qp: qps) {
                auto u_pt = u_projected(qp.first);

                auto ls_n_pt = ls_cell.normal(qp.first);
                T u_n_val = u_pt.first * ls_n_pt(0) + u_pt.second * ls_n_pt(1);
                L1_normal_interface_status_initial += qp.second * std::abs(u_n_val);
                max_u_n_val_abs_initial = std::max(max_u_n_val_abs_initial, std::abs(u_n_val));
                if (std::abs(u_n_val) == max_u_n_val_abs_initial)
                    max_u_n_val_initial = u_n_val;

                l1_normal_interface_status_initial += std::abs(u_n_val);
                counter_interface_pts_initial++;


            }

        }

    }
    l1_normal_interface_status_initial /= counter_interface_pts_initial;
    l1_err_u_n_time.push_back(l1_normal_interface_status_initial);
    linf_err_u_n_time.push_back(max_u_n_val_abs_initial);
//            linf_der_time_interface.push_back(0) ;
    max_val_u_n_time.push_back(max_u_n_val_initial);
    L1_err_u_n_time.push_back(L1_normal_interface_status_initial);

    std::cout << "------> The l1 error of u*n along the INTERFACE at INITIAL TIME is "
              << l1_normal_interface_status_initial << std::endl;

    std::cout << bold << green << "------> The linf error of u*n along the INTERFACE at INITIAL TIME is "
              << max_u_n_val_abs_initial << reset << std::endl;

    std::cout << "------> The L1 error of u*n along the INTERFACE at INITIAL TIME is "
              << L1_normal_interface_status_initial << std::endl;


    size_t degree_jacobian = para_curve_cont.degree_det;

    T L1_normal_interface_para = 0.0;
    T linf_u_n_para = 0.0;
    T max_u_n_val_para = 0.0;
    T l1_normal_interface_para = 0.0;
    size_t counter_interface_pts_para = 0;


    T area_para = 0.0;

    for (auto &cl: msh_i.cells) {

        if ((location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) ||
            (location(msh_i, cl) == element_location::ON_INTERFACE)) {
            u_projected.cell_assignment(cl);
            T partial_area = measure(msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            area_para += partial_area;

            size_t max_deg = std::max(degree_velocity, degree_FEM);
            auto qps_fin = integrate(msh_i, cl, max_deg, element_location::IN_NEGATIVE_SIDE);


            for (auto &qp: qps_fin) {
                auto u_pt = u_projected(qp.first);
                rise_vel0 += qp.second * u_pt.first;
                rise_vel1 += qp.second * u_pt.second;
            }

        }


        if (cl.user_data.location == element_location::ON_INTERFACE) {
            u_projected.cell_assignment(cl);
            auto global_cells_i = para_curve_cont.get_global_cells_interface(msh_i, cl);
            auto integration_msh = cl.user_data.integration_msh;
//                    auto degree_int = degree_curvature + degree_jacobian ;


            auto qps_un = edge_quadrature<T>(degree_jacobian + degree_curvature + degree_velocity);

            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++) {
                auto pts = points(integration_msh, integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell];

                for (auto &qp: qps_un) {
                    auto t = 0.5 * qp.first.x() + 0.5;

                    T jacobian = para_curve_cont.jacobian_cont(t, global_cl_i);
                    auto w = 0.5 * qp.second * jacobian;
                    auto p = para_curve_cont(t, global_cl_i);
                    auto pt = typename Mesh::point_type(p(0), p(1));
                    auto u_pt = u_projected(pt);
                    auto curve_n_pt = para_curve_cont.normal_cont(t, global_cl_i);
                    T flux = u_pt.first * curve_n_pt(0) + u_pt.second * curve_n_pt(1);
                    flux_interface += w * flux;

                    L1_normal_interface_para += w * std::abs(flux);
                    linf_u_n_para = std::max(linf_u_n_para, std::abs(flux));
                    if (std::abs(flux) == linf_u_n_para)
                        max_u_n_val_para = flux;

                    l1_normal_interface_para += std::abs(flux);
                    counter_interface_pts_para++;

                }
            }
        }
    }
    l1_normal_interface_para /= counter_interface_pts_para;
    l1_err_u_n_time_para.push_back(l1_normal_interface_para);
    linf_err_u_n_time_para.push_back(linf_u_n_para);
    L1_err_u_n_time_para.push_back(L1_normal_interface_para);
    max_val_u_n_time_para.push_back(max_u_n_val_para);
    flux_interface_time.push_back(flux_interface);
    rise_velocity_time.push_back(std::make_pair(rise_vel0 / area_para, rise_vel1 / area_para));

    std::cout << "------> The l1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
              << l1_normal_interface_para << std::endl;

    std::cout << bold << yellow << "------> The linf error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
              << linf_u_n_para << reset << std::endl;

    std::cout << "------> The L1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
              << L1_normal_interface_para << std::endl;


    tc_tot.toc();
    std::cout << "Simulation machine time t = " << tc_tot << std::endl;

    return 0;
}

#endif






// Interface Stokes Problem: Two-fluid problem STATIONARY
// Loop varying \mu and ellipse radii

#if 0

int main(int argc, char **argv) {
    using RealType = double;
    RealType sizeBox = 1.0;
    std::string folder = "simulation_mu_eps_1"
    size_t degree = 1;
    size_t int_refsteps = 4;
    size_t degree_FEM = 0;
    size_t degree_curve = 2;
    size_t degree_curvature = 1; // degree_curve -1 ;
    bool dump_debug = false;
    bool solve_interface = false;
    bool solve_fictdom = false;
    bool agglomeration = false;

    bool high_order = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic_mass_consistent = false;
    bool compressed = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params <RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

    mip.min_x = -sizeBox;
    mip.min_y = -sizeBox;
    mip.max_x = sizeBox;
    mip.max_y = sizeBox;
    size_t T_N = 0;
    int ch;
    while ((ch = getopt(argc, argv, "k:q:M:N:r:T:l:p:ifDAdhesgc")) != -1) {
        switch (ch) {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'p':
                degree_curvature = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
                break;

            case 'e':
                entropic = true;
                break;

            case 's':
                entropic_mass_consistent = true;
                break;

            case 'g':
                compressed = true;
                break;

            case 'c':
                cut_off_active = true;
                break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    std::vector <RealType> int_refstepsVec{0};
    std::vector <RealType> degree_curveVec{4};
    std::vector <RealType> mu_vec{0.01, 0.1, 1.0, 10.0, 100.0}; // 0.01,0.1,1,10,100
    std::vector <RealType> radius_a_vec{1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0};
    std::vector <RealType> radius_b_vec{1.0 / 6.0, 2.0 / 9.0, 4.0 / 15.0, 10.0 / 57.0, 10.0 / 33.0, 4.0 / 21.0};


    int nOfRadii = radius_a_vec.size();

    std::vector <RealType> testCaseGamma{0.0, 1.0}; // {1.0};
    std::vector <RealType> testCaseEps{1.0, 0.0}; // {0.0};

    int nOfTestCases = testCaseGamma.size();
    size_t counter_tests = 0;
    for (auto mu: mu_vec) // for (auto int_refsteps1 : int_refstepsVec) //  for (auto mu : mu_vec)
    {
// auto mu = mu_vec.at(0);
// int R_i = 0 ;
        int_refsteps = int_refstepsVec.at(0); // int_refsteps1;
        for (int iTestCase = 0; iTestCase < nOfTestCases; iTestCase++) {
            RealType gamma = testCaseGamma.at(iTestCase);
            RealType eps_dirichlet_cond = testCaseEps.at(iTestCase);

            for (int R_i = 0; R_i <
                              nOfRadii; R_i++) // for (auto degree_curve1 : degree_curveVec) // for (int R_i = 0 ; R_i < nOfRadii ; R_i++)
            {
                degree_curve = degree_curveVec.at(0); //  degree_curve1;
/************** BUILD MESH **************/

                cuthho_poly_mesh <RealType> msh(mip);
                typedef cuthho_poly_mesh <RealType> Mesh;
                typedef RealType T;
                offset_definition(msh);
                std::cout << "Mesh size = " << mip.Nx << "x" << mip.Ny << std::endl;
                std::cout << "Number of refine interface points: r = " << int_refsteps << std::endl;
/************** FINITE ELEMENT INITIALIZATION **************/
                auto fe_data = Finite_Element<RealType, Mesh>(msh, degree_FEM, mip);
                typedef Finite_Element<RealType, Mesh> FiniteSpace;
                std::cout << "Level Set (finite element approximation): Bernstein basis in space Q^{k_phi},  k_phi = "
                          << degree_FEM << std::endl;

/**************************************TRANSPORT PROBLEM METHOD *****************************************/
// auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
                size_t degree_gradient = degree_FEM;
                size_t degree_div = degree_FEM;
                std::cout << "Finite element space for gradient and divergence of the LS: grad deg = "
                          << degree_gradient << " , div deg = " << degree_div << std::endl;

                auto fe_data_gradient = Finite_Element<RealType, Mesh>(msh, degree_gradient, mip);
                auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh);
                auto fe_data_div = Finite_Element<RealType, Mesh>(msh, degree_div, mip);
// auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;

/************** ANALYTIC LEVEL SET FUNCTION  **************/
                bool circle = false, ellipse = true;
                bool flower = false;
                RealType radius_a, radius_b, radius;
                RealType x_centre = 0.0; // 0.5
                RealType y_centre = 0.0;
                if (circle) {
                    radius = 1.0 / 6.0;
                }
                if (ellipse) {

                    radius_a = radius_a_vec.at(R_i); // 1.0/3.0;
                    radius_b = radius_b_vec.at(R_i);
                    radius = sqrt(radius_a * radius_b);
                }

// -------------------------- ELLIPTIC LEVEL SET -----------------------------------
                std::cout << "Initial interface: ELLIPSE" << std::endl;
                auto level_set_function_anal = elliptic_level_set<RealType>(radius_a, radius_b, x_centre, y_centre);
                typedef elliptic_level_set <T> Fonction;
//std::cout<<"mu = "<<mu<<std::endl;
//std::cout<<"radius_a = "<<radius_a<<"radius_b = "<<radius_b<<std::endl;
                T curvature_anal = 1.0 / radius;

/**************  VELOCITY FIELD  INITIALISATION  **************/

                size_t degree_velocity = degree_FEM;
// **************** --------> STORING OF LAGRANGIAN NODES
                nodes_Lagrangian_cell_definition(msh, degree_velocity);


                auto fe_data_Lagrange = Finite_Element<RealType, Mesh>(msh, degree_velocity, mip);

                auto u_projected = velocity_high_order<Mesh, FiniteSpace, T>(fe_data_Lagrange, msh);

/************** LEVEL SET FUNCTION DISCRETISATION **************/
                auto level_set_function = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(fe_data,
                                                                                             level_set_function_anal,
                                                                                             msh, fe_data_gradient,
                                                                                             fe_data_div);
                typedef Level_set_berstein<Mesh, Fonction, FiniteSpace, T> Level_Set;
// ------------------  IF GRADIENT CONTINUOUS --------------
                level_set_function.gradient_continuous_setting(method_transport_pb_grad);
                auto curve = Interface_parametrisation_mesh1d(degree_curve);
                size_t degree_det_jac_curve = curve.degree_det;

/************** MESH INITIALISATION FOR ROUTINE  **************/


                auto crr_mesh = Current_Mesh<Mesh>(msh);
                crr_mesh.current_mesh = msh;
                Mesh msh_i = crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
                offset_definition(msh_i);

/************** INITIAL DATA INITIALISATION (t = 0) **************/
                T dt = 0.;
                T initial_area = 0., initial_mass = 0.;
                T d_a = 0.;
                T perimeter_initial = 0.;
                T centre_mass_x_inital = 0., centre_mass_y_inital = 0.;
                T max_u_n_val_old = 1e+6, max_u_n_val_new = 1e+5;
                T check = 10.0;
                T tot_time = 0.;

/************** BOUNDARY CONDITIONS **************/
                std::cout << yellow << bold << "INLET BDRY: UP AND DOWN FOR DIRCIRCHLET_eps FP" << reset << std::endl;
                bool bdry_bottom = true, bdry_up = true;
                bool bdry_left = false, bdry_right = false;
                check_inlet(msh, fe_data, bdry_bottom, bdry_right, bdry_up, bdry_left, 1e-14);


//************ DO cutHHO MESH PROCESSING **************
                tc.tic();
                detect_node_position3(msh_i, level_set_function); // In cuthho_geom
                detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

                if (agglomeration) {
                    detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                    refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
                    set_integration_mesh(msh_i, degree_curve);
                    detect_cell_agglo_set(msh_i, level_set_function);
                    make_neighbors_info_cartesian(msh_i);

                    make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
                    set_integration_mesh(msh_i, degree_curve);


                } else {
                    detect_cut_cells3(msh_i, level_set_function);
                    refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
                    set_integration_mesh(msh_i, degree_curve);
                }

                tc.toc();
                std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << '\n' << std::endl;
                std::cout << "Agglomerated amount cells: " << msh_i.cells.size() << std::endl;
                output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

/************** UPDATING  LEVEL SET  AND VELOCITY  **************/
                level_set_function.gradient_continuous_setting(method_transport_pb_grad);
// -------------- LS_CELL: CHOICE OF DISC/CONT ----------------------------- \\
                // IF grad cont -> normal cont -> divergence disc
                auto ls_cell = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(
                        level_set_function, msh_i);
                ls_cell.radius = radius;
                u_projected.set_agglo_mesh(msh_i);

                timecounter tc_initial;
                tc_initial.tic();



/************** PLOTTINGS + GOAL QUANTITIES  **************/
                std::vector <T> max_val_u_n_time_para, L1_err_u_n_time_para, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time;
                std::vector <T> area_time, l1_err_u_n_time, linf_err_u_n_time, time_vec;
                std::vector <T> linf_der_time_interface, eccentricity_vec;
                std::vector <T> max_val_u_n_time, l1_err_curvature_time, linf_err_curvature_time;
                std::vector <T> circularity_time, circularity_time2, flux_interface_time, perimeter_time;
                std::vector <std::pair<T, T>> centre_mass_err_time, rise_velocity_time, min_max_vec;
                T circularity_ref = 0.0, perim_ref = 0.0, area_ref = 0.0;
                T l1_divergence_error = 0., l2_divergence_error = 0.;
                T linf_divergence_error = -10.;
                T L1_divergence_error = 0.;

                bool l2proj_para = false;

                bool l2proj = true;
                bool avg = false;
                bool disc = false;
                bool filter = false;

                Interface_parametrisation_mesh1d_global <Mesh> para_curve_cont(msh_i, degree_curve, degree_curvature);

// *********************** DERIVATIVE / NORMAL PARA *************************//
//------------- L2 cont curvature from parametric interface  r ---------- //
                para_curve_cont.make_L2_proj_para_derivative(msh_i);

//---------------------------- L2 global Normal from LS  ----------------------- //
                if (l2proj) {
                    if (!disc)
                        para_curve_cont.make_L2_proj_para_normal(msh_i, ls_cell);
                    else
                        para_curve_cont.make_L2_proj_para_normal_disc(msh_i, ls_cell);
                }
//---------------------------- Avg Normal from LS  ---------------------------- //
                if (avg) {
                    if (!disc)
                        para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
                    else
                        para_curve_cont.make_avg_L2_local_proj_para_normal_disc(msh_i, ls_cell);
                }


// *********************** CURVATURE PARA *************************//

//------------- L2 cont curvature from parametric interface  r ---------- //
                if (l2proj_para)
                    para_curve_cont.make_L2_proj_para_curvature(msh_i);



//---------------------------- L2 global Curvature from LS  ----------------------- //
                if (l2proj) {
                    if (!disc)
                        para_curve_cont.make_L2_proj_para_curvature(msh_i, ls_cell);
                    else
                        para_curve_cont.make_L2_proj_para_curvature_disc(msh_i, ls_cell);
                }
//---------------------------- Avg Curvature from LS  ---------------------------- //
                if (avg) {
                    if (!disc)
                        para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
                    else
                        para_curve_cont.make_avg_L2_local_proj_para_curvature_disc(msh_i, ls_cell);

                }
                if (filter) {
                    std::cout << bold << yellow << "CURVATURE ANALYSIS PRE FILTER:" << '\n';
                    para_curvature_error(msh_i, para_curve_cont, curvature_anal);
                    para_curve_cont.make_smooth_filter_curvature();
                    std::cout << bold << yellow << "CURVATURE ANALYSIS POST FILTER:" << '\n';
                    para_curvature_error(msh_i, para_curve_cont, curvature_anal);

                }
                if (!filter) {
                    std::cout << bold << yellow << "CURVATURE ANALYSIS PARA:" << '\n';
                    para_curvature_error(msh_i, para_curve_cont, curvature_anal);
                }



// T eps_dirichlet_cond = 0.0 ;
                std::cout << "Dirichlet eps Cond = " << eps_dirichlet_cond << std::endl;

// -----------------------------------------------------------------------------------------
// ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
// -----------------------------------------------------------------------------------------

                bool sym_grad = TRUE;
                auto prm = params<T>();
                prm.kappa_1 = mu; // 100.0;
                prm.kappa_2 = 1.0;
// T gamma =  1.0;
// kappa_1 is negative domain (inner)
// kappa_2 is positive domain (outer)

                std::cout << "gamma = " << gamma << std::endl;
                std::cout << '\n' << bold << yellow << "HHO flow resolution." << reset << '\n' << std::endl;

// -------------- ESHELBY VERSION PARAMETRIC (CONT) -------------------
// LS normal and curvature
                auto test_case = make_test_case_eshelby_LS_eps_DIR_domSym(msh_i, ls_cell, para_curve_cont, prm,
                                                                          sym_grad, gamma, eps_dirichlet_cond, sizeBox);
// ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
                T alfa1 = prm.kappa_2 / (prm.kappa_1 + prm.kappa_2); // alfa1 is negative domain (inner)
                T alfa2 = prm.kappa_1 / (prm.kappa_1 + prm.kappa_2); // alfa2 is positive domain (outer)
                auto method = make_sym_gradrec_stokes_interface_method_alfai(msh_i, 1.0, 0.0, test_case, sym_grad,
                                                                             alfa1, alfa2);




//  ******************** - HHO RESOLUTION - ********************
// run_cuthho_interface_velocity_new_post_processingLS(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , counter_tests, 1);
// new - 27 07 2023 - calculation tangential velocity at interface + separation of pos and neg component
                run_cuthho_interface_velocity_complete(msh_i, degree, method, test_case, ls_cell, u_projected, sym_grad,
                                                       counter_tests, 1, folder);

                counter_tests++;
                std::cout << "Test number = " << counter_tests << std::endl;
                std::cout << "Case: mu = " << mu << ", gamma = " << gamma << ", eps = " << eps_dirichlet_cond
                          << std::endl;
                std::cout << "Ra = " << radius_a << ", Rb = " << radius_b << std::endl;
            } // R_i loop


        } // test case gamma vs eps

    } // mu loop





    tc_tot.toc();
    std::cout << "Simulation machine time t = " << tc_tot << std::endl;

    return 0;
}

#endif







// Interface Stokes Problem: Two-fluid problem with FIXED POINT
// -------- Code paper: interface evolution under shear flow - perturbed flow - null flow

#if 1

int main(int argc, char **argv) {
    using RealType = double;
    RealType sizeBox = 0.5;

    std::string folder = "simu_weightCircle_";
    int time_gap = 20;


    size_t degree = 1;
    size_t int_refsteps = 0; // 4
    size_t degree_FEM = 2;
    size_t degree_curve = 2;
    size_t degree_curvature = 1; // degree_curve -1 ;
    bool dump_debug = false;
    bool solve_interface = true;
    bool solve_fictdom = false;
    bool agglomeration = true;

    bool high_order = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic_mass_consistent = false;
    bool compressed = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params <RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

    mip.min_x = -sizeBox;
    mip.min_y = -sizeBox;
    mip.max_x = sizeBox;
    mip.max_y = sizeBox;


    size_t T_N = 10000;
    int ch;
    while ((ch = getopt(argc, argv, "k:q:M:N:r:T:l:p:ifDAdhesgc")) != -1) {
        switch (ch) {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'p':
                degree_curvature = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
                break;

            case 'e':
                entropic = true;
                break;

            case 's':
                entropic_mass_consistent = true;
                break;

            case 'g':
                compressed = true;
                break;

            case 'c':
                cut_off_active = true;
                break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


/************** BUILD MESH **************/

    cuthho_poly_mesh <RealType> msh(mip);
    typedef cuthho_poly_mesh <RealType> Mesh;
    typedef RealType T;
//    typedef typename Mesh::point_type point_type;
    offset_definition(msh);

    std::cout << "Mesh size = " << mip.Nx << "x" << mip.Ny << std::endl;
    std::cout << "Number of refine interface points: r = " << int_refsteps << std::endl;


    folder = folder + std::to_string(mip.Nx) + "/";

    if (high_order == true)
        std::cout << bold << green << "Transport problem high order with limiting (no inlet). " << reset << std::endl;
    else if (entropic == true)
        std::cout << bold << green << "Transport problem entropic mass lumped (no inlet). " << reset << std::endl;
    else if (entropic_mass_consistent == true)
        std::cout << bold << green << "Transport problem entropic mass consistent (no inlet). " << reset << std::endl;
    else if (compressed == true)
        std::cout << bold << green << "Transport problem high order compressed with limiting (no inlet). " << reset
                  << std::endl;
    else
        std::cout << bold << green << "Transport problem low order (no inlet).  " << reset << std::endl;

/************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType, Mesh>(msh, degree_FEM, mip);
    typedef Finite_Element<RealType, Mesh> FiniteSpace;
    std::cout << "Level Set (finite element approximation): Bernstein basis in space Q^{k_phi},  k_phi = " << degree_FEM
              << std::endl;

/**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh);
//typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t degree_gradient = degree_FEM;
    size_t degree_div = degree_FEM;
    std::cout << "Finite element space for gradient and divergence of the LS: grad deg = " << degree_gradient
              << " , div deg = " << degree_div << std::endl;

    auto fe_data_gradient = Finite_Element<RealType, Mesh>(msh, degree_gradient, mip);
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh);
    auto fe_data_div = Finite_Element<RealType, Mesh>(msh, degree_div, mip);
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh);


/************** ANALYTIC LEVEL SET FUNCTION  **************/


    bool circle = false, ellipse = false;
    bool flower = true;
    RealType radius_a, radius_b, radius;
    RealType x_centre = 0.0;
    RealType y_centre = 0.0; // 0.5 with all problems, but TGV 0.3
    T oscillation = 0.0;
//T h = std::max( fe_data.hx , fe_data.hy) ;
    if (circle) {
        radius = 1.0 / 3.0; // I ALWAYS USED 1.0/9.0
    }

    if (ellipse) {
        radius_a = 1.0 / 12.0;
        radius_b = 1.0 / 24.0;
//        T eps_circ = 1e-4;
//        radius_a = 1.0/3.0-eps_circ;
//        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: " << M_PI * radius_a * radius_b
                  << std::endl;
        radius = sqrt(radius_a * radius_b);
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius << reset << std::endl;
    }

    if (flower) {
        oscillation = 0.04;
        radius = 1.0 / 3.0;


    }




///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

// ------------------------------------ CIRCLE LEVEL SET ------------------------------------

// std::cout<<"Initial interface: CIRCLE"<<std::endl;
// auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
// typedef  circle_level_set<T> Fonction;


// ------------------------------------ FLOWER LEVEL SET ------------------------------------

    std::cout << "Initial interface: FLOWER" << std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, oscillation); //0.11
    typedef flower_level_set <T> Fonction;

// ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
//    std::cout<<"Initial interface: ELLIPSE"<<std::endl;
//    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
//    typedef  elliptic_level_set<T> Fonction;

// ------------> OLD STUFF IMPLEMENTATION
//auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
//typedef  elliptic_distance_ls<T> Fonction;
//auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
//typedef  circle_distance_ls<T> Fonction;




/**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t degree_velocity = degree_FEM; // std::max(degree + 1 , degree_FEM) ;


// **************** --------> STORING OF LAGRANGIAN NODES
    nodes_Lagrangian_cell_definition(msh, degree_velocity);


    auto fe_data_Lagrange = Finite_Element<RealType, Mesh>(msh, degree_velocity, mip);

    std::cout << "Velocity field: high order Lagrange basis: degree = " << degree_velocity << std::endl;
    auto u_projected = velocity_high_order<Mesh, FiniteSpace, T>(fe_data_Lagrange, msh);



/************** LEVEL SET FUNCTION DISCRETISATION **************/


//    if(high_order)
//        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
//    else
//        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

//    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;

//-------->  NEW FORMULATION
    auto level_set_function = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(fe_data, level_set_function_anal, msh,
                                                                                 fe_data_gradient, fe_data_div);
    typedef Level_set_berstein<Mesh, Fonction, FiniteSpace, T> Level_Set;
// ------------------  IF GRADIENT CONTINUOUS --------------
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//  ------------------ IF DIVERGENCE CONTINUOUS  ------------------
//    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

//-------->  OLD FORMULATION GRAD CONT
//    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//    level_set_function.gradient_continuous_setting() ;
//    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;




    std::cout << "Parametric interface: degree_curve = " << degree_curve << std::endl;
    auto curve = Interface_parametrisation_mesh1d(degree_curve);
    size_t degree_det_jac_curve = curve.degree_det; // 2*degree_curve INUTILE PER ORA
// integration CUT CELL degree += 2*degree_curve
// integration INTERFACE degree += degree_curve-1

//auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);





/************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh = Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i = crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


/************** INITIAL DATA INITIALISATION (t = 0) **************/
    T dt = 0.;
    T initial_area = 0., initial_mass = 0.;
    T d_a = 0.;
    T perimeter_initial = 0.;
    T centre_mass_x_inital = 0., centre_mass_y_inital = 0.;
    T max_u_n_val_old = 1e+6, max_u_n_val_new = 1e+5;
    T check = 10.0;
    T tot_time = 0.;

/************** BOUNDARY CONDITIONS **************/
    std::cout << yellow << bold << "INLET BDRY: UP AND DOWN FOR DIRCIRCHLET_eps FP" << reset << std::endl;
    bool bdry_bottom = false, bdry_up = false;
    bool bdry_left = false, bdry_right = false;
    check_inlet(msh, fe_data, bdry_bottom, bdry_right, bdry_up, bdry_left, 1e-14);


//************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
//detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration) {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
//detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
        set_integration_mesh(msh_i, degree_curve);
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);

        make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
        set_integration_mesh(msh_i, degree_curve); // TOLTO PER IL MOMENTO SENNO RADDOPPIO
//        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    } else {
        detect_cut_cells3(msh_i, level_set_function);
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << '\n' << std::endl;

    if (dump_debug) {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }



// IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

/************** UPDATING  LEVEL SET  AND VELOCITY  **************/
//    level_set_function.gradient_continuous_setting() ;
//    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;


// --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\

// IF grad cont -> normal cont -> (divergence disc) -> divergence cont
//auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad cont -> normal cont -> divergence disc
    auto ls_cell = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(level_set_function,
                                                                                                    msh_i);

// IF grad disc -> normal disc -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
// IF grad disc -> normal disc -> divergence disc -> normal and grad cont
//    auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

//-------------------------- OLD CASE LS_CELL --------------------------
//    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i );



    ls_cell.radius = radius;
    u_projected.set_agglo_mesh(msh_i);

    timecounter tc_initial;
    tc_initial.tic();



/************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector <T> max_val_u_n_time_para, L1_err_u_n_time_para, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time;
    std::vector <T> area_time, l1_err_u_n_time, linf_err_u_n_time, time_vec;
    std::vector <T> linf_der_time_interface, eccentricity_vec;
    std::vector <T> max_val_u_n_time, l1_err_curvature_time, linf_err_curvature_time;
    std::vector <T> circularity_time, circularity_time2, flux_interface_time, perimeter_time;
    std::vector <std::pair<T, T>> centre_mass_err_time, rise_velocity_time, min_max_vec;
    T circularity_ref = 0.0, perim_ref = 0.0, area_ref = 0.0;
    T l1_divergence_error = 0., l2_divergence_error = 0.;
    T linf_divergence_error = -10.;
    T L1_divergence_error = 0.;

    check_goal_quantities(msh_i, ls_cell, perimeter_initial, d_a, initial_area, centre_mass_x_inital,
                          centre_mass_y_inital, degree_FEM, initial_mass, flower, l1_divergence_error,
                          l2_divergence_error, linf_divergence_error, radius, L1_divergence_error, ellipse,
                          degree_curve, int_refsteps);



//------------------------ CHECK REFERENCE QUANTITIES ---------------------------//
    reference_quantities_computation(perim_ref, area_ref, circularity_ref, radius, x_centre, y_centre, fe_data, msh,
                                     degree_curve, perimeter_initial, initial_area, int_refsteps, degree_det_jac_curve);

//    plot_curvature_normal_vs_curv_abscisse(msh_i, ls_cell, degree_curve,int_refsteps , 0 );

    plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, ls_cell, degree_curve, int_refsteps, 0, degree_curvature);


    tc_initial.toc();
//    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    circularity_time.push_back(M_PI * d_a / perimeter_initial);
    circularity_time2.push_back(4.0 * M_PI * initial_area / (perimeter_initial * perimeter_initial));
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(
            std::make_pair(centre_mass_x_inital / initial_area, centre_mass_y_inital / initial_area));
    time_vec.push_back(0);
    area_time.push_back(initial_area);

    min_max_vec.push_back(std::make_pair(level_set_function.phi_min, level_set_function.phi_max));

    l1_err_curvature_time.push_back(l1_divergence_error);
    linf_err_curvature_time.push_back(linf_divergence_error);

    T dt_M;
    T R_phi = radius;

    size_t tot_amount_transport_routine = 0;


    bool l2proj_para = false;

    bool l2proj = true;
    bool avg = false;
    bool disc = false;
    bool filter = false;

    Interface_parametrisation_mesh1d_global <Mesh> para_curve_cont(msh_i, degree_curve, degree_curvature);

// *********************** DERIVATIVE / NORMAL PARA *************************//
//------------- L2 cont curvature from parametric interface  r ---------- //
    para_curve_cont.make_L2_proj_para_derivative(msh_i);

//---------------------------- L2 global Normal from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_normal_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Normal from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_normal_disc(msh_i, ls_cell);
    }


// *********************** CURVATURE PARA *************************//

//------------- L2 cont curvature from parametric interface  r ---------- //
    if (l2proj_para)
        para_curve_cont.make_L2_proj_para_curvature(msh_i);



//---------------------------- L2 global Curvature from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_curvature_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Curvature from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_curvature_disc(msh_i, ls_cell);

    }
    if (filter)
        para_curve_cont.make_smooth_filter_curvature();

// ******** TO FASTER THE SIMULATION, ERASED THE PLOTTINGS
    plotting_para_curvature_cont_time_fast(msh_i, para_curve_cont, degree_curve, degree_FEM, radius, 0, int_refsteps);

    T final_time = 8.0;

    T eps_dirichlet_cond = 0.0; //0.26; 0.52 ; // 0.01 -->  0.1

    for (size_t time_step = 0; time_step <= T_N; time_step++) {
        timecounter tc_iteration;
        tc_iteration.tic();
        std::cout << '\n' << bold << yellow << "Starting iteration numero  = " << time_step << " --> time t = "
                  << tot_time << reset << std::endl;
        std::cout << "Dirichlet eps Cond = " << eps_dirichlet_cond << std::endl;

// -----------------------------------------------------------------------------------------
// ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
// -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        T gamma = 1.0; // 0.05;


        savingVelocityLevelSet(level_set_function, u_projected);


        std::cout << '\n' << bold << yellow << "HHO flow resolution." << reset << '\n' << std::endl;


// ------------------ OLD VERSIONS ------------------
//auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
// Non serve modificare Gamma = 1/2
//auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
//auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
// ------------- OLD GUILLAUME VERSIONS --------------
// auto test_case = make_test_case_stokes_1(msh, level_set_function);
// auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

// ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
//auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
// PRESSURE SIGN NOT CORRECT
// ---------------------- ESHELBY VERSION LEVEL SET - CORRECT ------------------------
//        auto test_case = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT
// -------------------- ESHELBY VERSION PARAMETRIC (DISC) - CORRECT -------------------
//        auto test_case = make_test_case_eshelby_correct_parametric(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT




// -------------------- ESHELBY VERSION PARAMETRIC (CONT) - CORRECT -------------------
// domain  (0,1)^2 - null flow
//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );

// domain  (-a,a)^2 - shear flow
        auto test_case_prova = make_test_case_eshelby_parametric_cont_eps_DIR_domSym(msh_i, ls_cell, para_curve_cont,
                                                                                     prm, sym_grad, gamma,
                                                                                     eps_dirichlet_cond); // sizeBox

// domain  (0,1)^2 - shear flow

//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont_DIRICHLET_eps( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond);

// domain  (-a,a)^2 - new test case perturbated
// T perturbation = 0.5;
// auto test_case_prova = make_test_case_eshelby_parametric_cont_eps_perturbated_DIR_domSym( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond,perturbation );


// domain  (0,1)^2 - new test case perturbated
//     auto test_case_prova = make_test_case_shear_flow_perturbated( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond,perturbation );
//        auto test_case_prova = make_test_case_shear_y( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond,perturbation );
// New test case TGV - fixed point
//        auto test_case_prova = make_test_case_TGV_FPscheme( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond );



//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont_TGV_source( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );
// ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
//        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);
// -------------------- HHO METHOD FOR DISC PARAMETRIC INTERFACE  -----------------------
//         auto method = make_sym_gradrec_stokes_interface_method_perturbationref_pts(msh_i, 1.0, 0.0, test_case, sym_grad);


// -------------------- HHO METHOD FOR CONT PARAMETRIC INTERFACE  -----------------------
        auto method_prova = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh_i, 1.0, 0.0, test_case_prova,
                                                                                  sym_grad);




//  ******************** - HHO RESOLUTION - ********************
        if (solve_interface) {
// ----------------- HHO RESOLUTION OLD CASE  --------------------------
//            TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
//            run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

// ----------------- HHO RESOLUTION LS / PARAMETRIC DISC  ---------------------
//            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW

// ----------------- HHO RESOLUTION PARAMETRIC CONT  --------------------------
//             run_cuthho_interface_velocity_new(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
// run_cuthho_interface_velocity_fast(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // CORRECT BUT DOEST NOT COMPUTE ERRORS


            run_cuthho_interface_velocity_complete(msh_i, degree, method_prova, test_case_prova, ls_cell, u_projected,
                                                   sym_grad, time_step, time_gap, folder);


        }
//        testing_velocity_field(msh , u_projected) ;
/************************************ FEM -  PRE-PROCESSING ******************************************/
// ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if (0)
            std::cout << bold << green
                      << "CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"
                      << reset << std::endl;

        if (0) // method used in the paper - algebraic average
        {
            std::cout << '\n' << "Smoothing operator from velocity HHO to FE (continuity imposed): geometrical average."
                      << std::endl;
            u_projected.smooth_converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (1) // method used for the reviewers - weigth average
        {
            std::cout << '\n' << "Smoothing operator from velocity HHO to FE (continuity imposed): geometrical average."
                      << std::endl;
            u_projected.weight_converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (0) {
            std::cout << '\n' << "------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM." << std::endl;
            u_projected.converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (0) {
            std::cout << '\n' << "------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM." << std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function, msh, method_transport_pb);
        }


//testing_velocity_field(msh , u_projected) ;
//auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
//u_prova.sol_HHO = u_projected.sol_HHO ;
//u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
//testing_velocity_field_L2projected(msh , u_prova) ;

        T rise_vel0 = 0.0, rise_vel1 = 0.0;
        T flux_interface = 0.0;

        if (time_step == 0) {
            T max_u_n_val_initial = 0.0;
            T max_u_n_val_abs_initial = 0.0;
            T l1_normal_interface_status_initial = 0.;

            T L1_normal_interface_status_initial = 0.;

            size_t counter_interface_pts_initial = 0;
            for (auto &cl: msh_i.cells) {
                if (cl.user_data.location == element_location::ON_INTERFACE) {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);

                    auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity,
                                                   element_location::ON_INTERFACE);
                    for (auto &qp: qps) {
                        auto u_pt = u_projected(qp.first);

                        auto ls_n_pt = ls_cell.normal(qp.first);
                        T u_n_val = u_pt.first * ls_n_pt(0) + u_pt.second * ls_n_pt(1);
                        L1_normal_interface_status_initial += qp.second * std::abs(u_n_val);
                        max_u_n_val_abs_initial = std::max(max_u_n_val_abs_initial, std::abs(u_n_val));
                        if (std::abs(u_n_val) == max_u_n_val_abs_initial)
                            max_u_n_val_initial = u_n_val;

                        l1_normal_interface_status_initial += std::abs(u_n_val);
                        counter_interface_pts_initial++;


                    }

                }

            }
            l1_normal_interface_status_initial /= counter_interface_pts_initial;
            l1_err_u_n_time.push_back(l1_normal_interface_status_initial);
            linf_err_u_n_time.push_back(max_u_n_val_abs_initial);
//            linf_der_time_interface.push_back(0) ;
            max_val_u_n_time.push_back(max_u_n_val_initial);
            L1_err_u_n_time.push_back(L1_normal_interface_status_initial);

            std::cout << "------> The l1 error of u*n along the INTERFACE at INITIAL TIME is "
                      << l1_normal_interface_status_initial << std::endl;

            std::cout << bold << green << "------> The linf error of u*n along the INTERFACE at INITIAL TIME is "
                      << max_u_n_val_abs_initial << reset << std::endl;

            std::cout << "------> The L1 error of u*n along the INTERFACE at INITIAL TIME is "
                      << L1_normal_interface_status_initial << std::endl;


            size_t degree_curvature = para_curve_cont.dd_degree;
            size_t degree_jacobian = para_curve_cont.degree_det;

            T L1_normal_interface_para = 0.0;
            T linf_u_n_para = 0.0;
            T max_u_n_val_para = 0.0;
            T l1_normal_interface_para = 0.0;
            size_t counter_interface_pts_para = 0;


            T area_para = 0.0;

            for (auto &cl: msh_i.cells) {

                if ((location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) ||
                    (location(msh_i, cl) == element_location::ON_INTERFACE)) {
                    u_projected.cell_assignment(cl);
                    T partial_area = measure(msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                    area_para += partial_area;

                    size_t max_deg = std::max(degree_velocity, degree_FEM);
                    auto qps_fin = integrate(msh_i, cl, max_deg, element_location::IN_NEGATIVE_SIDE);


                    for (auto &qp: qps_fin) {
                        auto u_pt = u_projected(qp.first);
                        rise_vel0 += qp.second * u_pt.first;
                        rise_vel1 += qp.second * u_pt.second;
                    }

                }


                if (cl.user_data.location == element_location::ON_INTERFACE) {
                    u_projected.cell_assignment(cl);
                    auto global_cells_i = para_curve_cont.get_global_cells_interface(msh_i, cl);
                    auto integration_msh = cl.user_data.integration_msh;
//                    auto degree_int = degree_curvature + degree_jacobian ;


                    auto qps_un = edge_quadrature<T>(degree_jacobian + degree_curvature + degree_velocity);

                    for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++) {
                        auto pts = points(integration_msh, integration_msh.cells[i_cell]);
                        size_t global_cl_i = global_cells_i[i_cell];

                        for (auto &qp: qps_un) {
                            auto t = 0.5 * qp.first.x() + 0.5;

                            T jacobian = para_curve_cont.jacobian_cont(t, global_cl_i);
                            auto w = 0.5 * qp.second * jacobian;
                            auto p = para_curve_cont(t, global_cl_i);
                            auto pt = typename Mesh::point_type(p(0), p(1));
                            auto u_pt = u_projected(pt);
                            auto curve_n_pt = para_curve_cont.normal_cont(t, global_cl_i);
                            T flux = u_pt.first * curve_n_pt(0) + u_pt.second * curve_n_pt(1);
                            flux_interface += w * flux;

                            L1_normal_interface_para += w * std::abs(flux);
                            linf_u_n_para = std::max(linf_u_n_para, std::abs(flux));
                            if (std::abs(flux) == linf_u_n_para)
                                max_u_n_val_para = flux;

                            l1_normal_interface_para += std::abs(flux);
                            counter_interface_pts_para++;

                        }
                    }
                }
            }
            l1_normal_interface_para /= counter_interface_pts_para;
            l1_err_u_n_time_para.push_back(l1_normal_interface_para);
            linf_err_u_n_time_para.push_back(linf_u_n_para);
            L1_err_u_n_time_para.push_back(L1_normal_interface_para);
            max_val_u_n_time_para.push_back(max_u_n_val_para);
            flux_interface_time.push_back(flux_interface);
            rise_velocity_time.push_back(std::make_pair(rise_vel0 / area_para, rise_vel1 / area_para));

            std::cout << "------> The l1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << l1_normal_interface_para << std::endl;

            std::cout << bold << yellow
                      << "------> The linf error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << linf_u_n_para << reset << std::endl;

            std::cout << "------> The L1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << L1_normal_interface_para << std::endl;
        }
// -----------------------------------------------------------------------------------------
// ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
// -----------------------------------------------------------------------------------------


//------------- MACRO TIME STEP dt -------------
//(before checking if it is too big, I need to find the new interface)
        T dt_M_max = 0.1; // 0.1 ; //5e-2 ; //5e-2; // phi_h 1e-3 e dt_m^MAX = 1e-4 not enought (oscillation )

//if(tot_time < 0.75)
        T eps = 0.05; //1.0 ; // 0.05 ; // factor to be inside CFL stability zone IT WAS 0.4
        T dt_one_cell = time_step_CFL_new(u_projected, mip, eps);

// Stokes time step maximum
        T c2 = 2.0; // 2.0; // it was 1
        T eta = std::min(prm.kappa_1, prm.kappa_2);
        T dt_STK = time_step_STK(eta, gamma, mip, c2);
        dt_M = std::min(dt_one_cell, dt_STK);

// dt_M =  dt_M * 0.1 ; // add 23/09/2021

// ------> ADAPTIVE SCHEME
//        dt_M = dt_one_cell * 0.1 ;
//        dt_M = floorf(dt_M * 1000) / 1000;

//        T dt_M_max ;
//        if( std::max(mip.hx() , mip.hy() ) <= 16 )
//            dt_M_max = 0.1;
//        else if( std::max(mip.hx() , mip.hy() ) == 32 )
//            dt_M_max = 5e-2;
//        else
//            dt_M_max = 5e-2;



        dt = std::min(dt_M_max, dt_M); //5e-2 for mesh 32x32, 0.1 for  mesh 16x16, 8x8

        if (final_time < (dt + tot_time)) {
            std::cout << "Last step, dt_M changed to arrive at T." << std::endl;
            dt = final_time - tot_time;

        }
        int N_sub = 10; //N_sub = 20 for BOH, N_sub = 10 for  mesh 16x16, 8x8, 32x32
// ------> FIXED  SCHEME
//        dt_M =  8*1e-3; // FOR LS low phi_L order-> 8*1e-3; // FOR LS high order phi_H ->  2*1e-3;
//        dt = std::min(dt_one_cell , dt_M);
//        T N_sub = 20 ;  // N_sub = 20 for mesh 32x32, N_sub = 10 for  mesh 16x16,  N_sub = 40 for phi_H
//std::cout<<"dt1 is "<<dt1<<std::endl;


        std::cout << '\n' << "Macro time step dt_M = " << dt << ", dt_h = " << dt_one_cell << ", dt_STK = " << dt_STK
                  << std::endl;

// I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = dt / N_sub; //std::min(4*1e-4 , dt ) ;

// ------> ADAPTIVE SCHEME
// It is phi_L: > 1e-3 for 16x16 and 8x8  ; > 5e-4 for 32x32
// It is phi_H: > 1e-4 for 16x16 and 8x8  ; > 5e-4 for 32x32
        if (sub_dt > 1e-3) {
            sub_dt = 1e-3;
            N_sub = floor(dt / sub_dt); // N_sub varies between 10 and 100 depending on sub_dt

        }


        auto level_set_old = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(level_set_function);
        auto ls_old = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(level_set_old,
                                                                                                       msh_i);


        std::cout << "-----> Implemented sub time dt_m = " << sub_dt << std::endl;

// ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM SUB-ROUTINE: tilde{N} = " << N_sub
                  << "-----------" << reset << std::endl;
        timecounter tc_case_tr;
        tc_case_tr.tic();
        while (sub_time < sub_dt * N_sub) {
// std::pair<T,T> CFL_numb;
            if (high_order) {
//           CFL_numb = run_transport_high_order_FTC_M_lumped( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false );

                run_transport_high_order_FTC_M_consistent(level_set_function.msh, fe_data, level_set_function,
                                                          u_projected, method_transport_pb, sub_dt, false);

//            CFL_numb = run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONS_LIMITED( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false ); // CORRECT 25/01/21

            } else if (entropic) {
                run_transport_entropic_M_lumped_Ri_correct(level_set_function.msh, fe_data, level_set_function,
                                                           u_projected, method_transport_pb, sub_dt, false);
//             CFL_numb = run_transport_entropic_M_lumped ( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false );
//            CFL_numb = run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING ( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false ); // CORRECT 25/01/21
            } else {
//                if(degree_velocity == degree_FEM) // IT IS FASTER
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(level_set_function.msh, fe_data,
                                                                                   level_set_function, u_projected,
                                                                                   method_transport_pb,
                                                                                   sub_dt); // CORRECT 25/01/21
//                else // IT WORKS BUT IT'S MUCH SLOWER
//                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt;

        }
        tot_time += sub_time;

        tc_case_tr.toc();
        std::cout << yellow << bold << "----------- THE END OF TRANSPORT PROBLEM SUB-ROUTINE: machine time t = "
                  << tc_case_tr << " s -----------" << reset << std::endl;
        tot_amount_transport_routine += N_sub;

/**************************************************   POST-PROCESSING **************************************************/


// Updating continuous normal function
//            level_set_function.gradient_continuous_setting() ;
// IF GRADIENT CONTINUOUS
        level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//         // IF DIVERGENCE CONTINUOUS
//         level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

// Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i = crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration) {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom

            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
            set_integration_mesh(msh_i, degree_curve);

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
//refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
//refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
// make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            set_integration_mesh(msh_i, degree_curve);
        } else {
            move_nodes(msh_i, level_set_function);
            detect_cut_cells3(msh_i, level_set_function);
            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }


        tc.toc();
        std::cout << '\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

        if (dump_debug) {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

// TOLTO TO BE FASTER
        if (time_step % time_gap == 0) {
            output_mesh_info2_time(msh_i, level_set_function, tot_time, time_step, folder);
            testing_level_set_time(msh, level_set_function, tot_time, time_step, folder);
            plot_u_n_interface(msh_i, ls_cell, u_projected, time_step, folder);
            testing_velocity_field(msh, u_projected, time_step, folder);
        }
//        output_mesh_info2_time_fixed_mesh(msh_i, level_set_function,tot_time,time_step);
        testing_level_set(msh, level_set_function, folder);
// Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh(msh_i);


        T max_u_n_val = 0.0;
        T max_u_n_val_abs = 0.0;

        T diff_in_time_interface = 0.0;
        T l1_normal_interface_status = 0.;

        T L1_normal_interface_status = 0.;

        size_t counter_interface_pts = 0;
        for (auto &cl: msh_i.cells) {
            if (cl.user_data.location == element_location::ON_INTERFACE) {
                ls_cell.cell_assignment(cl);
                ls_old.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                for (auto &qp: qps) {
                    auto u_pt = u_projected(qp.first);
                    auto ls_n_pt = ls_cell.normal(qp.first);
                    T u_n_val = u_pt.first * ls_n_pt(0) + u_pt.second * ls_n_pt(1);
                    L1_normal_interface_status += qp.second * std::abs(u_n_val);
                    max_u_n_val_abs = std::max(max_u_n_val_abs, std::abs(u_n_val));

                    diff_in_time_interface = std::max(diff_in_time_interface,
                                                      (std::abs(ls_cell(qp.first) - ls_old(qp.first))) / sub_time);
                    if (std::abs(u_n_val) == max_u_n_val_abs)
                        max_u_n_val = u_n_val;

                    l1_normal_interface_status += std::abs(u_n_val);
                    counter_interface_pts++;

                }


            }
        }

        if (time_step == 0)
            max_u_n_val_new = max_u_n_val;

        if (time_step > 0) {
            max_u_n_val_old = max_u_n_val_new;
            max_u_n_val_new = max_u_n_val;
            std::cout << bold << yellow << "l^{inf} u*n(t^n) = " << max_u_n_val_old << " , l^{inf} u*n(t^{n+1}) = "
                      << max_u_n_val_new << reset << std::endl;
        }

        std::cout << "Number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;

        std::cout << "-----------------------> The l1 error of u*n over the INTERFACE, at time t = " << tot_time
                  << " is " << l1_normal_interface_status << reset << std::endl;

        std::cout << bold << green << "-----------------------> The linf error of u*n over the INTERFACE, at time t = "
                  << tot_time << " is " << max_u_n_val_abs << reset << std::endl;

        std::cout << "-----------------------> The L1 error of u*n over the INTERFACE, at time t = " << tot_time
                  << " is " << L1_normal_interface_status << reset << std::endl;

        std::cout << bold << green << "---> The linf error of (phi^{n+1}-phi{n})/dt over the INTERFACE, at time t = "
                  << tot_time << " is " << diff_in_time_interface << reset << std::endl;








// ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status;
/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

//if(check < 1e-8 )
//{
//    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
//    return 0;
//}





        T mass_fin = 0., area_fin = 0.;
        T centre_mass_x = 0., centre_mass_y = 0.;
        T l1_divergence_error_fin = 0., l2_divergence_error_fin = 0.;
        T linf_divergence_error_fin = 0.;
        T perimeter = 0.;
        T L1_divergence_error_fin = 0.;


        size_t counter_interface_pts_fin = 0.0;
//
//------------ Updating Parametric interface
        para_curve_cont.updating_parametric_interface(msh_i, ls_cell, l2proj, avg, l2proj_para, disc);

        if (filter) {
            plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, int_refsteps, para_curve_cont, time_step);
            para_curve_cont.make_smooth_filter_curvature();
        }

//        para_curve_cont.plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh, n_int);

        T L1_normal_interface_para = 0.0;
        T linf_u_n_para = 0.0;
        T max_u_n_val_para = 0.0;
        T l1_normal_interface_para = 0.0;
        size_t counter_interface_pts_para = 0;
        T max_curvature = 0;
        T min_curvature = 1e+6;
        plot_curvature_normal_vs_curv_abscisse(msh_i, ls_cell, degree_curve, int_refsteps, 1, folder);
        plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, degree_curve, int_refsteps, 1, degree_curvature,
                                                          para_curve_cont, folder);

//        check_goal_quantities_final_para( msh_i ,ls_cell, para_curve_tmp , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface, counter_interface_pts_fin,degree_curve,int_refsteps, L1_normal_interface_para,linf_u_n_para,max_u_n_val_para,l1_normal_interface_para,counter_interface_pts_para);

        check_goal_quantities_final_para_no_plot(msh_i, ls_cell, para_curve_cont, u_projected, perimeter, d_a, area_fin,
                                                 centre_mass_x, centre_mass_y, degree_FEM, mass_fin, degree_velocity,
                                                 l1_divergence_error_fin, l2_divergence_error_fin,
                                                 linf_divergence_error_fin, radius, L1_divergence_error_fin, 1,
                                                 rise_vel0, rise_vel1, flux_interface, counter_interface_pts_fin,
                                                 degree_curve, int_refsteps, L1_normal_interface_para, linf_u_n_para,
                                                 max_u_n_val_para, l1_normal_interface_para, counter_interface_pts_para,
                                                 max_curvature, min_curvature);

        std::cout << "PARA-FLUX at the INTERFACE, at time " << tot_time << " is " << flux_interface << std::endl;
//        std::cout<<"PARA-L1(un) at the INTERFACE, at time "<< tot_time <<" is " << L1_normal_interface_para <<std::endl;

        l1_normal_interface_para /= counter_interface_pts_para;
//        std::cout<<"PARA-l1(un) at the INTERFACE, at time "<< tot_time <<" is " << l1_normal_interface_para <<std::endl;
//        std::cout<<"PARA-linf(un) at the INTERFACE, at time "<< tot_time <<" is " << linf_u_n_para <<std::endl;
//        std::cout<<"PARA-linf(un) SIGNED at the INTERFACE, at time "<< tot_time <<" is " << max_u_n_val_para <<std::endl;

        l1_err_u_n_time_para.push_back(l1_normal_interface_para);
        linf_err_u_n_time_para.push_back(linf_u_n_para);
        L1_err_u_n_time_para.push_back(L1_normal_interface_para);
        max_val_u_n_time_para.push_back(max_u_n_val_para);

//        check_goal_quantities_final( msh_i , ls_cell , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);
//

        testing_level_set_max_min(msh, level_set_function, time_step, min_max_vec);


        l1_divergence_error_fin /= counter_interface_pts_fin;


        std::cout << "The l1 error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time << " is "
                  << l1_divergence_error_fin << std::endl;

        std::cout << bold << green << "The linf error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time
                  << " is " << linf_divergence_error_fin << reset << std::endl;

        std::cout << "The L1 error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time << " is "
                  << L1_divergence_error_fin << std::endl;








//        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

//        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0 * area_fin / M_PI);

        std::cout << "The CIRCULARITY (OLD), at time " << tot_time << " is " << M_PI * d_a / perimeter << std::endl;
        std::cout << "The CIRCULARITY, at time " << tot_time << " is "
                  << 4.0 * M_PI * area_fin / (perimeter * perimeter) << std::endl;
        std::cout << "Area at time step: " << tot_time << " is " << area_fin << std::endl;
//        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME " << tot_time << " IS "
                  << (area_fin - initial_area) / initial_area << reset << std::endl;
//        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: " << tot_time << " is " << " ( " << centre_mass_x / area_fin << " , "
                  << centre_mass_y / area_fin << " ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: " << tot_time << " is " << " ( "
                  << centre_mass_x / area_fin - centre_mass_x_inital / initial_area << " , "
                  << centre_mass_y / area_fin - centre_mass_y_inital / initial_area << " ). " << std::endl;
        R_phi = sqrt(area_fin / M_PI);
        std::cout << "Abs error over expected radius = " << std::abs(R_phi - radius) << '\n' << std::endl;




// Eccentricity (good only for elliptic solutions)
        T radius_max = 1.0 / min_curvature;
        T radius_min = 1.0 / max_curvature;

        T eccentricity = sqrt(1.0 - radius_min * radius_min / (radius_max * radius_max));

        std::cout << bold << green << "Eccentricity = " << eccentricity << reset << std::endl;
        eccentricity_vec.push_back(eccentricity);

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin);
        l1_err_u_n_time.push_back(l1_normal_interface_status);
        linf_err_u_n_time.push_back(max_u_n_val_abs);
        L1_err_u_n_time.push_back(L1_normal_interface_status);

        linf_der_time_interface.push_back(diff_in_time_interface);

        max_val_u_n_time.push_back(max_u_n_val);
        l1_err_curvature_time.push_back(l1_divergence_error_fin);
        linf_err_curvature_time.push_back(linf_divergence_error_fin);


        circularity_time2.push_back(4.0 * M_PI * area_fin / (perimeter * perimeter));
        circularity_time.push_back(M_PI * d_a / perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x / area_fin, centre_mass_y / area_fin));

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back(std::make_pair(rise_vel0 / area_fin, rise_vel1 / area_fin));


        if (tot_time >= final_time) {
            std::cout << "Final time T = " << tot_time << " achieved. Simulation ended at iteration = " << time_step
                      << std::endl;
            std::cout << "Tot amount HHO routines (fixed-point scheme), N = " << time_step << std::endl;
            break;
        }
        tc_iteration.toc();
        std::cout << "Time for this iteration = " << tc_iteration << std::endl;
        plotting_in_time_new(time_vec, area_time, l1_err_u_n_time, linf_err_u_n_time, max_val_u_n_time,
                             l1_err_curvature_time, linf_err_curvature_time, dt_M, min_max_vec, flux_interface_time,
                             rise_velocity_time, centre_mass_err_time, perimeter_time, circularity_time2,
                             circularity_ref, perim_ref, area_ref, radius,
                             L1_err_u_n_time, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time_para,
                             max_val_u_n_time_para, linf_der_time_interface, eccentricity_vec, folder);
    } // End of the temporal loop








    std::cout << "Tot amount transport problem sub-routines tilde{N} = " << tot_amount_transport_routine << std::endl;


    std::cout << "FINAL TIME IS t = " << tot_time << std::endl;

    tc_tot.toc();
    std::cout << "Simulation machine time t = " << tc_tot << std::endl;

    return 0;
}

#endif




// Interface Stokes Problem: Two-fluid problem with FIXED POINT
// -------- Code paper: interface evolution under shear flow - perturbed flow - null flow
// Starting from numerical velocity field and level set - to be uploaded before the simulation

#if 0

int main(int argc, char **argv) {
    using RealType = double;
    RealType sizeBox = 0.5;
    size_t degree = 1;
    size_t int_refsteps = 0; // 4
    size_t degree_FEM = 2;
    size_t degree_curve = 2;
    size_t degree_curvature = 1; // degree_curve -1 ;
    bool dump_debug = false;
    bool solve_interface = true;
    bool solve_fictdom = false;
    bool agglomeration = true;

    bool high_order = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool entropic_mass_consistent = false;
    bool compressed = false; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params <RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

    mip.min_x = -sizeBox;
    mip.min_y = -sizeBox;
    mip.max_x = sizeBox;
    mip.max_y = sizeBox;


    size_t T_N = 10000;
    int ch;
    while ((ch = getopt(argc, argv, "k:q:M:N:r:T:l:p:ifDAdhesgc")) != -1) {
        switch (ch) {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'p':
                degree_curvature = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
                break;

            case 'e':
                entropic = true;
                break;

            case 's':
                entropic_mass_consistent = true;
                break;

            case 'g':
                compressed = true;
                break;

            case 'c':
                cut_off_active = true;
                break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


/************** BUILD MESH **************/

    cuthho_poly_mesh <RealType> msh(mip);
    typedef cuthho_poly_mesh <RealType> Mesh;
    typedef RealType T;
//    typedef typename Mesh::point_type point_type;
    offset_definition(msh);

    std::cout << "Mesh size = " << mip.Nx << "x" << mip.Ny << std::endl;
    std::cout << "Number of refine interface points: r = " << int_refsteps << std::endl;



/************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType, Mesh>(msh, degree_FEM, mip);
    typedef Finite_Element<RealType, Mesh> FiniteSpace;
    std::cout << "Level Set (finite element approximation): Bernstein basis in space Q^{k_phi},  k_phi = " << degree_FEM
              << std::endl;

/**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh);
//typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t degree_gradient = degree_FEM;
    size_t degree_div = degree_FEM;
    std::cout << "Finite element space for gradient and divergence of the LS: grad deg = " << degree_gradient
              << " , div deg = " << degree_div << std::endl;

    auto fe_data_gradient = Finite_Element<RealType, Mesh>(msh, degree_gradient, mip);
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh);
    auto fe_data_div = Finite_Element<RealType, Mesh>(msh, degree_div, mip);
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh);




/**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t degree_velocity = degree_FEM; // std::max(degree + 1 , degree_FEM) ;


// **************** --------> STORING OF LAGRANGIAN NODES
    nodes_Lagrangian_cell_definition(msh, degree_velocity);


    auto fe_data_Lagrange = Finite_Element<RealType, Mesh>(msh, degree_velocity, mip);


    std::cout << "Velocity field: high order Lagrange basis: degree = " << degree_velocity << std::endl;
    auto u_projected = velocity_high_order<Mesh, FiniteSpace, T>(fe_data_Lagrange, msh);

    std::cout << "Uploading velocity field.. " << std::endl;
    u_projected.upload_velocity("FEM_velocityX.txt", "FEM_velocityY.txt");

/************** LEVEL SET FUNCTION DISCRETISATION **************/
    bool circle = true, ellipse = false;
    bool flower = true;
    RealType radius_a, radius_b, radius;
    RealType x_centre = 0.0;
    RealType y_centre = 0.0;
    if (circle) {
        radius = 1.0 / 3.0;
    }

    if (ellipse) {
        radius_a = 1.0 / 12.0;
        radius_b = 1.0 / 24.0;
    }
    if (flower) {

// T radiusOLD = 0.31 ;
// radius_a = 1.0/12.0;
// radius_b = 1.0/24.0;
// radius_a = 1.0/6.0;
// radius_b = 1.0/12.0;
// radius =  sqrt( radius_a * radius_b ) ;
// T ratioR = (radiusOLD*radiusOLD)/(radius*radius);
// T oscillation = 0.04/ratioR ;
        T oscillation = 0.04;
        radius = 1.0 / 3.0;
        std::cout << "Initial interface: FLOWER" << std::endl;
        auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, oscillation); //0.11
        typedef flower_level_set <T> Fonction;
    }

    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre,
                                                              y_centre); // random data, useful only to initialize the level set
    typedef circle_level_set <T> Fonction;
    auto level_set_function = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(fe_data, level_set_function_anal, msh,
                                                                                 fe_data_gradient, fe_data_div);
    typedef Level_set_berstein<Mesh, Fonction, FiniteSpace, T> Level_Set;

    std::cout << "Updating level set.. " << std::endl;
    level_set_function.upload_level_set("FEM_level_set.txt");
    level_set_function.converting_into_FE_formulation(level_set_function.sol_HHO);

// ------------------  IF GRADIENT CONTINUOUS --------------
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//  ------------------ IF DIVERGENCE CONTINUOUS  ------------------
//    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

//-------->  OLD FORMULATION GRAD CONT
//    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//    level_set_function.gradient_continuous_setting() ;
//    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;




    std::cout << "Parametric interface: degree_curve = " << degree_curve << std::endl;
    auto curve = Interface_parametrisation_mesh1d(degree_curve);
    size_t degree_det_jac_curve = curve.degree_det; // 2*degree_curve INUTILE PER ORA
// integration CUT CELL degree += 2*degree_curve
// integration INTERFACE degree += degree_curve-1

//auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
//auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);





/************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh = Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i = crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


/************** INITIAL DATA INITIALISATION (t = 0) **************/
    T dt = 0.;
    T initial_area = 0., initial_mass = 0.;
    T d_a = 0.;
    T perimeter_initial = 0.;
    T centre_mass_x_inital = 0., centre_mass_y_inital = 0.;
    T max_u_n_val_old = 1e+6, max_u_n_val_new = 1e+5;
    T check = 10.0;
    T tot_time = 0.;

/************** BOUNDARY CONDITIONS **************/
    std::cout << yellow << bold << "INLET BDRY: UP AND DOWN FOR DIRCIRCHLET_eps FP" << reset << std::endl;
    bool bdry_bottom = false, bdry_up = false;
    bool bdry_left = false, bdry_right = false;
    check_inlet(msh, fe_data, bdry_bottom, bdry_right, bdry_up, bdry_left, 1e-14);


//************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
//detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration) {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
//detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
        set_integration_mesh(msh_i, degree_curve);
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);

        make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
        set_integration_mesh(msh_i, degree_curve); // TOLTO PER IL MOMENTO SENNO RADDOPPIO
//        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    } else {
        detect_cut_cells3(msh_i, level_set_function);
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << '\n' << std::endl;

    if (dump_debug) {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }



// IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

/************** UPDATING  LEVEL SET  AND VELOCITY  **************/
//    level_set_function.gradient_continuous_setting() ;
//    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;


// --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\

// IF grad cont -> normal cont -> (divergence disc) -> divergence cont
//auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad cont -> normal cont -> divergence disc
    auto ls_cell = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(level_set_function,
                                                                                                    msh_i);

// IF grad disc -> normal disc -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
// IF grad disc -> normal disc -> divergence disc -> normal and grad cont
//    auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

//-------------------------- OLD CASE LS_CELL --------------------------
//    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i );



    ls_cell.radius = radius;
    u_projected.set_agglo_mesh(msh_i);

    timecounter tc_initial;
    tc_initial.tic();



/************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector <T> max_val_u_n_time_para, L1_err_u_n_time_para, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time;
    std::vector <T> area_time, l1_err_u_n_time, linf_err_u_n_time, time_vec;
    std::vector <T> linf_der_time_interface, eccentricity_vec;
    std::vector <T> max_val_u_n_time, l1_err_curvature_time, linf_err_curvature_time;
    std::vector <T> circularity_time, circularity_time2, flux_interface_time, perimeter_time;
    std::vector <std::pair<T, T>> centre_mass_err_time, rise_velocity_time, min_max_vec;
    T circularity_ref = 0.0, perim_ref = 0.0, area_ref = 0.0;
    T l1_divergence_error = 0., l2_divergence_error = 0.;
    T linf_divergence_error = -10.;
    T L1_divergence_error = 0.;

    check_goal_quantities(msh_i, ls_cell, perimeter_initial, d_a, initial_area, centre_mass_x_inital,
                          centre_mass_y_inital, degree_FEM, initial_mass, flower, l1_divergence_error,
                          l2_divergence_error, linf_divergence_error, radius, L1_divergence_error, ellipse,
                          degree_curve, int_refsteps);



//------------------------ CHECK REFERENCE QUANTITIES ---------------------------//
    reference_quantities_computation(perim_ref, area_ref, circularity_ref, radius, x_centre, y_centre, fe_data, msh,
                                     degree_curve, perimeter_initial, initial_area, int_refsteps, degree_det_jac_curve);

//    plot_curvature_normal_vs_curv_abscisse(msh_i, ls_cell, degree_curve,int_refsteps , 0 );

    plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, ls_cell, degree_curve, int_refsteps, 0, degree_curvature);


    tc_initial.toc();
//    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    circularity_time.push_back(M_PI * d_a / perimeter_initial);
    circularity_time2.push_back(4.0 * M_PI * initial_area / (perimeter_initial * perimeter_initial));
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(
            std::make_pair(centre_mass_x_inital / initial_area, centre_mass_y_inital / initial_area));
    time_vec.push_back(0);
    area_time.push_back(initial_area);

    min_max_vec.push_back(std::make_pair(level_set_function.phi_min, level_set_function.phi_max));

    l1_err_curvature_time.push_back(l1_divergence_error);
    linf_err_curvature_time.push_back(linf_divergence_error);

    T dt_M;
    T R_phi = radius;

    size_t tot_amount_transport_routine = 0;


    bool l2proj_para = false;

    bool l2proj = true;
    bool avg = false;
    bool disc = false;
    bool filter = false;

    Interface_parametrisation_mesh1d_global <Mesh> para_curve_cont(msh_i, degree_curve, degree_curvature);

// *********************** DERIVATIVE / NORMAL PARA *************************//
//------------- L2 cont curvature from parametric interface  r ---------- //
    para_curve_cont.make_L2_proj_para_derivative(msh_i);

//---------------------------- L2 global Normal from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_normal_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Normal from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_normal_disc(msh_i, ls_cell);
    }


// *********************** CURVATURE PARA *************************//

//------------- L2 cont curvature from parametric interface  r ---------- //
    if (l2proj_para)
        para_curve_cont.make_L2_proj_para_curvature(msh_i);



//---------------------------- L2 global Curvature from LS  ----------------------- //
    if (l2proj) {
        if (!disc)
            para_curve_cont.make_L2_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_L2_proj_para_curvature_disc(msh_i, ls_cell);
    }
//---------------------------- Avg Curvature from LS  ---------------------------- //
    if (avg) {
        if (!disc)
            para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
        else
            para_curve_cont.make_avg_L2_local_proj_para_curvature_disc(msh_i, ls_cell);

    }
    if (filter)
        para_curve_cont.make_smooth_filter_curvature();

// ******** TO FASTER THE SIMULATION, ERASED THE PLOTTINGS
    plotting_para_curvature_cont_time_fast(msh_i, para_curve_cont, degree_curve, degree_FEM, radius, 0, int_refsteps);

    T final_time = 3.0;

    T eps_dirichlet_cond = 0.26; //0.26; 0.59 ; // 0.01 -->  0.1

    for (size_t time_step = 0; time_step <= T_N; time_step++) {
        timecounter tc_iteration;
        tc_iteration.tic();
        std::cout << '\n' << bold << yellow << "Starting iteration numero  = " << time_step << " --> time t = "
                  << tot_time << reset << std::endl;
        std::cout << "Dirichlet eps Cond = " << eps_dirichlet_cond << std::endl;

// -----------------------------------------------------------------------------------------
// ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
// -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        T gamma = 1.0; // 0.05;


        savingVelocityLevelSet(level_set_function, u_projected);


        std::cout << '\n' << bold << yellow << "HHO flow resolution." << reset << '\n' << std::endl;


// ------------------ OLD VERSIONS ------------------
//auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
// Non serve modificare Gamma = 1/2
//auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
//auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
// ------------- OLD GUILLAUME VERSIONS --------------
// auto test_case = make_test_case_stokes_1(msh, level_set_function);
// auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

// ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
//auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
// PRESSURE SIGN NOT CORRECT
// ---------------------- ESHELBY VERSION LEVEL SET - CORRECT ------------------------
//        auto test_case = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT
// -------------------- ESHELBY VERSION PARAMETRIC (DISC) - CORRECT -------------------
//        auto test_case = make_test_case_eshelby_correct_parametric(msh_i, ls_cell,  prm , sym_grad,gamma);
// PRESSURE SIGN NOT CORRECT




// -------------------- ESHELBY VERSION PARAMETRIC (CONT) - CORRECT -------------------
// domain  (0,1)^2 - null flow
//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );

// domain  (-a,a)^2 - shear flow
//  auto test_case_prova = make_test_case_eshelby_parametric_cont_eps_DIR_domSym( msh_i, ls_cell ,para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond); // sizeBox

// domain  (0,1)^2 - shear flow

//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont_DIRICHLET_eps( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond);

// domain  (-a,a)^2 - new test case perturbated
        T perturbation = 0.5;
        auto test_case_prova = make_test_case_eshelby_parametric_cont_eps_perturbated_DIR_domSym(msh_i, ls_cell,
                                                                                                 para_curve_cont, prm,
                                                                                                 sym_grad, gamma,
                                                                                                 eps_dirichlet_cond,
                                                                                                 perturbation);
// domain  (0,1)^2 - new test case perturbated
//        T perturbation = 0.5;
//     auto test_case_prova = make_test_case_shear_flow_perturbated( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond,perturbation );
//        auto test_case_prova = make_test_case_shear_y( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond,perturbation );
// New test case TGV - fixed point
//        auto test_case_prova = make_test_case_TGV_FPscheme( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma , eps_dirichlet_cond );



//        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont_TGV_source( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );
// ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
//        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);
// -------------------- HHO METHOD FOR DISC PARAMETRIC INTERFACE  -----------------------
//         auto method = make_sym_gradrec_stokes_interface_method_perturbationref_pts(msh_i, 1.0, 0.0, test_case, sym_grad);


// -------------------- HHO METHOD FOR CONT PARAMETRIC INTERFACE  -----------------------
        auto method_prova = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh_i, 1.0, 0.0, test_case_prova,
                                                                                  sym_grad);




//  ******************** - HHO RESOLUTION - ********************
        if (solve_interface) {
// ----------------- HHO RESOLUTION OLD CASE  --------------------------
//            TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
//            run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

// ----------------- HHO RESOLUTION LS / PARAMETRIC DISC  ---------------------
//            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW

// ----------------- HHO RESOLUTION PARAMETRIC CONT  --------------------------
//             run_cuthho_interface_velocity_new(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            run_cuthho_interface_velocity_fast(msh_i, degree, method_prova, test_case_prova, ls_cell, u_projected,
                                               sym_grad, time_step); // CORRECT BUT DOEST NOT COMPUTE ERRORS
        }
//        testing_velocity_field(msh , u_projected) ;
/************************************ FEM -  PRE-PROCESSING ******************************************/
// ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if (0)
            std::cout << bold << green
                      << "CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"
                      << reset << std::endl;

        if (0) //results of the paper with this
        {
            std::cout << '\n' << "Smoothing operator from velocity HHO to FE (continuity imposed): geometrical average."
                      << std::endl;
            u_projected.smooth_converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (1) //weighted implementation - reviewer results
        {
            std::cout << '\n' << "Smoothing operator from velocity HHO to FE (continuity imposed): geometrical average."
                      << std::endl;
            u_projected.smooth_converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (0) {
            std::cout << '\n' << "------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM." << std::endl;
            u_projected.converting_into_FE_formulation(u_projected.sol_HHO);
        }
        if (0) {
            std::cout << '\n' << "------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM." << std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function, msh, method_transport_pb);
        }


//testing_velocity_field(msh , u_projected) ;
//auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
//u_prova.sol_HHO = u_projected.sol_HHO ;
//u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
//testing_velocity_field_L2projected(msh , u_prova) ;

        T rise_vel0 = 0.0, rise_vel1 = 0.0;
        T flux_interface = 0.0;

        if (time_step == 0) {
            T max_u_n_val_initial = 0.0;
            T max_u_n_val_abs_initial = 0.0;
            T l1_normal_interface_status_initial = 0.;

            T L1_normal_interface_status_initial = 0.;

            size_t counter_interface_pts_initial = 0;
            for (auto &cl: msh_i.cells) {
                if (cl.user_data.location == element_location::ON_INTERFACE) {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);

                    auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity,
                                                   element_location::ON_INTERFACE);
                    for (auto &qp: qps) {
                        auto u_pt = u_projected(qp.first);

                        auto ls_n_pt = ls_cell.normal(qp.first);
                        T u_n_val = u_pt.first * ls_n_pt(0) + u_pt.second * ls_n_pt(1);
                        L1_normal_interface_status_initial += qp.second * std::abs(u_n_val);
                        max_u_n_val_abs_initial = std::max(max_u_n_val_abs_initial, std::abs(u_n_val));
                        if (std::abs(u_n_val) == max_u_n_val_abs_initial)
                            max_u_n_val_initial = u_n_val;

                        l1_normal_interface_status_initial += std::abs(u_n_val);
                        counter_interface_pts_initial++;


                    }

                }

            }
            l1_normal_interface_status_initial /= counter_interface_pts_initial;
            l1_err_u_n_time.push_back(l1_normal_interface_status_initial);
            linf_err_u_n_time.push_back(max_u_n_val_abs_initial);
//            linf_der_time_interface.push_back(0) ;
            max_val_u_n_time.push_back(max_u_n_val_initial);
            L1_err_u_n_time.push_back(L1_normal_interface_status_initial);

            std::cout << "------> The l1 error of u*n along the INTERFACE at INITIAL TIME is "
                      << l1_normal_interface_status_initial << std::endl;

            std::cout << bold << green << "------> The linf error of u*n along the INTERFACE at INITIAL TIME is "
                      << max_u_n_val_abs_initial << reset << std::endl;

            std::cout << "------> The L1 error of u*n along the INTERFACE at INITIAL TIME is "
                      << L1_normal_interface_status_initial << std::endl;


            size_t degree_curvature = para_curve_cont.dd_degree;
            size_t degree_jacobian = para_curve_cont.degree_det;

            T L1_normal_interface_para = 0.0;
            T linf_u_n_para = 0.0;
            T max_u_n_val_para = 0.0;
            T l1_normal_interface_para = 0.0;
            size_t counter_interface_pts_para = 0;


            T area_para = 0.0;

            for (auto &cl: msh_i.cells) {

                if ((location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) ||
                    (location(msh_i, cl) == element_location::ON_INTERFACE)) {
                    u_projected.cell_assignment(cl);
                    T partial_area = measure(msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                    area_para += partial_area;

                    size_t max_deg = std::max(degree_velocity, degree_FEM);
                    auto qps_fin = integrate(msh_i, cl, max_deg, element_location::IN_NEGATIVE_SIDE);


                    for (auto &qp: qps_fin) {
                        auto u_pt = u_projected(qp.first);
                        rise_vel0 += qp.second * u_pt.first;
                        rise_vel1 += qp.second * u_pt.second;
                    }

                }


                if (cl.user_data.location == element_location::ON_INTERFACE) {
                    u_projected.cell_assignment(cl);
                    auto global_cells_i = para_curve_cont.get_global_cells_interface(msh_i, cl);
                    auto integration_msh = cl.user_data.integration_msh;
//                    auto degree_int = degree_curvature + degree_jacobian ;


                    auto qps_un = edge_quadrature<T>(degree_jacobian + degree_curvature + degree_velocity);

                    for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++) {
                        auto pts = points(integration_msh, integration_msh.cells[i_cell]);
                        size_t global_cl_i = global_cells_i[i_cell];

                        for (auto &qp: qps_un) {
                            auto t = 0.5 * qp.first.x() + 0.5;

                            T jacobian = para_curve_cont.jacobian_cont(t, global_cl_i);
                            auto w = 0.5 * qp.second * jacobian;
                            auto p = para_curve_cont(t, global_cl_i);
                            auto pt = typename Mesh::point_type(p(0), p(1));
                            auto u_pt = u_projected(pt);
                            auto curve_n_pt = para_curve_cont.normal_cont(t, global_cl_i);
                            T flux = u_pt.first * curve_n_pt(0) + u_pt.second * curve_n_pt(1);
                            flux_interface += w * flux;

                            L1_normal_interface_para += w * std::abs(flux);
                            linf_u_n_para = std::max(linf_u_n_para, std::abs(flux));
                            if (std::abs(flux) == linf_u_n_para)
                                max_u_n_val_para = flux;

                            l1_normal_interface_para += std::abs(flux);
                            counter_interface_pts_para++;

                        }
                    }
                }
            }
            l1_normal_interface_para /= counter_interface_pts_para;
            l1_err_u_n_time_para.push_back(l1_normal_interface_para);
            linf_err_u_n_time_para.push_back(linf_u_n_para);
            L1_err_u_n_time_para.push_back(L1_normal_interface_para);
            max_val_u_n_time_para.push_back(max_u_n_val_para);
            flux_interface_time.push_back(flux_interface);
            rise_velocity_time.push_back(std::make_pair(rise_vel0 / area_para, rise_vel1 / area_para));

            std::cout << "------> The l1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << l1_normal_interface_para << std::endl;

            std::cout << bold << yellow
                      << "------> The linf error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << linf_u_n_para << reset << std::endl;

            std::cout << "------> The L1 error of PARA_CONT u*n along the INTERFACE at INITIAL TIME is "
                      << L1_normal_interface_para << std::endl;
        }
// -----------------------------------------------------------------------------------------
// ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
// -----------------------------------------------------------------------------------------


//------------- MACRO TIME STEP dt -------------
//(before checking if it is too big, I need to find the new interface)
        T dt_M_max = 0.1; // 0.1 ; //5e-2 ; //5e-2; // phi_h 1e-3 e dt_m^MAX = 1e-4 not enought (oscillation )

//if(tot_time < 0.75)
        T eps = 0.05; //1.0 ; // 0.05 ; // factor to be inside CFL stability zone IT WAS 0.4
        T dt_one_cell = time_step_CFL_new(u_projected, mip, eps);

// Stokes time step maximum
        T c2 = 2.0; // 2.0; // it was 1
        T eta = std::min(prm.kappa_1, prm.kappa_2);
        T dt_STK = time_step_STK(eta, gamma, mip, c2);
        dt_M = std::min(dt_one_cell, dt_STK);

// dt_M =  dt_M * 0.1 ; // add 23/09/2021

// ------> ADAPTIVE SCHEME
//        dt_M = dt_one_cell * 0.1 ;
//        dt_M = floorf(dt_M * 1000) / 1000;

//        T dt_M_max ;
//        if( std::max(mip.hx() , mip.hy() ) <= 16 )
//            dt_M_max = 0.1;
//        else if( std::max(mip.hx() , mip.hy() ) == 32 )
//            dt_M_max = 5e-2;
//        else
//            dt_M_max = 5e-2;



        dt = std::min(dt_M_max, dt_M); //5e-2 for mesh 32x32, 0.1 for  mesh 16x16, 8x8

        if (final_time < (dt + tot_time)) {
            std::cout << "Last step, dt_M changed to arrive at T." << std::endl;
            dt = final_time - tot_time;

        }
        int N_sub = 10; //N_sub = 20 for BOH, N_sub = 10 for  mesh 16x16, 8x8, 32x32
// ------> FIXED  SCHEME
//        dt_M =  8*1e-3; // FOR LS low phi_L order-> 8*1e-3; // FOR LS high order phi_H ->  2*1e-3;
//        dt = std::min(dt_one_cell , dt_M);
//        T N_sub = 20 ;  // N_sub = 20 for mesh 32x32, N_sub = 10 for  mesh 16x16,  N_sub = 40 for phi_H
//std::cout<<"dt1 is "<<dt1<<std::endl;


        std::cout << '\n' << "Macro time step dt_M = " << dt << ", dt_h = " << dt_one_cell << ", dt_STK = " << dt_STK
                  << std::endl;

// I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = dt / N_sub; //std::min(4*1e-4 , dt ) ;

// ------> ADAPTIVE SCHEME
// It is phi_L: > 1e-3 for 16x16 and 8x8  ; > 5e-4 for 32x32
// It is phi_H: > 1e-4 for 16x16 and 8x8  ; > 5e-4 for 32x32
        if (sub_dt > 1e-3) {
            sub_dt = 1e-3;
            N_sub = floor(dt / sub_dt); // N_sub varies between 10 and 100 depending on sub_dt

        }


        auto level_set_old = Level_set_berstein<Mesh, Fonction, FiniteSpace, T>(level_set_function);
        auto ls_old = LS_cell_high_order_grad_cont_div_disc<T, Mesh, Level_Set, Fonction, FiniteSpace>(level_set_old,
                                                                                                       msh_i);


        std::cout << "-----> Implemented sub time dt_m = " << sub_dt << std::endl;

// ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        std::cout << yellow << bold << "----------- STARTING TRANSPORT PROBLEM SUB-ROUTINE: tilde{N} = " << N_sub
                  << "-----------" << reset << std::endl;
        timecounter tc_case_tr;
        tc_case_tr.tic();
        while (sub_time < sub_dt * N_sub) {
// std::pair<T,T> CFL_numb;
            if (high_order) {
//           CFL_numb = run_transport_high_order_FTC_M_lumped( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false );

                run_transport_high_order_FTC_M_consistent(level_set_function.msh, fe_data, level_set_function,
                                                          u_projected, method_transport_pb, sub_dt, false);

//            CFL_numb = run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_CONS_LIMITED( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false ); // CORRECT 25/01/21

            } else if (entropic) {
                run_transport_entropic_M_lumped_Ri_correct(level_set_function.msh, fe_data, level_set_function,
                                                           u_projected, method_transport_pb, sub_dt, false);
//             CFL_numb = run_transport_entropic_M_lumped ( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false );
//            CFL_numb = run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS_M_LUMPED_NO_LIMITING ( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , false ); // CORRECT 25/01/21
            } else {
//                if(degree_velocity == degree_FEM) // IT IS FASTER
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(level_set_function.msh, fe_data,
                                                                                   level_set_function, u_projected,
                                                                                   method_transport_pb,
                                                                                   sub_dt); // CORRECT 25/01/21
//                else // IT WORKS BUT IT'S MUCH SLOWER
//                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt;

        }
        tot_time += sub_time;

        tc_case_tr.toc();
        std::cout << yellow << bold << "----------- THE END OF TRANSPORT PROBLEM SUB-ROUTINE: machine time t = "
                  << tc_case_tr << " s -----------" << reset << std::endl;
        tot_amount_transport_routine += N_sub;

/**************************************************   POST-PROCESSING **************************************************/


// Updating continuous normal function
//            level_set_function.gradient_continuous_setting() ;
// IF GRADIENT CONTINUOUS
        level_set_function.gradient_continuous_setting(method_transport_pb_grad);
//         // IF DIVERGENCE CONTINUOUS
//         level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

// Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i = crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration) {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom

            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
            set_integration_mesh(msh_i, degree_curve);

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
//refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
//refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration_no_double_points(msh_i, level_set_function, degree_det_jac_curve);
// make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            set_integration_mesh(msh_i, degree_curve);
        } else {
            move_nodes(msh_i, level_set_function);
            detect_cut_cells3(msh_i, level_set_function);
            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps, degree_curve);
//refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }


        tc.toc();
        std::cout << '\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

        if (dump_debug) {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

// TOLTO TO BE FASTER
        if (time_step % 20 == 0) {
            output_mesh_info2_time(msh_i, level_set_function, tot_time, time_step);
            testing_level_set_time(msh, level_set_function, tot_time, time_step);
            plot_u_n_interface(msh_i, ls_cell, u_projected, time_step);
            testing_velocity_field(msh, u_projected, time_step);
        }
//        output_mesh_info2_time_fixed_mesh(msh_i, level_set_function,tot_time,time_step);
        testing_level_set(msh, level_set_function);
// Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh(msh_i);


        T max_u_n_val = 0.0;
        T max_u_n_val_abs = 0.0;

        T diff_in_time_interface = 0.0;
        T l1_normal_interface_status = 0.;

        T L1_normal_interface_status = 0.;

        size_t counter_interface_pts = 0;
        for (auto &cl: msh_i.cells) {
            if (cl.user_data.location == element_location::ON_INTERFACE) {
                ls_cell.cell_assignment(cl);
                ls_old.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                for (auto &qp: qps) {
                    auto u_pt = u_projected(qp.first);
                    auto ls_n_pt = ls_cell.normal(qp.first);
                    T u_n_val = u_pt.first * ls_n_pt(0) + u_pt.second * ls_n_pt(1);
                    L1_normal_interface_status += qp.second * std::abs(u_n_val);
                    max_u_n_val_abs = std::max(max_u_n_val_abs, std::abs(u_n_val));

                    diff_in_time_interface = std::max(diff_in_time_interface,
                                                      (std::abs(ls_cell(qp.first) - ls_old(qp.first))) / sub_time);
                    if (std::abs(u_n_val) == max_u_n_val_abs)
                        max_u_n_val = u_n_val;

                    l1_normal_interface_status += std::abs(u_n_val);
                    counter_interface_pts++;

                }


            }
        }

        if (time_step == 0)
            max_u_n_val_new = max_u_n_val;

        if (time_step > 0) {
            max_u_n_val_old = max_u_n_val_new;
            max_u_n_val_new = max_u_n_val;
            std::cout << bold << yellow << "l^{inf} u*n(t^n) = " << max_u_n_val_old << " , l^{inf} u*n(t^{n+1}) = "
                      << max_u_n_val_new << reset << std::endl;
        }

        std::cout << "Number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;

        std::cout << "-----------------------> The l1 error of u*n over the INTERFACE, at time t = " << tot_time
                  << " is " << l1_normal_interface_status << reset << std::endl;

        std::cout << bold << green << "-----------------------> The linf error of u*n over the INTERFACE, at time t = "
                  << tot_time << " is " << max_u_n_val_abs << reset << std::endl;

        std::cout << "-----------------------> The L1 error of u*n over the INTERFACE, at time t = " << tot_time
                  << " is " << L1_normal_interface_status << reset << std::endl;

        std::cout << bold << green << "---> The linf error of (phi^{n+1}-phi{n})/dt over the INTERFACE, at time t = "
                  << tot_time << " is " << diff_in_time_interface << reset << std::endl;








// ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status;
/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

//if(check < 1e-8 )
//{
//    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
//    return 0;
//}





        T mass_fin = 0., area_fin = 0.;
        T centre_mass_x = 0., centre_mass_y = 0.;
        T l1_divergence_error_fin = 0., l2_divergence_error_fin = 0.;
        T linf_divergence_error_fin = 0.;
        T perimeter = 0.;
        T L1_divergence_error_fin = 0.;


        size_t counter_interface_pts_fin = 0.0;
//
//------------ Updating Parametric interface
        para_curve_cont.updating_parametric_interface(msh_i, ls_cell, l2proj, avg, l2proj_para, disc);

        if (filter) {
            plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, int_refsteps, para_curve_cont, time_step);
            para_curve_cont.make_smooth_filter_curvature();
        }

//        para_curve_cont.plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh, n_int);

        T L1_normal_interface_para = 0.0;
        T linf_u_n_para = 0.0;
        T max_u_n_val_para = 0.0;
        T l1_normal_interface_para = 0.0;
        size_t counter_interface_pts_para = 0;
        T max_curvature = 0;
        T min_curvature = 1e+6;
        plot_curvature_normal_vs_curv_abscisse(msh_i, ls_cell, degree_curve, int_refsteps, 1);
        plot_curvature_normal_vs_curv_abscisse_PARAMETRIC(msh_i, degree_curve, int_refsteps, 1, degree_curvature,
                                                          para_curve_cont);

//        check_goal_quantities_final_para( msh_i ,ls_cell, para_curve_tmp , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface, counter_interface_pts_fin,degree_curve,int_refsteps, L1_normal_interface_para,linf_u_n_para,max_u_n_val_para,l1_normal_interface_para,counter_interface_pts_para);

        check_goal_quantities_final_para_no_plot(msh_i, ls_cell, para_curve_cont, u_projected, perimeter, d_a, area_fin,
                                                 centre_mass_x, centre_mass_y, degree_FEM, mass_fin, degree_velocity,
                                                 l1_divergence_error_fin, l2_divergence_error_fin,
                                                 linf_divergence_error_fin, radius, L1_divergence_error_fin, 1,
                                                 rise_vel0, rise_vel1, flux_interface, counter_interface_pts_fin,
                                                 degree_curve, int_refsteps, L1_normal_interface_para, linf_u_n_para,
                                                 max_u_n_val_para, l1_normal_interface_para, counter_interface_pts_para,
                                                 max_curvature, min_curvature);

        std::cout << "PARA-FLUX at the INTERFACE, at time " << tot_time << " is " << flux_interface << std::endl;
//        std::cout<<"PARA-L1(un) at the INTERFACE, at time "<< tot_time <<" is " << L1_normal_interface_para <<std::endl;

        l1_normal_interface_para /= counter_interface_pts_para;
//        std::cout<<"PARA-l1(un) at the INTERFACE, at time "<< tot_time <<" is " << l1_normal_interface_para <<std::endl;
//        std::cout<<"PARA-linf(un) at the INTERFACE, at time "<< tot_time <<" is " << linf_u_n_para <<std::endl;
//        std::cout<<"PARA-linf(un) SIGNED at the INTERFACE, at time "<< tot_time <<" is " << max_u_n_val_para <<std::endl;

        l1_err_u_n_time_para.push_back(l1_normal_interface_para);
        linf_err_u_n_time_para.push_back(linf_u_n_para);
        L1_err_u_n_time_para.push_back(L1_normal_interface_para);
        max_val_u_n_time_para.push_back(max_u_n_val_para);

//        check_goal_quantities_final( msh_i , ls_cell , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);
//

        testing_level_set_max_min(msh, level_set_function, time_step, min_max_vec);


        l1_divergence_error_fin /= counter_interface_pts_fin;


        std::cout << "The l1 error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time << " is "
                  << l1_divergence_error_fin << std::endl;

        std::cout << bold << green << "The linf error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time
                  << " is " << linf_divergence_error_fin << reset << std::endl;

        std::cout << "The L1 error of the PARA_CONT CURVATURE at the INTERFACE, at time " << tot_time << " is "
                  << L1_divergence_error_fin << std::endl;








//        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

//        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0 * area_fin / M_PI);

        std::cout << "The CIRCULARITY (OLD), at time " << tot_time << " is " << M_PI * d_a / perimeter << std::endl;
        std::cout << "The CIRCULARITY, at time " << tot_time << " is "
                  << 4.0 * M_PI * area_fin / (perimeter * perimeter) << std::endl;
        std::cout << "Area at time step: " << tot_time << " is " << area_fin << std::endl;
//        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME " << tot_time << " IS "
                  << (area_fin - initial_area) / initial_area << reset << std::endl;
//        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: " << tot_time << " is " << " ( " << centre_mass_x / area_fin << " , "
                  << centre_mass_y / area_fin << " ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: " << tot_time << " is " << " ( "
                  << centre_mass_x / area_fin - centre_mass_x_inital / initial_area << " , "
                  << centre_mass_y / area_fin - centre_mass_y_inital / initial_area << " ). " << std::endl;
        R_phi = sqrt(area_fin / M_PI);
        std::cout << "Abs error over expected radius = " << std::abs(R_phi - radius) << '\n' << std::endl;




// Eccentricity (good only for elliptic solutions)
        T radius_max = 1.0 / min_curvature;
        T radius_min = 1.0 / max_curvature;

        T eccentricity = sqrt(1.0 - radius_min * radius_min / (radius_max * radius_max));

        std::cout << bold << green << "Eccentricity = " << eccentricity << reset << std::endl;
        eccentricity_vec.push_back(eccentricity);

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin);
        l1_err_u_n_time.push_back(l1_normal_interface_status);
        linf_err_u_n_time.push_back(max_u_n_val_abs);
        L1_err_u_n_time.push_back(L1_normal_interface_status);

        linf_der_time_interface.push_back(diff_in_time_interface);

        max_val_u_n_time.push_back(max_u_n_val);
        l1_err_curvature_time.push_back(l1_divergence_error_fin);
        linf_err_curvature_time.push_back(linf_divergence_error_fin);


        circularity_time2.push_back(4.0 * M_PI * area_fin / (perimeter * perimeter));
        circularity_time.push_back(M_PI * d_a / perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x / area_fin, centre_mass_y / area_fin));

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back(std::make_pair(rise_vel0 / area_fin, rise_vel1 / area_fin));


        if (tot_time >= final_time) {
            std::cout << "Final time T = " << tot_time << " achieved. Simulation ended at iteration = " << time_step
                      << std::endl;
            std::cout << "Tot amount HHO routines (fixed-point scheme), N = " << time_step << std::endl;
            break;
        }
        tc_iteration.toc();
        std::cout << "Time for this iteration = " << tc_iteration << std::endl;
        plotting_in_time_new(time_vec, area_time, l1_err_u_n_time, linf_err_u_n_time, max_val_u_n_time,
                             l1_err_curvature_time, linf_err_curvature_time, dt_M, min_max_vec, flux_interface_time,
                             rise_velocity_time, centre_mass_err_time, perimeter_time, circularity_time2,
                             circularity_ref, perim_ref, area_ref, radius,
                             L1_err_u_n_time, l1_err_u_n_time_para, linf_err_u_n_time_para, L1_err_u_n_time_para,
                             max_val_u_n_time_para, linf_der_time_interface, eccentricity_vec);
    } // End of the temporal loop








    std::cout << "Tot amount transport problem sub-routines tilde{N} = " << tot_amount_transport_routine << std::endl;


    std::cout << "FINAL TIME IS t = " << tot_time << std::endl;

    tc_tot.toc();
    std::cout << "Simulation machine time t = " << tc_tot << std::endl;

    return 0;
}

#endif





// Interface Stokes Problem: Fictitious domain
// Couette problem & M-shaped domain - comparison with HDG
// Ongoing work --> maybe use code of cuthho_stokes
#if
0

int main(int argc, char **argv) {
    using RealType = double;

    size_t degree = 0;
    size_t int_refsteps = 4;

    bool dump_debug = false;
    bool solve_interface = false;
    bool solve_fictdom = false;
    bool agglomeration = false;

    mesh_init_params <RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

/* k <deg>:     method degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ((ch = getopt(argc, argv, "k:M:N:r:ifDAd")) != -1) {
        switch (ch) {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

/************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh <RealType> msh(mip);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;
/************** LEVEL SET FUNCTION **************/
//    RealType radius = 1.0/3.0;
//    auto level_set_function = circle_level_set<RealType>(radius, 0.5, 0.5);
//     auto level_set_function = line_level_set<RealType>(0.5);
//     auto level_set_function = flower_level_set<RealType>(0.31, 0.5, 0.5, 4, 0.04);
    RealType eps = 0.005; // 0.25-1e-10; // 0.1;
    RealType epsBndry = 1e-8; //  0.15;
    RealType pos_sides = 0.25; // 0.0;
    auto level_set_function = m_shaped_level_set<RealType>(eps, epsBndry, pos_sides);


//    RealType R = 0.35;
//    auto level_set_function = rotated_square<RealType>(0.5 , 0.5 , R );
// RealType epsBndry  = -2.0*1e-2 ;
// auto level_set_function = square_level_set<RealType>(0.75-epsBndry,0.25+epsBndry,0.25+epsBndry,0.75-epsBndry);

//    RealType radius_a , radius_b,radius ;
//    RealType x_centre = 0.5;
//    RealType y_centre = 0.5;
//
//    radius_a = 1.0/6.0;
//    radius_b = 1.0/3.0;
//    radius = radius_a;
//
//    std::cout<<"Couette immersed domain: R1 = "<<radius_a<<", R2 = "<<radius_b<<std::endl;
//    auto level_set_function = couette_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);




/************** DO cutHHO MESH PROCESSING **************/

    tc.tic();
    detect_node_position(msh, level_set_function);
    detect_cut_faces(msh, level_set_function);

    if (agglomeration) {
        detect_cut_cells(msh, level_set_function);
        detect_cell_agglo_set(msh, level_set_function);
        make_neighbors_info_cartesian(msh);
// make_neighbors_info(msh);
        refine_interface(msh, level_set_function, int_refsteps);
        make_agglomeration(msh, level_set_function);
    } else {
        move_nodes(msh, level_set_function);
        detect_cut_faces(msh, level_set_function); //do it again to update intersection points
        detect_cut_cells(msh, level_set_function);
        refine_interface(msh, level_set_function, int_refsteps);
    }


    tc.toc();
    std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

    if (dump_debug) {
        dump_mesh(msh);
        output_mesh_info(msh, level_set_function);
    }

    output_mesh_info(msh, level_set_function);

// auto test_case = make_test_case_stokes_1(msh, level_set_function);
//    auto test_case = make_test_case_stokes_2(msh, level_set_function);
// auto test_case = make_test_case_kink_velocity(msh, .... );
    auto test_case = make_test_case_M_shaped(msh, 1.0, level_set_function);

//auto test_case = make_test_case_kink_velocity2(msh, level_set_function);

//    checkNormal(msh,level_set_function,2.0);
    auto cauchyFormulation = false;
    auto method = make_sym_gradrec_stokes_interface_method(msh, 1.0, 0.0, test_case, cauchyFormulation);


    if (solve_interface)
        run_cuthho_interface(msh, degree, method, test_case);

    if (solve_fictdom)
        run_cuthho_fictdom(msh, degree, test_case);


    return 0;
}

#endif
